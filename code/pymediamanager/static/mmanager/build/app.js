/*! For license information please see app.js.LICENSE.txt */
!(function (t) {
    var e = {};
    function n(r) {
        if (e[r]) return e[r].exports;
        var s = (e[r] = { i: r, l: !1, exports: {} });
        return t[r].call(s.exports, s, s.exports, n), (s.l = !0), s.exports;
    }
    (n.m = t),
        (n.c = e),
        (n.d = function (t, e, r) {
            n.o(t, e) ||
                Object.defineProperty(t, e, { enumerable: !0, get: r });
        }),
        (n.r = function (t) {
            "undefined" != typeof Symbol &&
                Symbol.toStringTag &&
                Object.defineProperty(t, Symbol.toStringTag, {
                    value: "Module",
                }),
                Object.defineProperty(t, "__esModule", { value: !0 });
        }),
        (n.t = function (t, e) {
            if ((1 & e && (t = n(t)), 8 & e)) return t;
            if (4 & e && "object" == typeof t && t && t.__esModule) return t;
            var r = Object.create(null);
            if (
                (n.r(r),
                Object.defineProperty(r, "default", {
                    enumerable: !0,
                    value: t,
                }),
                2 & e && "string" != typeof t)
            )
                for (var s in t)
                    n.d(
                        r,
                        s,
                        function (e) {
                            return t[e];
                        }.bind(null, s)
                    );
            return r;
        }),
        (n.n = function (t) {
            var e =
                t && t.__esModule
                    ? function () {
                          return t.default;
                      }
                    : function () {
                          return t;
                      };
            return n.d(e, "a", e), e;
        }),
        (n.o = function (t, e) {
            return Object.prototype.hasOwnProperty.call(t, e);
        }),
        (n.p = "/static/"),
        n((n.s = 168));
})([
    function (t, e, n) {
        "use strict";
        (function (t) {
            function r(t, e) {
                const n = Object.create(null),
                    r = t.split(",");
                for (let t = 0; t < r.length; t++) n[r[t]] = !0;
                return e ? (t) => !!n[t.toLowerCase()] : (t) => !!n[t];
            }
            n.d(e, "a", function () {
                return P;
            }),
                n.d(e, "b", function () {
                    return w;
                }),
                n.d(e, "c", function () {
                    return E;
                }),
                n.d(e, "d", function () {
                    return A;
                }),
                n.d(e, "e", function () {
                    return s;
                }),
                n.d(e, "f", function () {
                    return x;
                }),
                n.d(e, "g", function () {
                    return G;
                }),
                n.d(e, "h", function () {
                    return X;
                }),
                n.d(e, "i", function () {
                    return Z;
                }),
                n.d(e, "j", function () {
                    return O;
                }),
                n.d(e, "k", function () {
                    return nt;
                }),
                n.d(e, "l", function () {
                    return Y;
                }),
                n.d(e, "m", function () {
                    return N;
                }),
                n.d(e, "n", function () {
                    return J;
                }),
                n.d(e, "o", function () {
                    return Q;
                }),
                n.d(e, "p", function () {
                    return I;
                }),
                n.d(e, "q", function () {
                    return L;
                }),
                n.d(e, "r", function () {
                    return i;
                }),
                n.d(e, "s", function () {
                    return d;
                }),
                n.d(e, "t", function () {
                    return $;
                }),
                n.d(e, "u", function () {
                    return C;
                }),
                n.d(e, "v", function () {
                    return D;
                }),
                n.d(e, "w", function () {
                    return S;
                }),
                n.d(e, "x", function () {
                    return F;
                }),
                n.d(e, "y", function () {
                    return z;
                }),
                n.d(e, "z", function () {
                    return f;
                }),
                n.d(e, "A", function () {
                    return a;
                }),
                n.d(e, "B", function () {
                    return M;
                }),
                n.d(e, "C", function () {
                    return R;
                }),
                n.d(e, "D", function () {
                    return m;
                }),
                n.d(e, "E", function () {
                    return y;
                }),
                n.d(e, "F", function () {
                    return g;
                }),
                n.d(e, "G", function () {
                    return r;
                }),
                n.d(e, "H", function () {
                    return p;
                }),
                n.d(e, "I", function () {
                    return c;
                }),
                n.d(e, "J", function () {
                    return h;
                }),
                n.d(e, "K", function () {
                    return k;
                }),
                n.d(e, "L", function () {
                    return v;
                }),
                n.d(e, "M", function () {
                    return tt;
                }),
                n.d(e, "N", function () {
                    return V;
                });
            const s = {
                    1: "TEXT",
                    2: "CLASS",
                    4: "STYLE",
                    8: "PROPS",
                    16: "FULL_PROPS",
                    32: "HYDRATE_EVENTS",
                    64: "STABLE_FRAGMENT",
                    128: "KEYED_FRAGMENT",
                    256: "UNKEYED_FRAGMENT",
                    1024: "DYNAMIC_SLOTS",
                    512: "NEED_PATCH",
                    [-1]: "HOISTED",
                    [-2]: "BAIL",
                },
                i = r(
                    "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl"
                );
            const o =
                    "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
                a = r(o);
            function c(t) {
                if (I(t)) {
                    const e = {};
                    for (let n = 0; n < t.length; n++) {
                        const r = t[n],
                            s = c(M(r) ? h(r) : r);
                        if (s) for (const t in s) e[t] = s[t];
                    }
                    return e;
                }
                if (D(t)) return t;
            }
            const l = /;(?![^(]*\))/g,
                u = /:(.+)/;
            function h(t) {
                const e = {};
                return (
                    t.split(l).forEach((t) => {
                        if (t) {
                            const n = t.split(u);
                            n.length > 1 && (e[n[0].trim()] = n[1].trim());
                        }
                    }),
                    e
                );
            }
            function p(t) {
                let e = "";
                if (M(t)) e = t;
                else if (I(t))
                    for (let n = 0; n < t.length; n++) e += p(t[n]) + " ";
                else if (D(t)) for (const n in t) t[n] && (e += n + " ");
                return e.trim();
            }
            const d = r(
                    "html,body,base,head,link,meta,style,title,address,Podcast,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot"
                ),
                f = r(
                    "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view"
                ),
                m = r(
                    "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr"
                );
            function y(t, e) {
                if (t === e) return !0;
                let n = j(t),
                    r = j(e);
                if (n || r) return !(!n || !r) && t.getTime() === e.getTime();
                if (((n = I(t)), (r = I(e)), n || r))
                    return (
                        !(!n || !r) &&
                        (function (t, e) {
                            if (t.length !== e.length) return !1;
                            let n = !0;
                            for (let r = 0; n && r < t.length; r++)
                                n = y(t[r], e[r]);
                            return n;
                        })(t, e)
                    );
                if (((n = D(t)), (r = D(e)), n || r)) {
                    if (!n || !r) return !1;
                    if (Object.keys(t).length !== Object.keys(e).length)
                        return !1;
                    for (const n in t) {
                        const r = t.hasOwnProperty(n),
                            s = e.hasOwnProperty(n);
                        if ((r && !s) || (!r && s) || !y(t[n], e[n])) return !1;
                    }
                }
                return String(t) === String(e);
            }
            function g(t, e) {
                return t.findIndex((t) => y(t, e));
            }
            const v = (t) =>
                    null == t ? "" : D(t) ? JSON.stringify(t, b, 2) : String(t),
                b = (t, e) =>
                    e instanceof Map
                        ? {
                              [`Map(${e.size})`]: [...e.entries()].reduce(
                                  (t, [e, n]) => ((t[e + " =>"] = n), t),
                                  {}
                              ),
                          }
                        : e instanceof Set
                        ? { [`Set(${e.size})`]: [...e.values()] }
                        : !D(e) || I(e) || q(e)
                        ? e
                        : String(e),
                x = ["bigInt", "optionalChaining", "nullishCoalescingOperator"],
                w = {},
                P = [],
                A = () => {},
                E = () => !1,
                T = /^on[^a-z]/,
                S = (t) => T.test(t),
                C = (t) => t.startsWith("onUpdate:"),
                O = Object.assign,
                k = (t, e) => {
                    const n = t.indexOf(e);
                    n > -1 && t.splice(n, 1);
                },
                _ = Object.prototype.hasOwnProperty,
                N = (t, e) => _.call(t, e),
                I = Array.isArray,
                j = (t) => t instanceof Date,
                L = (t) => "function" == typeof t,
                M = (t) => "string" == typeof t,
                R = (t) => "symbol" == typeof t,
                D = (t) => null !== t && "object" == typeof t,
                F = (t) => D(t) && L(t.then) && L(t.catch),
                B = Object.prototype.toString,
                U = (t) => B.call(t),
                V = (t) => U(t).slice(8, -1),
                q = (t) => "[object Object]" === U(t),
                $ = (t) => M(t) && "-" !== t[0] && "" + parseInt(t, 10) === t,
                z = r(
                    "key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
                ),
                H = (t) => {
                    const e = Object.create(null);
                    return (n) => e[n] || (e[n] = t(n));
                },
                W = /-(\w)/g,
                G = H((t) =>
                    t.replace(W, (t, e) => (e ? e.toUpperCase() : ""))
                ),
                K = /\B([A-Z])/g,
                J = H((t) => t.replace(K, "-$1").toLowerCase()),
                X = H((t) => t.charAt(0).toUpperCase() + t.slice(1)),
                Y = (t, e) => t !== e && (t == t || e == e),
                Q = (t, e) => {
                    for (let n = 0; n < t.length; n++) t[n](e);
                },
                Z = (t, e, n) => {
                    Object.defineProperty(t, e, {
                        configurable: !0,
                        enumerable: !1,
                        value: n,
                    });
                },
                tt = (t) => {
                    const e = parseFloat(t);
                    return isNaN(e) ? t : e;
                };
            let et;
            const nt = () =>
                et ||
                (et =
                    "undefined" != typeof globalThis
                        ? globalThis
                        : "undefined" != typeof self
                        ? self
                        : "undefined" != typeof window
                        ? window
                        : void 0 !== t
                        ? t
                        : {});
        }.call(this, n(126)));
    },
    function (t, e, n) {
        "use strict";
        n.d(e, "m", function () {
            return it;
        }),
            n.d(e, "n", function () {
                return gt;
            }),
            n.d(e, "p", function () {
                return vt;
            }),
            n.d(e, "q", function () {
                return Pt;
            }),
            n.d(e, "a", function () {
                return Qr;
            }),
            n.d(e, "c", function () {
                return nn;
            }),
            n.d(e, "d", function () {
                return Ze;
            }),
            n.d(e, "e", function () {
                return Zr;
            }),
            n.d(e, "f", function () {
                return qr;
            }),
            n.d(e, "g", function () {
                return ns;
            }),
            n.d(e, "h", function () {
                return Cr;
            }),
            n.d(e, "i", function () {
                return Xt;
            }),
            n.d(e, "j", function () {
                return Nn;
            }),
            n.d(e, "k", function () {
                return On;
            }),
            n.d(e, "l", function () {
                return Sr;
            }),
            n.d(e, "o", function () {
                return ke;
            }),
            n.d(e, "r", function () {
                return It;
            }),
            n.d(e, "s", function () {
                return Pr;
            }),
            n.d(e, "b", function () {
                return Ai;
            });
        var r = {};
        n.r(r),
            n.d(r, "customRef", function () {
                return St;
            }),
            n.d(r, "isProxy", function () {
                return pt;
            }),
            n.d(r, "isReactive", function () {
                return ut;
            }),
            n.d(r, "isReadonly", function () {
                return ht;
            }),
            n.d(r, "isRef", function () {
                return yt;
            }),
            n.d(r, "markRaw", function () {
                return ft;
            }),
            n.d(r, "proxyRefs", function () {
                return Et;
            }),
            n.d(r, "reactive", function () {
                return it;
            }),
            n.d(r, "readonly", function () {
                return at;
            }),
            n.d(r, "ref", function () {
                return gt;
            }),
            n.d(r, "shallowReactive", function () {
                return ot;
            }),
            n.d(r, "shallowReadonly", function () {
                return ct;
            }),
            n.d(r, "shallowRef", function () {
                return vt;
            }),
            n.d(r, "toRaw", function () {
                return dt;
            }),
            n.d(r, "toRef", function () {
                return kt;
            }),
            n.d(r, "toRefs", function () {
                return Ct;
            }),
            n.d(r, "triggerRef", function () {
                return wt;
            }),
            n.d(r, "unref", function () {
                return Pt;
            }),
            n.d(r, "camelize", function () {
                return s.g;
            }),
            n.d(r, "capitalize", function () {
                return s.h;
            }),
            n.d(r, "toDisplayString", function () {
                return s.L;
            }),
            n.d(r, "BaseTransition", function () {
                return Fn;
            }),
            n.d(r, "Comment", function () {
                return De;
            }),
            n.d(r, "Fragment", function () {
                return Me;
            }),
            n.d(r, "KeepAlive", function () {
                return Wn;
            }),
            n.d(r, "Static", function () {
                return Fe;
            }),
            n.d(r, "Suspense", function () {
                return pe;
            }),
            n.d(r, "Teleport", function () {
                return Ce;
            }),
            n.d(r, "Text", function () {
                return Re;
            }),
            n.d(r, "callWithAsyncErrorHandling", function () {
                return Mt;
            }),
            n.d(r, "callWithErrorHandling", function () {
                return Lt;
            }),
            n.d(r, "cloneVNode", function () {
                return en;
            }),
            n.d(r, "computed", function () {
                return Qr;
            }),
            n.d(r, "createBlock", function () {
                return We;
            }),
            n.d(r, "createCommentVNode", function () {
                return sn;
            }),
            n.d(r, "createHydrationRenderer", function () {
                return gr;
            }),
            n.d(r, "createRenderer", function () {
                return yr;
            }),
            n.d(r, "createSlots", function () {
                return as;
            }),
            n.d(r, "createStaticVNode", function () {
                return rn;
            }),
            n.d(r, "createTextVNode", function () {
                return nn;
            }),
            n.d(r, "createVNode", function () {
                return Ze;
            }),
            n.d(r, "defineAsyncComponent", function () {
                return ts;
            }),
            n.d(r, "defineComponent", function () {
                return Zr;
            }),
            n.d(r, "devtools", function () {
                return un;
            }),
            n.d(r, "getCurrentInstance", function () {
                return qr;
            }),
            n.d(r, "getTransitionRawChildren", function () {
                return zn;
            }),
            n.d(r, "h", function () {
                return ns;
            }),
            n.d(r, "handleError", function () {
                return Rt;
            }),
            n.d(r, "inject", function () {
                return Cr;
            }),
            n.d(r, "isVNode", function () {
                return Ge;
            }),
            n.d(r, "mergeProps", function () {
                return ln;
            }),
            n.d(r, "nextTick", function () {
                return Xt;
            }),
            n.d(r, "onActivated", function () {
                return Jn;
            }),
            n.d(r, "onBeforeMount", function () {
                return Cn;
            }),
            n.d(r, "onBeforeUnmount", function () {
                return Nn;
            }),
            n.d(r, "onBeforeUpdate", function () {
                return kn;
            }),
            n.d(r, "onDeactivated", function () {
                return Xn;
            }),
            n.d(r, "onErrorCaptured", function () {
                return Mn;
            }),
            n.d(r, "onMounted", function () {
                return On;
            }),
            n.d(r, "onRenderTracked", function () {
                return Ln;
            }),
            n.d(r, "onRenderTriggered", function () {
                return jn;
            }),
            n.d(r, "onUnmounted", function () {
                return In;
            }),
            n.d(r, "onUpdated", function () {
                return _n;
            }),
            n.d(r, "openBlock", function () {
                return Ve;
            }),
            n.d(r, "popScopeId", function () {
                return Pe;
            }),
            n.d(r, "provide", function () {
                return Sr;
            }),
            n.d(r, "pushScopeId", function () {
                return we;
            }),
            n.d(r, "queuePostFlushCb", function () {
                return te;
            }),
            n.d(r, "registerRuntimeCompiler", function () {
                return Gr;
            }),
            n.d(r, "renderList", function () {
                return is;
            }),
            n.d(r, "renderSlot", function () {
                return ge;
            }),
            n.d(r, "resolveComponent", function () {
                return ke;
            }),
            n.d(r, "resolveDirective", function () {
                return Ie;
            }),
            n.d(r, "resolveDynamicComponent", function () {
                return Ne;
            }),
            n.d(r, "resolveTransitionHooks", function () {
                return Un;
            }),
            n.d(r, "setBlockTracking", function () {
                return He;
            }),
            n.d(r, "setDevtoolsHook", function () {
                return hn;
            }),
            n.d(r, "setTransitionHooks", function () {
                return $n;
            }),
            n.d(r, "ssrContextKey", function () {
                return rs;
            }),
            n.d(r, "ssrUtils", function () {
                return ls;
            }),
            n.d(r, "toHandlers", function () {
                return os;
            }),
            n.d(r, "transformVNodeArgs", function () {
                return Je;
            }),
            n.d(r, "useSSRContext", function () {
                return ss;
            }),
            n.d(r, "useTransitionState", function () {
                return Rn;
            }),
            n.d(r, "version", function () {
                return cs;
            }),
            n.d(r, "warn", function () {
                return It;
            }),
            n.d(r, "watch", function () {
                return Pr;
            }),
            n.d(r, "watchEffect", function () {
                return xr;
            }),
            n.d(r, "withCtx", function () {
                return ve;
            }),
            n.d(r, "withDirectives", function () {
                return ir;
            }),
            n.d(r, "withScopeId", function () {
                return Ae;
            }),
            n.d(r, "Transition", function () {
                return Is;
            }),
            n.d(r, "TransitionGroup", function () {
                return Ws;
            }),
            n.d(r, "createApp", function () {
                return Ai;
            }),
            n.d(r, "createSSRApp", function () {
                return Ei;
            }),
            n.d(r, "hydrate", function () {
                return Pi;
            }),
            n.d(r, "render", function () {
                return wi;
            }),
            n.d(r, "useCssModule", function () {
                return Os;
            }),
            n.d(r, "useCssVars", function () {
                return ks;
            }),
            n.d(r, "vModelCheckbox", function () {
                return ti;
            }),
            n.d(r, "vModelDynamic", function () {
                return ai;
            }),
            n.d(r, "vModelRadio", function () {
                return ni;
            }),
            n.d(r, "vModelSelect", function () {
                return ri;
            }),
            n.d(r, "vModelText", function () {
                return Zs;
            }),
            n.d(r, "vShow", function () {
                return fi;
            }),
            n.d(r, "withKeys", function () {
                return di;
            }),
            n.d(r, "withModifiers", function () {
                return hi;
            });
        var s = n(0);
        const i = new WeakMap(),
            o = [];
        let a;
        const c = Symbol(""),
            l = Symbol("");
        function u(t, e = s.b) {
            (function (t) {
                return t && !0 === t._isEffect;
            })(t) && (t = t.raw);
            const n = (function (t, e) {
                const n = function () {
                    if (!n.active) return e.scheduler ? void 0 : t();
                    if (!o.includes(n)) {
                        d(n);
                        try {
                            return m.push(f), (f = !0), o.push(n), (a = n), t();
                        } finally {
                            o.pop(), g(), (a = o[o.length - 1]);
                        }
                    }
                };
                return (
                    (n.id = p++),
                    (n._isEffect = !0),
                    (n.active = !0),
                    (n.raw = t),
                    (n.deps = []),
                    (n.options = e),
                    n
                );
            })(t, e);
            return e.lazy || n(), n;
        }
        function h(t) {
            t.active &&
                (d(t), t.options.onStop && t.options.onStop(), (t.active = !1));
        }
        let p = 0;
        function d(t) {
            const { deps: e } = t;
            if (e.length) {
                for (let n = 0; n < e.length; n++) e[n].delete(t);
                e.length = 0;
            }
        }
        let f = !0;
        const m = [];
        function y() {
            m.push(f), (f = !1);
        }
        function g() {
            const t = m.pop();
            f = void 0 === t || t;
        }
        function v(t, e, n) {
            if (!f || void 0 === a) return;
            let r = i.get(t);
            r || i.set(t, (r = new Map()));
            let s = r.get(n);
            s || r.set(n, (s = new Set())),
                s.has(a) || (s.add(a), a.deps.push(s));
        }
        function b(t, e, n, r, o, u) {
            const h = i.get(t);
            if (!h) return;
            const p = new Set(),
                d = (t) => {
                    t &&
                        t.forEach((t) => {
                            t !== a && p.add(t);
                        });
                };
            if ("clear" === e) h.forEach(d);
            else if ("length" === n && Object(s.p)(t))
                h.forEach((t, e) => {
                    ("length" === e || e >= r) && d(t);
                });
            else {
                void 0 !== n && d(h.get(n));
                const r =
                    ("add" === e && (!Object(s.p)(t) || Object(s.t)(n))) ||
                    ("delete" === e && !Object(s.p)(t));
                (r || ("set" === e && t instanceof Map)) &&
                    d(h.get(Object(s.p)(t) ? "length" : c)),
                    r && t instanceof Map && d(h.get(l));
            }
            p.forEach((t) => {
                t.options.scheduler ? t.options.scheduler(t) : t();
            });
        }
        const x = new Set(
                Object.getOwnPropertyNames(Symbol)
                    .map((t) => Symbol[t])
                    .filter(s.C)
            ),
            w = S(),
            P = S(!1, !0),
            A = S(!0),
            E = S(!0, !0),
            T = {};
        function S(t = !1, e = !1) {
            return function (n, r, i) {
                if ("__v_isReactive" === r) return !t;
                if ("__v_isReadonly" === r) return t;
                if ("__v_raw" === r && i === (t ? st : rt).get(n)) return n;
                const o = Object(s.p)(n);
                if (o && Object(s.m)(T, r)) return Reflect.get(T, r, i);
                const a = Reflect.get(n, r, i);
                if (
                    Object(s.C)(r)
                        ? x.has(r)
                        : "__proto__" === r || "__v_isRef" === r
                )
                    return a;
                if ((t || v(n, 0, r), e)) return a;
                if (yt(a)) {
                    return !o || !Object(s.t)(r) ? a.value : a;
                }
                return Object(s.v)(a) ? (t ? at(a) : it(a)) : a;
            };
        }
        ["includes", "indexOf", "lastIndexOf"].forEach((t) => {
            T[t] = function (...e) {
                const n = dt(this);
                for (let t = 0, e = this.length; t < e; t++) v(n, 0, t + "");
                const r = n[t](...e);
                return -1 === r || !1 === r ? n[t](...e.map(dt)) : r;
            };
        });
        const C = k(),
            O = k(!0);
        function k(t = !1) {
            return function (e, n, r, i) {
                const o = e[n];
                if (!t && ((r = dt(r)), !Object(s.p)(e) && yt(o) && !yt(r)))
                    return (o.value = r), !0;
                const a =
                        Object(s.p)(e) && Object(s.t)(n)
                            ? Number(n) < e.length
                            : Object(s.m)(e, n),
                    c = Reflect.set(e, n, r, i);
                return (
                    e === dt(i) &&
                        (a
                            ? Object(s.l)(r, o) && b(e, "set", n, r)
                            : b(e, "add", n, r)),
                    c
                );
            };
        }
        function _(t, e) {
            const n = Reflect.has(t, e);
            return (Object(s.C)(e) && x.has(e)) || v(t, 0, e), n;
        }
        function N(t) {
            return v(t, 0, c), Reflect.ownKeys(t);
        }
        const I = {
                get: w,
                set: C,
                deleteProperty: function (t, e) {
                    const n = Object(s.m)(t, e),
                        r = (t[e], Reflect.deleteProperty(t, e));
                    return r && n && b(t, "delete", e, void 0), r;
                },
                has: _,
                ownKeys: N,
            },
            j = {
                get: A,
                has: _,
                ownKeys: N,
                set: (t, e) => !0,
                deleteProperty: (t, e) => !0,
            },
            L = Object(s.j)({}, I, { get: P, set: O }),
            M = Object(s.j)({}, j, { get: E }),
            R = (t) => (Object(s.v)(t) ? it(t) : t),
            D = (t) => (Object(s.v)(t) ? at(t) : t),
            F = (t) => t,
            B = (t) => Reflect.getPrototypeOf(t);
        function U(t, e, n = !1, r = !1) {
            const s = dt((t = t.__v_raw)),
                i = dt(e);
            e !== i && !n && v(s, 0, e), !n && v(s, 0, i);
            const { has: o } = B(s),
                a = n ? D : r ? F : R;
            return o.call(s, e)
                ? a(t.get(e))
                : o.call(s, i)
                ? a(t.get(i))
                : void 0;
        }
        function V(t, e = !1) {
            const n = this.__v_raw,
                r = dt(n),
                s = dt(t);
            return (
                t !== s && !e && v(r, 0, t),
                !e && v(r, 0, s),
                t === s ? n.has(t) : n.has(t) || n.has(s)
            );
        }
        function q(t, e = !1) {
            return (
                (t = t.__v_raw), !e && v(dt(t), 0, c), Reflect.get(t, "size", t)
            );
        }
        function $(t) {
            t = dt(t);
            const e = dt(this),
                n = B(e),
                r = n.has.call(e, t),
                s = n.add.call(e, t);
            return r || b(e, "add", t, t), s;
        }
        function z(t, e) {
            e = dt(e);
            const n = dt(this),
                { has: r, get: i, set: o } = B(n);
            let a = r.call(n, t);
            a || ((t = dt(t)), (a = r.call(n, t)));
            const c = i.call(n, t),
                l = o.call(n, t, e);
            return (
                a ? Object(s.l)(e, c) && b(n, "set", t, e) : b(n, "add", t, e),
                l
            );
        }
        function H(t) {
            const e = dt(this),
                { has: n, get: r, delete: s } = B(e);
            let i = n.call(e, t);
            i || ((t = dt(t)), (i = n.call(e, t)));
            r && r.call(e, t);
            const o = s.call(e, t);
            return i && b(e, "delete", t, void 0), o;
        }
        function W() {
            const t = dt(this),
                e = 0 !== t.size,
                n = B(t).clear.call(t);
            return e && b(t, "clear", void 0, void 0), n;
        }
        function G(t, e) {
            return function (n, r) {
                const s = this,
                    i = s.__v_raw,
                    o = dt(i),
                    a = t ? D : e ? F : R;
                return (
                    !t && v(o, 0, c),
                    i.forEach((t, e) => n.call(r, a(t), a(e), s))
                );
            };
        }
        function K(t, e, n) {
            return function (...r) {
                const s = this.__v_raw,
                    i = dt(s),
                    o = i instanceof Map,
                    a = "entries" === t || (t === Symbol.iterator && o),
                    u = "keys" === t && o,
                    h = s[t](...r),
                    p = e ? D : n ? F : R;
                return (
                    !e && v(i, 0, u ? l : c),
                    {
                        next() {
                            const { value: t, done: e } = h.next();
                            return e
                                ? { value: t, done: e }
                                : {
                                      value: a ? [p(t[0]), p(t[1])] : p(t),
                                      done: e,
                                  };
                        },
                        [Symbol.iterator]() {
                            return this;
                        },
                    }
                );
            };
        }
        function J(t) {
            return function (...e) {
                return "delete" !== t && this;
            };
        }
        const X = {
                get(t) {
                    return U(this, t);
                },
                get size() {
                    return q(this);
                },
                has: V,
                add: $,
                set: z,
                delete: H,
                clear: W,
                forEach: G(!1, !1),
            },
            Y = {
                get(t) {
                    return U(this, t, !1, !0);
                },
                get size() {
                    return q(this);
                },
                has: V,
                add: $,
                set: z,
                delete: H,
                clear: W,
                forEach: G(!1, !0),
            },
            Q = {
                get(t) {
                    return U(this, t, !0);
                },
                get size() {
                    return q(this, !0);
                },
                has(t) {
                    return V.call(this, t, !0);
                },
                add: J("add"),
                set: J("set"),
                delete: J("delete"),
                clear: J("clear"),
                forEach: G(!0, !1),
            };
        function Z(t, e) {
            const n = e ? Y : t ? Q : X;
            return (e, r, i) =>
                "__v_isReactive" === r
                    ? !t
                    : "__v_isReadonly" === r
                    ? t
                    : "__v_raw" === r
                    ? e
                    : Reflect.get(Object(s.m)(n, r) && r in e ? n : e, r, i);
        }
        ["keys", "values", "entries", Symbol.iterator].forEach((t) => {
            (X[t] = K(t, !1, !1)), (Q[t] = K(t, !0, !1)), (Y[t] = K(t, !1, !0));
        });
        const tt = { get: Z(!1, !1) },
            et = { get: Z(!1, !0) },
            nt = { get: Z(!0, !1) };
        const rt = new WeakMap(),
            st = new WeakMap();
        function it(t) {
            return t && t.__v_isReadonly ? t : lt(t, !1, I, tt);
        }
        function ot(t) {
            return lt(t, !1, L, et);
        }
        function at(t) {
            return lt(t, !0, j, nt);
        }
        function ct(t) {
            return lt(t, !0, M, nt);
        }
        function lt(t, e, n, r) {
            if (!Object(s.v)(t)) return t;
            if (t.__v_raw && (!e || !t.__v_isReactive)) return t;
            const i = e ? st : rt,
                o = i.get(t);
            if (o) return o;
            const a =
                (c = t).__v_skip || !Object.isExtensible(c)
                    ? 0
                    : (function (t) {
                          switch (t) {
                              case "Object":
                              case "Array":
                                  return 1;
                              case "Map":
                              case "Set":
                              case "WeakMap":
                              case "WeakSet":
                                  return 2;
                              default:
                                  return 0;
                          }
                      })(Object(s.N)(c));
            var c;
            if (0 === a) return t;
            const l = new Proxy(t, 2 === a ? r : n);
            return i.set(t, l), l;
        }
        function ut(t) {
            return ht(t) ? ut(t.__v_raw) : !(!t || !t.__v_isReactive);
        }
        function ht(t) {
            return !(!t || !t.__v_isReadonly);
        }
        function pt(t) {
            return ut(t) || ht(t);
        }
        function dt(t) {
            return (t && dt(t.__v_raw)) || t;
        }
        function ft(t) {
            return Object(s.i)(t, "__v_skip", !0), t;
        }
        const mt = (t) => (Object(s.v)(t) ? it(t) : t);
        function yt(t) {
            return Boolean(t && !0 === t.__v_isRef);
        }
        function gt(t) {
            return xt(t);
        }
        function vt(t) {
            return xt(t, !0);
        }
        class bt {
            constructor(t, e = !1) {
                (this._rawValue = t),
                    (this._shallow = e),
                    (this.__v_isRef = !0),
                    (this._value = e ? t : mt(t));
            }
            get value() {
                return v(dt(this), 0, "value"), this._value;
            }
            set value(t) {
                Object(s.l)(dt(t), this._rawValue) &&
                    ((this._rawValue = t),
                    (this._value = this._shallow ? t : mt(t)),
                    b(dt(this), "set", "value", t));
            }
        }
        function xt(t, e = !1) {
            return yt(t) ? t : new bt(t, e);
        }
        function wt(t) {
            b(t, "set", "value", void 0);
        }
        function Pt(t) {
            return yt(t) ? t.value : t;
        }
        const At = {
            get: (t, e, n) => Pt(Reflect.get(t, e, n)),
            set: (t, e, n, r) => {
                const s = t[e];
                return yt(s) && !yt(n)
                    ? ((s.value = n), !0)
                    : Reflect.set(t, e, n, r);
            },
        };
        function Et(t) {
            return ut(t) ? t : new Proxy(t, At);
        }
        class Tt {
            constructor(t) {
                this.__v_isRef = !0;
                const { get: e, set: n } = t(
                    () => v(this, 0, "value"),
                    () => b(this, "set", "value")
                );
                (this._get = e), (this._set = n);
            }
            get value() {
                return this._get();
            }
            set value(t) {
                this._set(t);
            }
        }
        function St(t) {
            return new Tt(t);
        }
        function Ct(t) {
            const e = Object(s.p)(t) ? new Array(t.length) : {};
            for (const n in t) e[n] = kt(t, n);
            return e;
        }
        class Ot {
            constructor(t, e) {
                (this._object = t), (this._key = e), (this.__v_isRef = !0);
            }
            get value() {
                return this._object[this._key];
            }
            set value(t) {
                this._object[this._key] = t;
            }
        }
        function kt(t, e) {
            return new Ot(t, e);
        }
        class _t {
            constructor(t, e, n) {
                (this._setter = e),
                    (this._dirty = !0),
                    (this.__v_isRef = !0),
                    (this.effect = u(t, {
                        lazy: !0,
                        scheduler: () => {
                            this._dirty ||
                                ((this._dirty = !0),
                                b(dt(this), "set", "value"));
                        },
                    })),
                    (this.__v_isReadonly = n);
            }
            get value() {
                return (
                    this._dirty &&
                        ((this._value = this.effect()), (this._dirty = !1)),
                    v(dt(this), 0, "value"),
                    this._value
                );
            }
            set value(t) {
                this._setter(t);
            }
        }
        const Nt = [];
        function It(t, ...e) {
            y();
            const n = Nt.length ? Nt[Nt.length - 1].component : null,
                r = n && n.appContext.config.warnHandler,
                s = (function () {
                    let t = Nt[Nt.length - 1];
                    if (!t) return [];
                    const e = [];
                    for (; t; ) {
                        const n = e[0];
                        n && n.vnode === t
                            ? n.recurseCount++
                            : e.push({ vnode: t, recurseCount: 0 });
                        const r = t.component && t.component.parent;
                        t = r && r.vnode;
                    }
                    return e;
                })();
            if (r)
                Lt(r, n, 11, [
                    t + e.join(""),
                    n && n.proxy,
                    s.map(({ vnode: t }) => `at <${Yr(n, t.type)}>`).join("\n"),
                    s,
                ]);
            else {
                const n = ["[Vue warn]: " + t, ...e];
                s.length &&
                    n.push(
                        "\n",
                        ...(function (t) {
                            const e = [];
                            return (
                                t.forEach((t, n) => {
                                    e.push(
                                        ...(0 === n ? [] : ["\n"]),
                                        ...(function ({
                                            vnode: t,
                                            recurseCount: e,
                                        }) {
                                            const n =
                                                    e > 0
                                                        ? `... (${e} recursive calls)`
                                                        : "",
                                                r =
                                                    !!t.component &&
                                                    null == t.component.parent,
                                                s =
                                                    " at <" +
                                                    Yr(t.component, t.type, r),
                                                i = ">" + n;
                                            return t.props
                                                ? [s, ...jt(t.props), i]
                                                : [s + i];
                                        })(t)
                                    );
                                }),
                                e
                            );
                        })(s)
                    ),
                    console.warn(...n);
            }
            g();
        }
        function jt(t) {
            const e = [],
                n = Object.keys(t);
            return (
                n.slice(0, 3).forEach((n) => {
                    e.push(
                        ...(function t(e, n, r) {
                            return Object(s.B)(n)
                                ? ((n = JSON.stringify(n)),
                                  r ? n : [`${e}=${n}`])
                                : "number" == typeof n ||
                                  "boolean" == typeof n ||
                                  null == n
                                ? r
                                    ? n
                                    : [`${e}=${n}`]
                                : yt(n)
                                ? ((n = t(e, dt(n.value), !0)),
                                  r ? n : [e + "=Ref<", n, ">"])
                                : Object(s.q)(n)
                                ? [`${e}=fn${n.name ? `<${n.name}>` : ""}`]
                                : ((n = dt(n)), r ? n : [e + "=", n]);
                        })(n, t[n])
                    );
                }),
                n.length > 3 && e.push(" ..."),
                e
            );
        }
        function Lt(t, e, n, r) {
            let s;
            try {
                s = r ? t(...r) : t();
            } catch (t) {
                Rt(t, e, n);
            }
            return s;
        }
        function Mt(t, e, n, r) {
            if (Object(s.q)(t)) {
                const i = Lt(t, e, n, r);
                return (
                    i &&
                        Object(s.x)(i) &&
                        i.catch((t) => {
                            Rt(t, e, n);
                        }),
                    i
                );
            }
            const i = [];
            for (let s = 0; s < t.length; s++) i.push(Mt(t[s], e, n, r));
            return i;
        }
        function Rt(t, e, n) {
            e && e.vnode;
            if (e) {
                let r = e.parent;
                const s = e.proxy,
                    i = n;
                for (; r; ) {
                    const e = r.ec;
                    if (e)
                        for (let n = 0; n < e.length; n++)
                            if (e[n](t, s, i)) return;
                    r = r.parent;
                }
                const o = e.appContext.config.errorHandler;
                if (o) return void Lt(o, null, 10, [t, s, i]);
            }
            !(function (t, e, n) {
                console.error(t);
            })(t);
        }
        let Dt = !1,
            Ft = !1;
        const Bt = [];
        let Ut = 0;
        const Vt = [];
        let qt = null,
            $t = 0;
        const zt = [];
        let Ht = null,
            Wt = 0;
        const Gt = Promise.resolve();
        let Kt = null,
            Jt = null;
        function Xt(t) {
            const e = Kt || Gt;
            return t ? e.then(t) : e;
        }
        function Yt(t) {
            (Bt.length && Bt.includes(t, Dt && t.allowRecurse ? Ut + 1 : Ut)) ||
                t === Jt ||
                (Bt.push(t), Qt());
        }
        function Qt() {
            Dt || Ft || ((Ft = !0), (Kt = Gt.then(se)));
        }
        function Zt(t, e, n, r) {
            Object(s.p)(t)
                ? n.push(...t)
                : (e && e.includes(t, t.allowRecurse ? r + 1 : r)) || n.push(t),
                Qt();
        }
        function te(t) {
            Zt(t, Ht, zt, Wt);
        }
        function ee(t, e = null) {
            if (Vt.length) {
                for (
                    Jt = e, qt = [...new Set(Vt)], Vt.length = 0, $t = 0;
                    $t < qt.length;
                    $t++
                )
                    qt[$t]();
                (qt = null), ($t = 0), (Jt = null), ee(t, e);
            }
        }
        function ne(t) {
            if (zt.length) {
                const t = [...new Set(zt)];
                if (((zt.length = 0), Ht)) return void Ht.push(...t);
                for (
                    Ht = t, Ht.sort((t, e) => re(t) - re(e)), Wt = 0;
                    Wt < Ht.length;
                    Wt++
                )
                    Ht[Wt]();
                (Ht = null), (Wt = 0);
            }
        }
        const re = (t) => (null == t.id ? 1 / 0 : t.id);
        function se(t) {
            (Ft = !1), (Dt = !0), ee(t), Bt.sort((t, e) => re(t) - re(e));
            try {
                for (Ut = 0; Ut < Bt.length; Ut++) {
                    const t = Bt[Ut];
                    t && Lt(t, null, 14);
                }
            } finally {
                (Ut = 0),
                    (Bt.length = 0),
                    ne(),
                    (Dt = !1),
                    (Kt = null),
                    (Bt.length || zt.length) && se(t);
            }
        }
        new Set();
        new Map();
        let ie = null;
        function oe(t) {
            ie = t;
        }
        function ae(t) {
            const {
                type: e,
                parent: n,
                vnode: r,
                proxy: i,
                withProxy: o,
                props: a,
                slots: c,
                attrs: l,
                emit: u,
                render: h,
                renderCache: p,
                data: d,
                setupState: f,
                ctx: m,
            } = t;
            let y;
            ie = t;
            try {
                let t;
                if (4 & r.shapeFlag) {
                    const e = o || i;
                    (y = on(h.call(e, e, p, a, f, d, m))), (t = l);
                } else {
                    const n = e;
                    0,
                        (y = on(
                            n.length > 1
                                ? n(a, { attrs: l, slots: c, emit: u })
                                : n(a, null)
                        )),
                        (t = e.props ? l : ce(l));
                }
                let g = y;
                if (!1 !== e.inheritAttrs && t) {
                    const e = Object.keys(t),
                        { shapeFlag: n } = g;
                    e.length &&
                        (1 & n || 6 & n) &&
                        (1 & n && e.some(s.u) && (t = le(t)), (g = en(g, t)));
                }
                const v = r.scopeId,
                    b = v && g.scopeId !== v,
                    x = n && n.type.__scopeId,
                    w = x && x !== v ? x + "-s" : null;
                if (b || w) {
                    const t = {};
                    b && (t[v] = ""), w && (t[w] = ""), (g = en(g, t));
                }
                r.dirs && (g.dirs = r.dirs),
                    r.transition && (g.transition = r.transition),
                    (y = g);
            } catch (e) {
                Rt(e, t, 1), (y = Ze(De));
            }
            return (ie = null), y;
        }
        const ce = (t) => {
                let e;
                for (const n in t)
                    ("class" === n || "style" === n || Object(s.w)(n)) &&
                        ((e || (e = {}))[n] = t[n]);
                return e;
            },
            le = (t) => {
                const e = {};
                for (const n in t) Object(s.u)(n) || (e[n] = t[n]);
                return e;
            };
        function ue(t, e) {
            const n = Object.keys(e);
            if (n.length !== Object.keys(t).length) return !0;
            for (let r = 0; r < n.length; r++) {
                const s = n[r];
                if (e[s] !== t[s]) return !0;
            }
            return !1;
        }
        function he({ vnode: t, parent: e }, n) {
            for (; e && e.subTree === t; )
                ((t = e.vnode).el = n), (e = e.parent);
        }
        const pe = {
            __isSuspense: !0,
            process(t, e, n, r, s, i, o, a, c) {
                null == t
                    ? (function (t, e, n, r, s, i, o, a) {
                          const {
                                  p: c,
                                  o: { createElement: l },
                              } = a,
                              u = l("div"),
                              h = (t.suspense = de(t, s, r, e, u, n, i, o, a));
                          c(null, h.subTree, u, null, r, h, i, o),
                              h.deps > 0
                                  ? (c(
                                        null,
                                        h.fallbackTree,
                                        e,
                                        n,
                                        r,
                                        null,
                                        i,
                                        o
                                    ),
                                    (t.el = h.fallbackTree.el))
                                  : h.resolve();
                      })(e, n, r, s, i, o, a, c)
                    : (function (t, e, n, r, s, i, o, { p: a }) {
                          const c = (e.suspense = t.suspense);
                          c.vnode = e;
                          const { content: l, fallback: u } = fe(e),
                              h = c.subTree,
                              p = c.fallbackTree;
                          c.isResolved
                              ? (a(h, l, n, r, s, c, i, o), (e.el = l.el))
                              : (a(h, l, c.hiddenContainer, null, s, c, i, o),
                                c.deps > 0 &&
                                    (a(p, u, n, r, s, null, i, o),
                                    (e.el = u.el)));
                          (c.subTree = l), (c.fallbackTree = u);
                      })(t, e, n, r, s, o, a, c);
            },
            hydrate: function (t, e, n, r, s, i, o, a) {
                const c = (e.suspense = de(
                        e,
                        r,
                        n,
                        t.parentNode,
                        document.createElement("div"),
                        null,
                        s,
                        i,
                        o,
                        !0
                    )),
                    l = a(t, c.subTree, n, c, i);
                0 === c.deps && c.resolve();
                return l;
            },
        };
        function de(t, e, n, r, i, o, a, c, l, u = !1) {
            const {
                    p: h,
                    m: p,
                    um: d,
                    n: f,
                    o: { parentNode: m },
                } = l,
                y = () =>
                    b.isResolved || b.isHydrating ? b.subTree : b.fallbackTree,
                { content: g, fallback: v } = fe(t),
                b = {
                    vnode: t,
                    parent: e,
                    parentComponent: n,
                    isSVG: a,
                    optimized: c,
                    container: r,
                    hiddenContainer: i,
                    anchor: o,
                    deps: 0,
                    subTree: g,
                    fallbackTree: v,
                    isHydrating: u,
                    isResolved: !1,
                    isUnmounted: !1,
                    effects: [],
                    resolve() {
                        const {
                            vnode: t,
                            subTree: e,
                            fallbackTree: n,
                            effects: r,
                            parentComponent: i,
                            container: o,
                        } = b;
                        if (b.isHydrating) b.isHydrating = !1;
                        else {
                            let { anchor: t } = b;
                            n.el && ((t = f(n)), d(n, i, b, !0)), p(e, o, t, 0);
                        }
                        const a = (t.el = e.el);
                        i && i.subTree === t && ((i.vnode.el = a), he(i, a));
                        let c = b.parent,
                            l = !1;
                        for (; c; ) {
                            if (!c.isResolved) {
                                c.effects.push(...r), (l = !0);
                                break;
                            }
                            c = c.parent;
                        }
                        l || te(r), (b.isResolved = !0), (b.effects = []);
                        const u = t.props && t.props.onResolve;
                        Object(s.q)(u) && u();
                    },
                    recede() {
                        b.isResolved = !1;
                        const {
                                vnode: t,
                                subTree: e,
                                fallbackTree: n,
                                parentComponent: r,
                                container: i,
                                hiddenContainer: o,
                                isSVG: a,
                                optimized: c,
                            } = b,
                            l = f(e);
                        p(e, o, null, 1), h(null, n, i, l, r, null, a, c);
                        const u = (t.el = n.el);
                        r && r.subTree === t && ((r.vnode.el = u), he(r, u));
                        const d = t.props && t.props.onRecede;
                        Object(s.q)(d) && d();
                    },
                    move(t, e, n) {
                        p(y(), t, e, n), (b.container = t);
                    },
                    next: () => f(y()),
                    registerDep(t, e) {
                        b.isResolved &&
                            Yt(() => {
                                b.recede();
                            });
                        const n = t.vnode.el;
                        b.deps++,
                            t.asyncDep
                                .catch((e) => {
                                    Rt(e, t, 0);
                                })
                                .then((r) => {
                                    if (t.isUnmounted || b.isUnmounted) return;
                                    b.deps--, (t.asyncResolved = !0);
                                    const { vnode: s } = t;
                                    Wr(t, r),
                                        n && (s.el = n),
                                        e(
                                            t,
                                            s,
                                            m(n || t.subTree.el),
                                            n ? null : f(t.subTree),
                                            b,
                                            a,
                                            c
                                        ),
                                        he(t, s.el),
                                        0 === b.deps && b.resolve();
                                });
                    },
                    unmount(t, e) {
                        (b.isUnmounted = !0),
                            d(b.subTree, n, t, e),
                            b.isResolved || d(b.fallbackTree, n, t, e);
                    },
                };
            return b;
        }
        function fe(t) {
            const { shapeFlag: e, children: n } = t;
            if (32 & e) {
                const { default: t, fallback: e } = n;
                return {
                    content: on(Object(s.q)(t) ? t() : t),
                    fallback: on(Object(s.q)(e) ? e() : e),
                };
            }
            return { content: on(n), fallback: on(null) };
        }
        function me(t, e) {
            e && !e.isResolved
                ? Object(s.p)(t)
                    ? e.effects.push(...t)
                    : e.effects.push(t)
                : te(t);
        }
        let ye = 0;
        function ge(t, e, n = {}, r) {
            let s = t[e];
            ye++;
            const i =
                (Ve(),
                We(
                    Me,
                    { key: n.key },
                    s ? s(n) : r ? r() : [],
                    1 === t._ ? 64 : -2
                ));
            return ye--, i;
        }
        function ve(t, e = ie) {
            return e
                ? function () {
                      ye || Ve(!0);
                      const n = ie;
                      oe(e);
                      const r = t.apply(null, arguments);
                      return oe(n), ye || qe(), r;
                  }
                : t;
        }
        let be = null;
        const xe = [];
        function we(t) {
            xe.push((be = t));
        }
        function Pe() {
            xe.pop(), (be = xe[xe.length - 1] || null);
        }
        function Ae(t) {
            return (e) =>
                ve(function () {
                    we(t);
                    const n = e.apply(this, arguments);
                    return Pe(), n;
                });
        }
        const Ee = (t) => t && (t.disabled || "" === t.disabled),
            Te = (t, e) => {
                const n = t && t.to;
                if (Object(s.B)(n)) {
                    if (e) {
                        const t = e(n);
                        return t;
                    }
                    return null;
                }
                return n;
            };
        function Se(t, e, n, { o: { insert: r }, m: s }, i = 2) {
            0 === i && r(t.targetAnchor, e, n);
            const { el: o, anchor: a, shapeFlag: c, children: l, props: u } = t,
                h = 2 === i;
            if ((h && r(o, e, n), (!h || Ee(u)) && 16 & c))
                for (let t = 0; t < l.length; t++) s(l[t], e, n, 2);
            h && r(a, e, n);
        }
        const Ce = {
                __isTeleport: !0,
                process(t, e, n, r, s, i, o, a, c) {
                    const {
                            mc: l,
                            pc: u,
                            pbc: h,
                            o: {
                                insert: p,
                                querySelector: d,
                                createText: f,
                                createComment: m,
                            },
                        } = c,
                        y = Ee(e.props),
                        { shapeFlag: g, children: v } = e;
                    if (null == t) {
                        const t = (e.el = f("")),
                            c = (e.anchor = f(""));
                        p(t, n, r), p(c, n, r);
                        const u = (e.target = Te(e.props, d)),
                            h = (e.targetAnchor = f(""));
                        u && p(h, u);
                        const m = (t, e) => {
                            16 & g && l(v, t, e, s, i, o, a);
                        };
                        y ? m(n, c) : u && m(u, h);
                    } else {
                        e.el = t.el;
                        const r = (e.anchor = t.anchor),
                            l = (e.target = t.target),
                            p = (e.targetAnchor = t.targetAnchor),
                            f = Ee(t.props),
                            m = f ? n : l,
                            g = f ? r : p;
                        if (e.dynamicChildren) {
                            if (
                                (h(
                                    t.dynamicChildren,
                                    e.dynamicChildren,
                                    m,
                                    s,
                                    i,
                                    o
                                ),
                                16 & e.shapeFlag)
                            ) {
                                const n = t.children,
                                    r = e.children;
                                for (let t = 0; t < r.length; t++)
                                    r[t].el || (r[t].el = n[t].el);
                            }
                        } else a || u(t, e, m, g, s, i, o);
                        if (y) f || Se(e, n, r, c, 1);
                        else if (
                            (e.props && e.props.to) !== (t.props && t.props.to)
                        ) {
                            const t = (e.target = Te(e.props, d));
                            t && Se(e, t, null, c, 0);
                        } else f && Se(e, l, p, c, 1);
                    }
                },
                remove(t, { r: e, o: { remove: n } }) {
                    const { shapeFlag: r, children: s, anchor: i } = t;
                    if ((n(i), 16 & r))
                        for (let t = 0; t < s.length; t++) e(s[t]);
                },
                move: Se,
                hydrate: function (
                    t,
                    e,
                    n,
                    r,
                    s,
                    { o: { nextSibling: i, parentNode: o, querySelector: a } },
                    c
                ) {
                    const l = (e.target = Te(e.props, a));
                    if (l) {
                        const a = l._lpa || l.firstChild;
                        16 & e.shapeFlag &&
                            (Ee(e.props)
                                ? ((e.anchor = c(i(t), e, o(t), n, r, s)),
                                  (e.targetAnchor = a))
                                : ((e.anchor = i(t)),
                                  (e.targetAnchor = c(a, e, l, n, r, s))),
                            (l._lpa = e.targetAnchor && i(e.targetAnchor)));
                    }
                    return e.anchor && i(e.anchor);
                },
            },
            Oe = "components";
        function ke(t) {
            return je(Oe, t) || t;
        }
        const _e = Symbol();
        function Ne(t) {
            return Object(s.B)(t) ? je(Oe, t, !1) || t : t || _e;
        }
        function Ie(t) {
            return je("directives", t);
        }
        function je(t, e, n = !0) {
            const r = ie || Vr;
            if (r) {
                const n = r.type;
                if (t === Oe) {
                    const t = n.displayName || n.name;
                    if (
                        t &&
                        (t === e ||
                            t === Object(s.g)(e) ||
                            t === Object(s.h)(Object(s.g)(e)))
                    )
                        return n;
                }
                return Le(r[t] || n[t], e) || Le(r.appContext[t], e);
            }
        }
        function Le(t, e) {
            return (
                t &&
                (t[e] || t[Object(s.g)(e)] || t[Object(s.h)(Object(s.g)(e))])
            );
        }
        const Me = Symbol(void 0),
            Re = Symbol(void 0),
            De = Symbol(void 0),
            Fe = Symbol(void 0),
            Be = [];
        let Ue = null;
        function Ve(t = !1) {
            Be.push((Ue = t ? null : []));
        }
        function qe() {
            Be.pop(), (Ue = Be[Be.length - 1] || null);
        }
        let $e,
            ze = 1;
        function He(t) {
            ze += t;
        }
        function We(t, e, n, r, i) {
            const o = Ze(t, e, n, r, i, !0);
            return (o.dynamicChildren = Ue || s.a), qe(), Ue && Ue.push(o), o;
        }
        function Ge(t) {
            return !!t && !0 === t.__v_isVNode;
        }
        function Ke(t, e) {
            return t.type === e.type && t.key === e.key;
        }
        function Je(t) {
            $e = t;
        }
        const Xe = "__vInternal",
            Ye = ({ key: t }) => (null != t ? t : null),
            Qe = ({ ref: t }) =>
                null != t ? (Object(s.p)(t) ? t : [ie, t]) : null,
            Ze = tn;
        function tn(t, e = null, n = null, r = 0, i = null, o = !1) {
            if (((t && t !== _e) || (t = De), Ge(t))) {
                const r = en(t, e);
                return n && cn(r, n), r;
            }
            if ((Object(s.q)(t) && "__vccOpts" in t && (t = t.__vccOpts), e)) {
                (pt(e) || Xe in e) && (e = Object(s.j)({}, e));
                let { class: t, style: n } = e;
                t && !Object(s.B)(t) && (e.class = Object(s.H)(t)),
                    Object(s.v)(n) &&
                        (pt(n) && !Object(s.p)(n) && (n = Object(s.j)({}, n)),
                        (e.style = Object(s.I)(n)));
            }
            const a = Object(s.B)(t)
                ? 1
                : ((t) => t.__isSuspense)(t)
                ? 128
                : ((t) => t.__isTeleport)(t)
                ? 64
                : Object(s.v)(t)
                ? 4
                : Object(s.q)(t)
                ? 2
                : 0;
            const c = {
                __v_isVNode: !0,
                __v_skip: !0,
                type: t,
                props: e,
                key: e && Ye(e),
                ref: e && Qe(e),
                scopeId: be,
                children: null,
                component: null,
                suspense: null,
                dirs: null,
                transition: null,
                el: null,
                anchor: null,
                target: null,
                targetAnchor: null,
                staticCount: 0,
                shapeFlag: a,
                patchFlag: r,
                dynamicProps: i,
                dynamicChildren: null,
                appContext: null,
            };
            return (
                cn(c, n),
                ze > 0 &&
                    !o &&
                    Ue &&
                    (r > 0 || 6 & a) &&
                    32 !== r &&
                    Ue.push(c),
                c
            );
        }
        function en(t, e) {
            const { props: n, patchFlag: r } = t,
                s = e ? ln(n || {}, e) : n;
            return {
                __v_isVNode: !0,
                __v_skip: !0,
                type: t.type,
                props: s,
                key: s && Ye(s),
                ref: e && e.ref ? Qe(e) : t.ref,
                scopeId: t.scopeId,
                children: t.children,
                target: t.target,
                targetAnchor: t.targetAnchor,
                staticCount: t.staticCount,
                shapeFlag: t.shapeFlag,
                patchFlag: e && t.type !== Me ? (-1 === r ? 16 : 16 | r) : r,
                dynamicProps: t.dynamicProps,
                dynamicChildren: t.dynamicChildren,
                appContext: t.appContext,
                dirs: t.dirs,
                transition: t.transition,
                component: t.component,
                suspense: t.suspense,
                el: t.el,
                anchor: t.anchor,
            };
        }
        function nn(t = " ", e = 0) {
            return Ze(Re, null, t, e);
        }
        function rn(t, e) {
            const n = Ze(Fe, null, t);
            return (n.staticCount = e), n;
        }
        function sn(t = "", e = !1) {
            return e ? (Ve(), We(De, null, t)) : Ze(De, null, t);
        }
        function on(t) {
            return null == t || "boolean" == typeof t
                ? Ze(De)
                : Object(s.p)(t)
                ? Ze(Me, null, t)
                : "object" == typeof t
                ? null === t.el
                    ? t
                    : en(t)
                : Ze(Re, null, String(t));
        }
        function an(t) {
            return null === t.el ? t : en(t);
        }
        function cn(t, e) {
            let n = 0;
            const { shapeFlag: r } = t;
            if (null == e) e = null;
            else if (Object(s.p)(e)) n = 16;
            else if ("object" == typeof e) {
                if ((1 & r || 64 & r) && e.default)
                    return void cn(t, e.default());
                {
                    n = 32;
                    const r = e._;
                    r || Xe in e
                        ? 3 === r &&
                          ie &&
                          (1024 & ie.vnode.patchFlag
                              ? ((e._ = 2), (t.patchFlag |= 1024))
                              : (e._ = 1))
                        : (e._ctx = ie);
                }
            } else
                Object(s.q)(e)
                    ? ((e = { default: e, _ctx: ie }), (n = 32))
                    : ((e = String(e)),
                      64 & r ? ((n = 16), (e = [nn(e)])) : (n = 8));
            (t.children = e), (t.shapeFlag |= n);
        }
        function ln(...t) {
            const e = Object(s.j)({}, t[0]);
            for (let n = 1; n < t.length; n++) {
                const r = t[n];
                for (const t in r)
                    if ("class" === t)
                        e.class !== r.class &&
                            (e.class = Object(s.H)([e.class, r.class]));
                    else if ("style" === t)
                        e.style = Object(s.I)([e.style, r.style]);
                    else if (Object(s.w)(t)) {
                        const n = e[t],
                            s = r[t];
                        n !== s && (e[t] = n ? [].concat(n, r[t]) : s);
                    } else e[t] = r[t];
            }
            return e;
        }
        let un;
        function hn(t) {
            un = t;
        }
        const pn = mn("component:added"),
            dn = mn("component:updated"),
            fn = mn("component:removed");
        function mn(t) {
            return (e) => {
                un &&
                    un.emit(
                        t,
                        e.appContext.app,
                        e.uid,
                        e.parent ? e.parent.uid : void 0
                    );
            };
        }
        function yn(t, e, ...n) {
            const r = t.vnode.props || s.b;
            __VUE_PROD_DEVTOOLS__ &&
                (function (t, e, n) {
                    un && un.emit("component:emit", t.appContext.app, t, e, n);
                })(t, e, n);
            let i = "on" + Object(s.h)(e),
                o = r[i];
            if (
                (!o &&
                    e.startsWith("update:") &&
                    ((i = "on" + Object(s.h)(Object(s.n)(e))), (o = r[i])),
                !o)
            )
                if (((o = r[i + "Once"]), t.emitted)) {
                    if (t.emitted[i]) return;
                } else (t.emitted = {})[i] = !0;
            o && Mt(o, t, 6, n);
        }
        function gn(t, e) {
            let n;
            return (
                !(
                    !Object(s.w)(e) ||
                    !(n = (function t(e) {
                        if (Object(s.m)(e, "__emits")) return e.__emits;
                        const n = e.emits;
                        let r = {},
                            i = !1;
                        return (
                            __VUE_OPTIONS_API__ &&
                                !Object(s.q)(e) &&
                                (e.extends &&
                                    ((i = !0), Object(s.j)(r, t(e.extends))),
                                e.mixins &&
                                    ((i = !0),
                                    e.mixins.forEach((e) =>
                                        Object(s.j)(r, t(e))
                                    ))),
                            n || i
                                ? (Object(s.p)(n)
                                      ? n.forEach((t) => (r[t] = null))
                                      : Object(s.j)(r, n),
                                  (e.__emits = r))
                                : (e.__emits = void 0)
                        );
                    })(t))
                ) &&
                ((e = e.replace(/Once$/, "")),
                Object(s.m)(n, e[2].toLowerCase() + e.slice(3)) ||
                    Object(s.m)(n, e.slice(2)))
            );
        }
        function vn(t, e, n, r) {
            const [i, o] = xn(t.type);
            if (e)
                for (const o in e) {
                    const a = e[o];
                    if (Object(s.y)(o)) continue;
                    let c;
                    i && Object(s.m)(i, (c = Object(s.g)(o)))
                        ? (n[c] = a)
                        : gn(t.type, o) || (r[o] = a);
                }
            if (o) {
                const t = dt(n);
                for (let e = 0; e < o.length; e++) {
                    const r = o[e];
                    n[r] = bn(i, t, r, t[r]);
                }
            }
        }
        function bn(t, e, n, r) {
            const i = t[n];
            if (null != i) {
                const t = Object(s.m)(i, "default");
                if (t && void 0 === r) {
                    const t = i.default;
                    r = i.type !== Function && Object(s.q)(t) ? t(e) : t;
                }
                i[0] &&
                    (Object(s.m)(e, n) || t
                        ? !i[1] ||
                          ("" !== r && r !== Object(s.n)(n)) ||
                          (r = !0)
                        : (r = !1));
            }
            return r;
        }
        function xn(t) {
            if (t.__props) return t.__props;
            const e = t.props,
                n = {},
                r = [];
            let i = !1;
            if (__VUE_OPTIONS_API__ && !Object(s.q)(t)) {
                const e = (t) => {
                    const [e, i] = xn(t);
                    Object(s.j)(n, e), i && r.push(...i);
                };
                t.extends && ((i = !0), e(t.extends)),
                    t.mixins && ((i = !0), t.mixins.forEach(e));
            }
            if (!e && !i) return (t.__props = s.a);
            if (Object(s.p)(e))
                for (let t = 0; t < e.length; t++) {
                    0;
                    const r = Object(s.g)(e[t]);
                    En(r) && (n[r] = s.b);
                }
            else if (e) {
                0;
                for (const t in e) {
                    const i = Object(s.g)(t);
                    if (En(i)) {
                        const o = e[t],
                            a = (n[i] =
                                Object(s.p)(o) || Object(s.q)(o)
                                    ? { type: o }
                                    : o);
                        if (a) {
                            const t = An(Boolean, a.type),
                                e = An(String, a.type);
                            (a[0] = t > -1),
                                (a[1] = e < 0 || t < e),
                                (t > -1 || Object(s.m)(a, "default")) &&
                                    r.push(i);
                        }
                    }
                }
            }
            const o = [n, r];
            return (t.__props = o), o;
        }
        function wn(t) {
            const e = t && t.toString().match(/^\s*function (\w+)/);
            return e ? e[1] : "";
        }
        function Pn(t, e) {
            return wn(t) === wn(e);
        }
        function An(t, e) {
            if (Object(s.p)(e)) {
                for (let n = 0, r = e.length; n < r; n++)
                    if (Pn(e[n], t)) return n;
            } else if (Object(s.q)(e)) return Pn(e, t) ? 0 : -1;
            return -1;
        }
        function En(t) {
            return "$" !== t[0];
        }
        function Tn(t, e, n = Vr, r = !1) {
            if (n) {
                const s = n[t] || (n[t] = []),
                    i =
                        e.__weh ||
                        (e.__weh = (...r) => {
                            if (n.isUnmounted) return;
                            y(), $r(n);
                            const s = Mt(e, n, t, r);
                            return $r(null), g(), s;
                        });
                return r ? s.unshift(i) : s.push(i), i;
            }
        }
        const Sn =
                (t) =>
                (e, n = Vr) =>
                    !Hr && Tn(t, e, n),
            Cn = Sn("bm"),
            On = Sn("m"),
            kn = Sn("bu"),
            _n = Sn("u"),
            Nn = Sn("bum"),
            In = Sn("um"),
            jn = Sn("rtg"),
            Ln = Sn("rtc"),
            Mn = (t, e = Vr) => {
                Tn("ec", t, e);
            };
        function Rn() {
            const t = {
                isMounted: !1,
                isLeaving: !1,
                isUnmounting: !1,
                leavingVNodes: new Map(),
            };
            return (
                On(() => {
                    t.isMounted = !0;
                }),
                Nn(() => {
                    t.isUnmounting = !0;
                }),
                t
            );
        }
        const Dn = [Function, Array],
            Fn = {
                name: "BaseTransition",
                props: {
                    mode: String,
                    appear: Boolean,
                    persisted: Boolean,
                    onBeforeEnter: Dn,
                    onEnter: Dn,
                    onAfterEnter: Dn,
                    onEnterCancelled: Dn,
                    onBeforeLeave: Dn,
                    onLeave: Dn,
                    onAfterLeave: Dn,
                    onLeaveCancelled: Dn,
                    onBeforeAppear: Dn,
                    onAppear: Dn,
                    onAfterAppear: Dn,
                    onAppearCancelled: Dn,
                },
                setup(t, { slots: e }) {
                    const n = qr(),
                        r = Rn();
                    let s;
                    return () => {
                        const i = e.default && zn(e.default(), !0);
                        if (!i || !i.length) return;
                        const o = dt(t),
                            { mode: a } = o;
                        const c = i[0];
                        if (r.isLeaving) return Vn(c);
                        const l = qn(c);
                        if (!l) return Vn(c);
                        const u = (l.transition = Un(l, o, r, n)),
                            h = n.subTree,
                            p = h && qn(h);
                        let d = !1;
                        const { getTransitionKey: f } = l.type;
                        if (f) {
                            const t = f();
                            void 0 === s
                                ? (s = t)
                                : t !== s && ((s = t), (d = !0));
                        }
                        if (p && p.type !== De && (!Ke(l, p) || d)) {
                            const t = Un(p, o, r, n);
                            if (($n(p, t), "out-in" === a))
                                return (
                                    (r.isLeaving = !0),
                                    (t.afterLeave = () => {
                                        (r.isLeaving = !1), n.update();
                                    }),
                                    Vn(c)
                                );
                            "in-out" === a &&
                                (t.delayLeave = (t, e, n) => {
                                    (Bn(r, p)[String(p.key)] = p),
                                        (t._leaveCb = () => {
                                            e(),
                                                (t._leaveCb = void 0),
                                                delete u.delayedLeave;
                                        }),
                                        (u.delayedLeave = n);
                                });
                        }
                        return c;
                    };
                },
            };
        function Bn(t, e) {
            const { leavingVNodes: n } = t;
            let r = n.get(e.type);
            return r || ((r = Object.create(null)), n.set(e.type, r)), r;
        }
        function Un(
            t,
            {
                appear: e,
                persisted: n = !1,
                onBeforeEnter: r,
                onEnter: s,
                onAfterEnter: i,
                onEnterCancelled: o,
                onBeforeLeave: a,
                onLeave: c,
                onAfterLeave: l,
                onLeaveCancelled: u,
                onBeforeAppear: h,
                onAppear: p,
                onAfterAppear: d,
                onAppearCancelled: f,
            },
            m,
            y
        ) {
            const g = String(t.key),
                v = Bn(m, t),
                b = (t, e) => {
                    t && Mt(t, y, 9, e);
                },
                x = {
                    persisted: n,
                    beforeEnter(n) {
                        let s = r;
                        if (!m.isMounted) {
                            if (!e) return;
                            s = h || r;
                        }
                        n._leaveCb && n._leaveCb(!0);
                        const i = v[g];
                        i && Ke(t, i) && i.el._leaveCb && i.el._leaveCb(),
                            b(s, [n]);
                    },
                    enter(t) {
                        let n = s,
                            r = i,
                            a = o;
                        if (!m.isMounted) {
                            if (!e) return;
                            (n = p || s), (r = d || i), (a = f || o);
                        }
                        let c = !1;
                        const l = (t._enterCb = (e) => {
                            c ||
                                ((c = !0),
                                b(e ? a : r, [t]),
                                x.delayedLeave && x.delayedLeave(),
                                (t._enterCb = void 0));
                        });
                        n ? (n(t, l), n.length <= 1 && l()) : l();
                    },
                    leave(e, n) {
                        const r = String(t.key);
                        if ((e._enterCb && e._enterCb(!0), m.isUnmounting))
                            return n();
                        b(a, [e]);
                        let s = !1;
                        const i = (e._leaveCb = (i) => {
                            s ||
                                ((s = !0),
                                n(),
                                b(i ? u : l, [e]),
                                (e._leaveCb = void 0),
                                v[r] === t && delete v[r]);
                        });
                        (v[r] = t), c ? (c(e, i), c.length <= 1 && i()) : i();
                    },
                };
            return x;
        }
        function Vn(t) {
            if (Hn(t)) return ((t = en(t)).children = null), t;
        }
        function qn(t) {
            return Hn(t) ? (t.children ? t.children[0] : void 0) : t;
        }
        function $n(t, e) {
            6 & t.shapeFlag && t.component
                ? $n(t.component.subTree, e)
                : (t.transition = e);
        }
        function zn(t, e = !1) {
            let n = [],
                r = 0;
            for (let s = 0; s < t.length; s++) {
                const i = t[s];
                i.type === Me
                    ? (128 & i.patchFlag && r++,
                      (n = n.concat(zn(i.children, e))))
                    : (e || i.type !== De) && n.push(i);
            }
            if (r > 1) for (let t = 0; t < n.length; t++) n[t].patchFlag = -2;
            return n;
        }
        const Hn = (t) => t.type.__isKeepAlive,
            Wn = {
                name: "KeepAlive",
                __isKeepAlive: !0,
                inheritRef: !0,
                props: {
                    include: [String, RegExp, Array],
                    exclude: [String, RegExp, Array],
                    max: [String, Number],
                },
                setup(t, { slots: e }) {
                    const n = new Map(),
                        r = new Set();
                    let i = null;
                    const o = qr(),
                        a = o.suspense,
                        c = o.ctx,
                        {
                            renderer: {
                                p: l,
                                m: u,
                                um: h,
                                o: { createElement: p },
                            },
                        } = c,
                        d = p("div");
                    function f(t) {
                        Zn(t), h(t, o, a);
                    }
                    function m(t) {
                        n.forEach((e, n) => {
                            const r = Gn(e.type);
                            !r || (t && t(r)) || y(n);
                        });
                    }
                    function y(t) {
                        const e = n.get(t);
                        i && e.type === i.type ? i && Zn(i) : f(e),
                            n.delete(t),
                            r.delete(t);
                    }
                    (c.activate = (t, e, n, r, i) => {
                        const o = t.component;
                        u(t, e, n, 0, a),
                            l(o.vnode, t, e, n, o, a, r, i),
                            fr(() => {
                                (o.isDeactivated = !1), o.a && Object(s.o)(o.a);
                                const e = t.props && t.props.onVnodeMounted;
                                e && br(e, o.parent, t);
                            }, a);
                    }),
                        (c.deactivate = (t) => {
                            const e = t.component;
                            u(t, d, null, 1, a),
                                fr(() => {
                                    e.da && Object(s.o)(e.da);
                                    const n =
                                        t.props && t.props.onVnodeUnmounted;
                                    n && br(n, e.parent, t),
                                        (e.isDeactivated = !0);
                                }, a);
                        }),
                        Pr(
                            () => [t.include, t.exclude],
                            ([t, e]) => {
                                t && m((e) => Kn(t, e)),
                                    e && m((t) => Kn(e, t));
                            }
                        );
                    let g = null;
                    const v = () => {
                        null != g && n.set(g, o.subTree);
                    };
                    return (
                        Cn(v),
                        kn(v),
                        Nn(() => {
                            n.forEach((t) => {
                                const { subTree: e, suspense: n } = o;
                                if (t.type !== e.type) f(t);
                                else {
                                    Zn(e);
                                    const t = e.component.da;
                                    t && fr(t, n);
                                }
                            });
                        }),
                        () => {
                            if (((g = null), !e.default)) return null;
                            const s = e.default();
                            let o = s[0];
                            if (s.length > 1) return (i = null), s;
                            if (!(Ge(o) && 4 & o.shapeFlag))
                                return (i = null), o;
                            const a = o.type,
                                c = Gn(a),
                                { include: l, exclude: u, max: h } = t;
                            if (
                                (l && (!c || !Kn(l, c))) ||
                                (u && c && Kn(u, c))
                            )
                                return (i = o);
                            const p = null == o.key ? a : o.key,
                                d = n.get(p);
                            return (
                                o.el && (o = en(o)),
                                (g = p),
                                d
                                    ? ((o.el = d.el),
                                      (o.component = d.component),
                                      o.transition && $n(o, o.transition),
                                      (o.shapeFlag |= 512),
                                      r.delete(p),
                                      r.add(p))
                                    : (r.add(p),
                                      h &&
                                          r.size > parseInt(h, 10) &&
                                          y(r.values().next().value)),
                                (o.shapeFlag |= 256),
                                (i = o),
                                o
                            );
                        }
                    );
                },
            };
        function Gn(t) {
            return t.displayName || t.name;
        }
        function Kn(t, e) {
            return Object(s.p)(t)
                ? t.some((t) => Kn(t, e))
                : Object(s.B)(t)
                ? t.split(",").indexOf(e) > -1
                : !!t.test && t.test(e);
        }
        function Jn(t, e) {
            Yn(t, "a", e);
        }
        function Xn(t, e) {
            Yn(t, "da", e);
        }
        function Yn(t, e, n = Vr) {
            const r =
                t.__wdc ||
                (t.__wdc = () => {
                    let e = n;
                    for (; e; ) {
                        if (e.isDeactivated) return;
                        e = e.parent;
                    }
                    t();
                });
            if ((Tn(e, r, n), n)) {
                let t = n.parent;
                for (; t && t.parent; )
                    Hn(t.parent.vnode) && Qn(r, e, n, t), (t = t.parent);
            }
        }
        function Qn(t, e, n, r) {
            const i = Tn(e, t, r, !0);
            In(() => {
                Object(s.K)(r[e], i);
            }, n);
        }
        function Zn(t) {
            let e = t.shapeFlag;
            256 & e && (e -= 256), 512 & e && (e -= 512), (t.shapeFlag = e);
        }
        const tr = (t) => "_" === t[0] || "$stable" === t,
            er = (t) => (Object(s.p)(t) ? t.map(on) : [on(t)]),
            nr = (t, e, n) => ve((t) => er(e(t)), n),
            rr = (t, e) => {
                const n = t._ctx;
                for (const r in t) {
                    if (tr(r)) continue;
                    const i = t[r];
                    if (Object(s.q)(i)) e[r] = nr(0, i, n);
                    else if (null != i) {
                        0;
                        const t = er(i);
                        e[r] = () => t;
                    }
                }
            },
            sr = (t, e) => {
                const n = er(e);
                t.slots.default = () => n;
            };
        function ir(t, e) {
            if (null === ie) return t;
            const n = ie.proxy,
                r = t.dirs || (t.dirs = []);
            for (let t = 0; t < e.length; t++) {
                let [i, o, a, c = s.b] = e[t];
                Object(s.q)(i) && (i = { mounted: i, updated: i }),
                    r.push({
                        dir: i,
                        instance: n,
                        value: o,
                        oldValue: void 0,
                        arg: a,
                        modifiers: c,
                    });
            }
            return t;
        }
        function or(t, e, n, r) {
            const s = t.dirs,
                i = e && e.dirs;
            for (let o = 0; o < s.length; o++) {
                const a = s[o];
                i && (a.oldValue = i[o].value);
                const c = a.dir[r];
                c && Mt(c, n, 8, [t.el, a, t, e]);
            }
        }
        function ar() {
            return {
                app: null,
                config: {
                    isNativeTag: s.c,
                    performance: !1,
                    globalProperties: {},
                    optionMergeStrategies: {},
                    isCustomElement: s.c,
                    errorHandler: void 0,
                    warnHandler: void 0,
                },
                mixins: [],
                components: {},
                directives: {},
                provides: Object.create(null),
            };
        }
        function cr(t, e) {
            return function (n, r = null) {
                null == r || Object(s.v)(r) || (r = null);
                const i = ar(),
                    o = new Set();
                let a = !1;
                const c = (i.app = {
                    _component: n,
                    _props: r,
                    _container: null,
                    _context: i,
                    version: cs,
                    get config() {
                        return i.config;
                    },
                    set config(t) {
                        0;
                    },
                    use: (t, ...e) => (
                        o.has(t) ||
                            (t && Object(s.q)(t.install)
                                ? (o.add(t), t.install(c, ...e))
                                : Object(s.q)(t) && (o.add(t), t(c, ...e))),
                        c
                    ),
                    mixin: (t) => (
                        __VUE_OPTIONS_API__ &&
                            (i.mixins.includes(t) || i.mixins.push(t)),
                        c
                    ),
                    component: (t, e) =>
                        e ? ((i.components[t] = e), c) : i.components[t],
                    directive: (t, e) =>
                        e ? ((i.directives[t] = e), c) : i.directives[t],
                    mount(s, o) {
                        if (!a) {
                            const l = Ze(n, r);
                            return (
                                (l.appContext = i),
                                o && e ? e(l, s) : t(l, s),
                                (a = !0),
                                (c._container = s),
                                (s.__vue_app__ = c),
                                __VUE_PROD_DEVTOOLS__ &&
                                    (function (t, e) {
                                        un &&
                                            un.emit("app:init", t, e, {
                                                Fragment: Me,
                                                Text: Re,
                                                Comment: De,
                                                Static: Fe,
                                            });
                                    })(c, cs),
                                l.component.proxy
                            );
                        }
                    },
                    unmount() {
                        a &&
                            (t(null, c._container),
                            __VUE_PROD_DEVTOOLS__ &&
                                (function (t) {
                                    un && un.emit("app:unmount", t);
                                })(c));
                    },
                    provide: (t, e) => ((i.provides[t] = e), c),
                });
                return c;
            };
        }
        let lr = !1;
        const ur = (t) =>
                /svg/.test(t.namespaceURI) && "foreignObject" !== t.tagName,
            hr = (t) => 8 === t.nodeType;
        function pr(t) {
            const {
                    mt: e,
                    p: n,
                    o: {
                        patchProp: r,
                        nextSibling: i,
                        parentNode: o,
                        remove: a,
                        insert: c,
                        createComment: l,
                    },
                } = t,
                u = (n, r, s, a, c = !1) => {
                    const l = hr(n) && "[" === n.data,
                        y = () => f(n, r, s, a, l),
                        { type: g, ref: v, shapeFlag: b } = r,
                        x = n.nodeType;
                    r.el = n;
                    let w = null;
                    switch (g) {
                        case Re:
                            3 !== x
                                ? (w = y())
                                : (n.data !== r.children &&
                                      ((lr = !0), (n.data = r.children)),
                                  (w = i(n)));
                            break;
                        case De:
                            w = 8 !== x || l ? y() : i(n);
                            break;
                        case Fe:
                            if (1 === x) {
                                w = n;
                                const t = !r.children.length;
                                for (let e = 0; e < r.staticCount; e++)
                                    t && (r.children += w.outerHTML),
                                        e === r.staticCount - 1 &&
                                            (r.anchor = w),
                                        (w = i(w));
                                return w;
                            }
                            w = y();
                            break;
                        case Me:
                            w = l ? d(n, r, s, a, c) : y();
                            break;
                        default:
                            if (1 & b)
                                w =
                                    1 !== x ||
                                    r.type !== n.tagName.toLowerCase()
                                        ? y()
                                        : h(n, r, s, a, c);
                            else if (6 & b) {
                                const t = o(n),
                                    u = () => {
                                        e(r, t, null, s, a, ur(t), c);
                                    },
                                    h = r.type.__asyncLoader;
                                h ? h().then(u) : u(), (w = l ? m(n) : i(n));
                            } else
                                64 & b
                                    ? (w =
                                          8 !== x
                                              ? y()
                                              : r.type.hydrate(
                                                    n,
                                                    r,
                                                    s,
                                                    a,
                                                    c,
                                                    t,
                                                    p
                                                ))
                                    : 128 & b &&
                                      (w = r.type.hydrate(
                                          n,
                                          r,
                                          s,
                                          a,
                                          ur(o(n)),
                                          c,
                                          t,
                                          u
                                      ));
                    }
                    return null != v && s && mr(v, null, s, a, r), w;
                },
                h = (t, e, n, i, o) => {
                    o = o || !!e.dynamicChildren;
                    const { props: c, patchFlag: l, shapeFlag: u, dirs: h } = e;
                    if (-1 !== l) {
                        if ((h && or(e, null, n, "created"), c))
                            if (!o || 16 & l || 32 & l)
                                for (const e in c)
                                    !Object(s.y)(e) &&
                                        Object(s.w)(e) &&
                                        r(t, e, null, c[e]);
                            else c.onClick && r(t, "onClick", null, c.onClick);
                        let d;
                        if (
                            ((d = c && c.onVnodeBeforeMount) && br(d, n, e),
                            h && or(e, null, n, "beforeMount"),
                            ((d = c && c.onVnodeMounted) || h) &&
                                me(() => {
                                    d && br(d, n, e),
                                        h && or(e, null, n, "mounted");
                                }, i),
                            16 & u && (!c || (!c.innerHTML && !c.textContent)))
                        ) {
                            let r = p(t.firstChild, e, t, n, i, o);
                            for (; r; ) {
                                lr = !0;
                                const t = r;
                                (r = r.nextSibling), a(t);
                            }
                        } else
                            8 & u &&
                                t.textContent !== e.children &&
                                ((lr = !0), (t.textContent = e.children));
                    }
                    return t.nextSibling;
                },
                p = (t, e, r, s, i, o) => {
                    o = o || !!e.dynamicChildren;
                    const a = e.children,
                        c = a.length;
                    for (let e = 0; e < c; e++) {
                        const c = o ? a[e] : (a[e] = on(a[e]));
                        t
                            ? (t = u(t, c, s, i, o))
                            : ((lr = !0), n(null, c, r, null, s, i, ur(r)));
                    }
                    return t;
                },
                d = (t, e, n, r, s) => {
                    const a = o(t),
                        u = p(i(t), e, a, n, r, s);
                    return u && hr(u) && "]" === u.data
                        ? i((e.anchor = u))
                        : ((lr = !0), c((e.anchor = l("]")), a, u), u);
                },
                f = (t, e, r, s, c) => {
                    if (((lr = !0), (e.el = null), c)) {
                        const e = m(t);
                        for (;;) {
                            const n = i(t);
                            if (!n || n === e) break;
                            a(n);
                        }
                    }
                    const l = i(t),
                        u = o(t);
                    return a(t), n(null, e, u, l, r, s, ur(u)), l;
                },
                m = (t) => {
                    let e = 0;
                    for (; t; )
                        if (
                            (t = i(t)) &&
                            hr(t) &&
                            ("[" === t.data && e++, "]" === t.data)
                        ) {
                            if (0 === e) return i(t);
                            e--;
                        }
                    return t;
                };
            return [
                (t, e) => {
                    (lr = !1),
                        u(e.firstChild, t, null, null),
                        ne(),
                        lr &&
                            console.error(
                                "Hydration completed but contains mismatches."
                            );
                },
                u,
            ];
        }
        const dr = { scheduler: Yt };
        const fr = me,
            mr = (t, e, n, r, i) => {
                let o;
                o = i ? (4 & i.shapeFlag ? i.component.proxy : i.el) : null;
                const [a, c] = t;
                const l = e && e[1],
                    u = a.refs === s.b ? (a.refs = {}) : a.refs,
                    h = a.setupState;
                if (
                    (null != l &&
                        l !== c &&
                        (Object(s.B)(l)
                            ? ((u[l] = null),
                              Object(s.m)(h, l) && (h[l] = null))
                            : yt(l) && (l.value = null)),
                    Object(s.B)(c))
                ) {
                    const t = () => {
                        (u[c] = o), Object(s.m)(h, c) && (h[c] = o);
                    };
                    o ? ((t.id = -1), fr(t, r)) : t();
                } else if (yt(c)) {
                    const t = () => {
                        c.value = o;
                    };
                    o ? ((t.id = -1), fr(t, r)) : t();
                } else Object(s.q)(c) && Lt(c, n, 12, [o, u]);
            };
        function yr(t) {
            return vr(t);
        }
        function gr(t) {
            return vr(t, pr);
        }
        function vr(t, e) {
            !(function () {
                let t = !1;
                "boolean" != typeof __VUE_OPTIONS_API__ &&
                    ((t = !0), (Object(s.k)().__VUE_OPTIONS_API__ = !0)),
                    "boolean" != typeof __VUE_PROD_DEVTOOLS__ &&
                        ((t = !0), (Object(s.k)().__VUE_PROD_DEVTOOLS__ = !1));
            })();
            const {
                    insert: n,
                    remove: r,
                    patchProp: i,
                    forcePatchProp: o,
                    createElement: a,
                    createText: c,
                    createComment: l,
                    setText: p,
                    setElementText: d,
                    parentNode: f,
                    nextSibling: m,
                    setScopeId: v = s.d,
                    cloneNode: x,
                    insertStaticContent: w,
                } = t,
                P = (t, e, n, r = null, s = null, i = null, o = !1, a = !1) => {
                    t && !Ke(t, e) && ((r = G(t)), q(t, s, i, !0), (t = null)),
                        -2 === e.patchFlag &&
                            ((a = !1), (e.dynamicChildren = null));
                    const { type: c, ref: l, shapeFlag: u } = e;
                    switch (c) {
                        case Re:
                            A(t, e, n, r);
                            break;
                        case De:
                            E(t, e, n, r);
                            break;
                        case Fe:
                            null == t && T(e, n, r, o);
                            break;
                        case Me:
                            I(t, e, n, r, s, i, o, a);
                            break;
                        default:
                            1 & u
                                ? S(t, e, n, r, s, i, o, a)
                                : 6 & u
                                ? j(t, e, n, r, s, i, o, a)
                                : (64 & u || 128 & u) &&
                                  c.process(t, e, n, r, s, i, o, a, J);
                    }
                    null != l && s && mr(l, t && t.ref, s, i, e);
                },
                A = (t, e, r, s) => {
                    if (null == t) n((e.el = c(e.children)), r, s);
                    else {
                        const n = (e.el = t.el);
                        e.children !== t.children && p(n, e.children);
                    }
                },
                E = (t, e, r, s) => {
                    null == t
                        ? n((e.el = l(e.children || "")), r, s)
                        : (e.el = t.el);
                },
                T = (t, e, n, r) => {
                    [t.el, t.anchor] = w(t.children, e, n, r);
                },
                S = (t, e, n, r, s, i, o, a) => {
                    (o = o || "svg" === e.type),
                        null == t
                            ? C(e, n, r, s, i, o, a)
                            : k(t, e, s, i, o, a);
                },
                C = (t, e, r, o, c, l, u) => {
                    let h, p;
                    const {
                        type: f,
                        props: m,
                        shapeFlag: y,
                        transition: g,
                        scopeId: b,
                        patchFlag: w,
                        dirs: P,
                    } = t;
                    if (t.el && void 0 !== x && -1 === w) h = t.el = x(t.el);
                    else {
                        if (
                            ((h = t.el = a(t.type, l, m && m.is)),
                            8 & y
                                ? d(h, t.children)
                                : 16 & y &&
                                  O(
                                      t.children,
                                      h,
                                      null,
                                      o,
                                      c,
                                      l && "foreignObject" !== f,
                                      u || !!t.dynamicChildren
                                  ),
                            P && or(t, null, o, "created"),
                            m)
                        ) {
                            for (const e in m)
                                Object(s.y)(e) ||
                                    i(h, e, null, m[e], l, t.children, o, c, W);
                            (p = m.onVnodeBeforeMount) && br(p, o, t);
                        }
                        b && v(h, b);
                        const e = o && o.type.__scopeId;
                        e && e !== b && v(h, e + "-s");
                    }
                    P && or(t, null, o, "beforeMount");
                    const A = (!c || (c && c.isResolved)) && g && !g.persisted;
                    A && g.beforeEnter(h),
                        n(h, e, r),
                        ((p = m && m.onVnodeMounted) || A || P) &&
                            fr(() => {
                                p && br(p, o, t),
                                    A && g.enter(h),
                                    P && or(t, null, o, "mounted");
                            }, c);
                },
                O = (t, e, n, r, s, i, o, a = 0) => {
                    for (let c = a; c < t.length; c++) {
                        const a = (t[c] = o ? an(t[c]) : on(t[c]));
                        P(null, a, e, n, r, s, i, o);
                    }
                },
                k = (t, e, n, r, a, c) => {
                    const l = (e.el = t.el);
                    let { patchFlag: u, dynamicChildren: h, dirs: p } = e;
                    u |= 16 & t.patchFlag;
                    const f = t.props || s.b,
                        m = e.props || s.b;
                    let y;
                    if (
                        ((y = m.onVnodeBeforeUpdate) && br(y, n, e, t),
                        p && or(e, t, n, "beforeUpdate"),
                        u > 0)
                    ) {
                        if (16 & u) N(l, e, f, m, n, r, a);
                        else if (
                            (2 & u &&
                                f.class !== m.class &&
                                i(l, "class", null, m.class, a),
                            4 & u && i(l, "style", f.style, m.style, a),
                            8 & u)
                        ) {
                            const s = e.dynamicProps;
                            for (let e = 0; e < s.length; e++) {
                                const c = s[e],
                                    u = f[c],
                                    h = m[c];
                                (h !== u || (o && o(l, c))) &&
                                    i(l, c, u, h, a, t.children, n, r, W);
                            }
                        }
                        1 & u && t.children !== e.children && d(l, e.children);
                    } else c || null != h || N(l, e, f, m, n, r, a);
                    const g = a && "foreignObject" !== e.type;
                    h
                        ? _(t.dynamicChildren, h, l, n, r, g)
                        : c || F(t, e, l, null, n, r, g),
                        ((y = m.onVnodeUpdated) || p) &&
                            fr(() => {
                                y && br(y, n, e, t),
                                    p && or(e, t, n, "updated");
                            }, r);
                },
                _ = (t, e, n, r, s, i) => {
                    for (let o = 0; o < e.length; o++) {
                        const a = t[o],
                            c = e[o],
                            l =
                                a.type === Me ||
                                !Ke(a, c) ||
                                6 & a.shapeFlag ||
                                64 & a.shapeFlag
                                    ? f(a.el)
                                    : n;
                        P(a, c, l, null, r, s, i, !0);
                    }
                },
                N = (t, e, n, r, a, c, l) => {
                    if (n !== r) {
                        for (const u in r) {
                            if (Object(s.y)(u)) continue;
                            const h = r[u],
                                p = n[u];
                            (h !== p || (o && o(t, u))) &&
                                i(t, u, p, h, l, e.children, a, c, W);
                        }
                        if (n !== s.b)
                            for (const o in n)
                                Object(s.y)(o) ||
                                    o in r ||
                                    i(t, o, n[o], null, l, e.children, a, c, W);
                    }
                },
                I = (t, e, r, s, i, o, a, l) => {
                    const u = (e.el = t ? t.el : c("")),
                        h = (e.anchor = t ? t.anchor : c(""));
                    let { patchFlag: p, dynamicChildren: d } = e;
                    p > 0 && (l = !0),
                        null == t
                            ? (n(u, r, s),
                              n(h, r, s),
                              O(e.children, r, h, i, o, a, l))
                            : p > 0 && 64 & p && d
                            ? _(t.dynamicChildren, d, r, i, o, a)
                            : F(t, e, r, h, i, o, a, l);
                },
                j = (t, e, n, r, s, i, o, a) => {
                    null == t
                        ? 512 & e.shapeFlag
                            ? s.ctx.activate(e, n, r, o, a)
                            : L(e, n, r, s, i, o, a)
                        : M(t, e, a);
                },
                L = (t, e, n, r, i, o, a) => {
                    const c = (t.component = (function (t, e, n) {
                        const r = t.type,
                            i = (e ? e.appContext : t.appContext) || Br,
                            o = {
                                uid: Ur++,
                                vnode: t,
                                type: r,
                                parent: e,
                                appContext: i,
                                root: null,
                                next: null,
                                subTree: null,
                                update: null,
                                render: null,
                                proxy: null,
                                withProxy: null,
                                effects: null,
                                provides: e
                                    ? e.provides
                                    : Object.create(i.provides),
                                accessCache: null,
                                renderCache: [],
                                components: null,
                                directives: null,
                                ctx: s.b,
                                data: s.b,
                                props: s.b,
                                attrs: s.b,
                                slots: s.b,
                                refs: s.b,
                                setupState: s.b,
                                setupContext: null,
                                suspense: n,
                                asyncDep: null,
                                asyncResolved: !1,
                                isMounted: !1,
                                isUnmounted: !1,
                                isDeactivated: !1,
                                bc: null,
                                c: null,
                                bm: null,
                                m: null,
                                bu: null,
                                u: null,
                                um: null,
                                bum: null,
                                da: null,
                                a: null,
                                rtg: null,
                                rtc: null,
                                ec: null,
                                emit: null,
                                emitted: null,
                            };
                        o.ctx = { _: o };
                        (o.root = e ? e.root : o),
                            (o.emit = yn.bind(null, o)),
                            __VUE_PROD_DEVTOOLS__ && pn(o);
                        return o;
                    })(t, r, i));
                    if (
                        (Hn(t) && (c.ctx.renderer = J),
                        (function (t, e = !1) {
                            Hr = e;
                            const {
                                    props: n,
                                    children: r,
                                    shapeFlag: i,
                                } = t.vnode,
                                o = 4 & i;
                            (function (t, e, n, r = !1) {
                                const i = {},
                                    o = {};
                                Object(s.i)(o, Xe, 1),
                                    vn(t, e, i, o),
                                    n
                                        ? (t.props = r ? i : ot(i))
                                        : t.type.props
                                        ? (t.props = i)
                                        : (t.props = o),
                                    (t.attrs = o);
                            })(t, n, o, e),
                                ((t, e) => {
                                    if (32 & t.vnode.shapeFlag) {
                                        const n = e._;
                                        n
                                            ? ((t.slots = e),
                                              Object(s.i)(e, "_", n))
                                            : rr(e, (t.slots = {}));
                                    } else (t.slots = {}), e && sr(t, e);
                                    Object(s.i)(t.slots, Xe, 1);
                                })(t, r);
                            const a = o
                                ? (function (t, e) {
                                      const n = t.type;
                                      0;
                                      (t.accessCache = {}),
                                          (t.proxy = new Proxy(t.ctx, Dr)),
                                          !1;
                                      const { setup: r } = n;
                                      if (r) {
                                          const n = (t.setupContext =
                                              r.length > 1
                                                  ? (function (t) {
                                                        return {
                                                            attrs: t.attrs,
                                                            slots: t.slots,
                                                            emit: t.emit,
                                                        };
                                                    })(t)
                                                  : null);
                                          (Vr = t), y();
                                          const i = Lt(r, t, 0, [t.props, n]);
                                          if (
                                              (g(), (Vr = null), Object(s.x)(i))
                                          ) {
                                              if (e)
                                                  return i.then((e) => {
                                                      Wr(t, e);
                                                  });
                                              t.asyncDep = i;
                                          } else Wr(t, i);
                                      } else Kr(t);
                                  })(t, e)
                                : void 0;
                            Hr = !1;
                        })(c),
                        c.asyncDep)
                    ) {
                        if (!i) return void 0;
                        if ((i.registerDep(c, R), !t.el)) {
                            const t = (c.subTree = Ze(De));
                            E(null, t, e, n);
                        }
                    } else R(c, t, e, n, i, o, a);
                },
                M = (t, e, n) => {
                    const r = (e.component = t.component);
                    if (
                        (function (t, e, n) {
                            const { props: r, children: s } = t,
                                { props: i, children: o, patchFlag: a } = e;
                            if (e.dirs || e.transition) return !0;
                            if (!(n && a > 0))
                                return (
                                    !((!s && !o) || (o && o.$stable)) ||
                                    (r !== i && (r ? !i || ue(r, i) : !!i))
                                );
                            if (1024 & a) return !0;
                            if (16 & a) return r ? ue(r, i) : !!i;
                            if (8 & a) {
                                const t = e.dynamicProps;
                                for (let e = 0; e < t.length; e++) {
                                    const n = t[e];
                                    if (i[n] !== r[n]) return !0;
                                }
                            }
                            return !1;
                        })(t, e, n)
                    ) {
                        if (r.asyncDep && !r.asyncResolved)
                            return void D(r, e, n);
                        (r.next = e),
                            (function (t) {
                                const e = Bt.indexOf(t);
                                e > -1 && (Bt[e] = null);
                            })(r.update),
                            r.update();
                    } else
                        (e.component = t.component),
                            (e.el = t.el),
                            (r.vnode = e);
                },
                R = (t, e, n, r, i, o, a) => {
                    (t.update = u(function () {
                        if (t.isMounted) {
                            let e,
                                {
                                    next: n,
                                    bu: r,
                                    u: c,
                                    parent: l,
                                    vnode: u,
                                } = t,
                                h = n;
                            0,
                                n ? D(t, n, a) : (n = u),
                                (n.el = u.el),
                                r && Object(s.o)(r),
                                (e = n.props && n.props.onVnodeBeforeUpdate) &&
                                    br(e, l, n, u);
                            const p = ae(t);
                            0;
                            const d = t.subTree;
                            (t.subTree = p),
                                t.refs !== s.b && (t.refs = {}),
                                P(d, p, f(d.el), G(d), t, i, o),
                                (n.el = p.el),
                                null === h && he(t, p.el),
                                c && fr(c, i),
                                (e = n.props && n.props.onVnodeUpdated) &&
                                    fr(() => {
                                        br(e, l, n, u);
                                    }, i),
                                __VUE_PROD_DEVTOOLS__ && dn(t);
                        } else {
                            let a;
                            const { el: c, props: l } = e,
                                { bm: u, m: h, parent: p } = t;
                            u && Object(s.o)(u),
                                (a = l && l.onVnodeBeforeMount) && br(a, p, e);
                            const d = (t.subTree = ae(t));
                            0,
                                c && Y
                                    ? Y(e.el, d, t, i)
                                    : (P(null, d, n, r, t, i, o),
                                      (e.el = d.el)),
                                h && fr(h, i),
                                (a = l && l.onVnodeMounted) &&
                                    fr(() => {
                                        br(a, p, e);
                                    }, i);
                            const { a: f } = t;
                            f && 256 & e.shapeFlag && fr(f, i),
                                (t.isMounted = !0);
                        }
                    }, dr)),
                        (t.update.allowRecurse = !0);
                },
                D = (t, e, n) => {
                    e.component = t;
                    const r = t.vnode.props;
                    (t.vnode = e),
                        (t.next = null),
                        (function (t, e, n, r) {
                            const {
                                    props: i,
                                    attrs: o,
                                    vnode: { patchFlag: a },
                                } = t,
                                c = dt(i),
                                [l] = xn(t.type);
                            if (!(r || a > 0) || 16 & a) {
                                let r;
                                vn(t, e, i, o);
                                for (const t in c)
                                    (e &&
                                        (Object(s.m)(e, t) ||
                                            ((r = Object(s.n)(t)) !== t &&
                                                Object(s.m)(e, r)))) ||
                                        (l
                                            ? !n ||
                                              (void 0 === n[t] &&
                                                  void 0 === n[r]) ||
                                              (i[t] = bn(
                                                  l,
                                                  e || s.b,
                                                  t,
                                                  void 0
                                              ))
                                            : delete i[t]);
                                if (o !== c)
                                    for (const t in o)
                                        (e && Object(s.m)(e, t)) || delete o[t];
                            } else if (8 & a) {
                                const n = t.vnode.dynamicProps;
                                for (let t = 0; t < n.length; t++) {
                                    const r = n[t],
                                        a = e[r];
                                    if (l)
                                        if (Object(s.m)(o, r)) o[r] = a;
                                        else {
                                            const t = Object(s.g)(r);
                                            i[t] = bn(l, c, t, a);
                                        }
                                    else o[r] = a;
                                }
                            }
                            b(t, "set", "$attrs");
                        })(t, e.props, r, n),
                        ((t, e) => {
                            const { vnode: n, slots: r } = t;
                            let i = !0,
                                o = s.b;
                            if (32 & n.shapeFlag) {
                                const t = e._;
                                t
                                    ? 1 === t
                                        ? (i = !1)
                                        : Object(s.j)(r, e)
                                    : ((i = !e.$stable), rr(e, r)),
                                    (o = e);
                            } else e && (sr(t, e), (o = { default: 1 }));
                            if (i)
                                for (const t in r)
                                    tr(t) || t in o || delete r[t];
                        })(t, e.children),
                        ee(void 0, t.update);
                },
                F = (t, e, n, r, s, i, o, a = !1) => {
                    const c = t && t.children,
                        l = t ? t.shapeFlag : 0,
                        u = e.children,
                        { patchFlag: h, shapeFlag: p } = e;
                    if (h > 0) {
                        if (128 & h) return void U(c, u, n, r, s, i, o, a);
                        if (256 & h) return void B(c, u, n, r, s, i, o, a);
                    }
                    8 & p
                        ? (16 & l && W(c, s, i), u !== c && d(n, u))
                        : 16 & l
                        ? 16 & p
                            ? U(c, u, n, r, s, i, o, a)
                            : W(c, s, i, !0)
                        : (8 & l && d(n, ""), 16 & p && O(u, n, r, s, i, o, a));
                },
                B = (t, e, n, r, i, o, a, c) => {
                    (t = t || s.a), (e = e || s.a);
                    const l = t.length,
                        u = e.length,
                        h = Math.min(l, u);
                    let p;
                    for (p = 0; p < h; p++) {
                        const r = (e[p] = c ? an(e[p]) : on(e[p]));
                        P(t[p], r, n, null, i, o, a, c);
                    }
                    l > u ? W(t, i, o, !0, h) : O(e, n, r, i, o, a, c, h);
                },
                U = (t, e, n, r, i, o, a, c) => {
                    let l = 0;
                    const u = e.length;
                    let h = t.length - 1,
                        p = u - 1;
                    for (; l <= h && l <= p; ) {
                        const r = t[l],
                            s = (e[l] = c ? an(e[l]) : on(e[l]));
                        if (!Ke(r, s)) break;
                        P(r, s, n, null, i, o, a, c), l++;
                    }
                    for (; l <= h && l <= p; ) {
                        const r = t[h],
                            s = (e[p] = c ? an(e[p]) : on(e[p]));
                        if (!Ke(r, s)) break;
                        P(r, s, n, null, i, o, a, c), h--, p--;
                    }
                    if (l > h) {
                        if (l <= p) {
                            const t = p + 1,
                                s = t < u ? e[t].el : r;
                            for (; l <= p; )
                                P(
                                    null,
                                    (e[l] = c ? an(e[l]) : on(e[l])),
                                    n,
                                    s,
                                    i,
                                    o,
                                    a
                                ),
                                    l++;
                        }
                    } else if (l > p) for (; l <= h; ) q(t[l], i, o, !0), l++;
                    else {
                        const d = l,
                            f = l,
                            m = new Map();
                        for (l = f; l <= p; l++) {
                            const t = (e[l] = c ? an(e[l]) : on(e[l]));
                            null != t.key && m.set(t.key, l);
                        }
                        let y,
                            g = 0;
                        const v = p - f + 1;
                        let b = !1,
                            x = 0;
                        const w = new Array(v);
                        for (l = 0; l < v; l++) w[l] = 0;
                        for (l = d; l <= h; l++) {
                            const r = t[l];
                            if (g >= v) {
                                q(r, i, o, !0);
                                continue;
                            }
                            let s;
                            if (null != r.key) s = m.get(r.key);
                            else
                                for (y = f; y <= p; y++)
                                    if (0 === w[y - f] && Ke(r, e[y])) {
                                        s = y;
                                        break;
                                    }
                            void 0 === s
                                ? q(r, i, o, !0)
                                : ((w[s - f] = l + 1),
                                  s >= x ? (x = s) : (b = !0),
                                  P(r, e[s], n, null, i, o, a, c),
                                  g++);
                        }
                        const A = b
                            ? (function (t) {
                                  const e = t.slice(),
                                      n = [0];
                                  let r, s, i, o, a;
                                  const c = t.length;
                                  for (r = 0; r < c; r++) {
                                      const c = t[r];
                                      if (0 !== c) {
                                          if (
                                              ((s = n[n.length - 1]), t[s] < c)
                                          ) {
                                              (e[r] = s), n.push(r);
                                              continue;
                                          }
                                          for (i = 0, o = n.length - 1; i < o; )
                                              (a = ((i + o) / 2) | 0),
                                                  t[n[a]] < c
                                                      ? (i = a + 1)
                                                      : (o = a);
                                          c < t[n[i]] &&
                                              (i > 0 && (e[r] = n[i - 1]),
                                              (n[i] = r));
                                      }
                                  }
                                  (i = n.length), (o = n[i - 1]);
                                  for (; i-- > 0; ) (n[i] = o), (o = e[o]);
                                  return n;
                              })(w)
                            : s.a;
                        for (y = A.length - 1, l = v - 1; l >= 0; l--) {
                            const t = f + l,
                                s = e[t],
                                c = t + 1 < u ? e[t + 1].el : r;
                            0 === w[l]
                                ? P(null, s, n, c, i, o, a)
                                : b &&
                                  (y < 0 || l !== A[y] ? V(s, n, c, 2) : y--);
                        }
                    }
                },
                V = (t, e, r, s, i = null) => {
                    const {
                        el: o,
                        type: a,
                        transition: c,
                        children: l,
                        shapeFlag: u,
                    } = t;
                    if (6 & u) return void V(t.component.subTree, e, r, s);
                    if (128 & u) return void t.suspense.move(e, r, s);
                    if (64 & u) return void a.move(t, e, r, J);
                    if (a === Me) {
                        n(o, e, r);
                        for (let t = 0; t < l.length; t++) V(l[t], e, r, s);
                        return void n(t.anchor, e, r);
                    }
                    if (2 !== s && 1 & u && c)
                        if (0 === s)
                            c.beforeEnter(o),
                                n(o, e, r),
                                fr(() => c.enter(o), i);
                        else {
                            const {
                                    leave: t,
                                    delayLeave: s,
                                    afterLeave: i,
                                } = c,
                                a = () => n(o, e, r),
                                l = () => {
                                    t(o, () => {
                                        a(), i && i();
                                    });
                                };
                            s ? s(o, a, l) : l();
                        }
                    else n(o, e, r);
                },
                q = (t, e, n, r = !1) => {
                    const {
                        type: s,
                        props: i,
                        ref: o,
                        children: a,
                        dynamicChildren: c,
                        shapeFlag: l,
                        patchFlag: u,
                        dirs: h,
                    } = t;
                    if ((null != o && e && mr(o, null, e, n, null), 256 & l))
                        return void e.ctx.deactivate(t);
                    const p = 1 & l && h;
                    let d;
                    if (
                        ((d = i && i.onVnodeBeforeUnmount) && br(d, e, t),
                        6 & l)
                    )
                        H(t.component, n, r);
                    else {
                        if (128 & l) return void t.suspense.unmount(n, r);
                        p && or(t, null, e, "beforeUnmount"),
                            c && (s !== Me || (u > 0 && 64 & u))
                                ? W(c, e, n)
                                : 16 & l && W(a, e, n),
                            64 & l && t.type.remove(t, J),
                            r && $(t);
                    }
                    ((d = i && i.onVnodeUnmounted) || p) &&
                        fr(() => {
                            d && br(d, e, t), p && or(t, null, e, "unmounted");
                        }, n);
                },
                $ = (t) => {
                    const { type: e, el: n, anchor: s, transition: i } = t;
                    if (e === Me) return void z(n, s);
                    const o = () => {
                        r(n),
                            i && !i.persisted && i.afterLeave && i.afterLeave();
                    };
                    if (1 & t.shapeFlag && i && !i.persisted) {
                        const { leave: e, delayLeave: r } = i,
                            s = () => e(n, o);
                        r ? r(t.el, o, s) : s();
                    } else o();
                },
                z = (t, e) => {
                    let n;
                    for (; t !== e; ) (n = m(t)), r(t), (t = n);
                    r(e);
                },
                H = (t, e, n) => {
                    const {
                        bum: r,
                        effects: i,
                        update: o,
                        subTree: a,
                        um: c,
                        da: l,
                        isDeactivated: u,
                    } = t;
                    if ((r && Object(s.o)(r), i))
                        for (let t = 0; t < i.length; t++) h(i[t]);
                    o && (h(o), q(a, t, e, n)),
                        c && fr(c, e),
                        l && !u && 256 & t.vnode.shapeFlag && fr(l, e),
                        fr(() => {
                            t.isUnmounted = !0;
                        }, e),
                        !e ||
                            e.isResolved ||
                            e.isUnmounted ||
                            !t.asyncDep ||
                            t.asyncResolved ||
                            (e.deps--, 0 === e.deps && e.resolve()),
                        __VUE_PROD_DEVTOOLS__ && fn(t);
                },
                W = (t, e, n, r = !1, s = 0) => {
                    for (let i = s; i < t.length; i++) q(t[i], e, n, r);
                },
                G = (t) =>
                    6 & t.shapeFlag
                        ? G(t.component.subTree)
                        : 128 & t.shapeFlag
                        ? t.suspense.next()
                        : m(t.anchor || t.el),
                K = (t, e) => {
                    null == t
                        ? e._vnode && q(e._vnode, null, null, !0)
                        : P(e._vnode || null, t, e),
                        ne(),
                        (e._vnode = t);
                },
                J = {
                    p: P,
                    um: q,
                    m: V,
                    r: $,
                    mt: L,
                    mc: O,
                    pc: F,
                    pbc: _,
                    n: G,
                    o: t,
                };
            let X, Y;
            return (
                e && ([X, Y] = e(J)),
                { render: K, hydrate: X, createApp: cr(K, X) }
            );
        }
        function br(t, e, n, r = null) {
            Mt(t, e, 7, [n, r]);
        }
        function xr(t, e) {
            return Ar(t, null, e);
        }
        const wr = {};
        function Pr(t, e, n) {
            return Ar(t, e, n);
        }
        function Ar(
            t,
            e,
            { immediate: n, deep: r, flush: i, onTrack: o, onTrigger: a } = s.b,
            c = Vr
        ) {
            let l;
            const p = yt(t);
            if (
                (p
                    ? (l = () => t.value)
                    : ut(t)
                    ? ((l = () => t), (r = !0))
                    : (l = Object(s.p)(t)
                          ? () =>
                                t.map((t) =>
                                    yt(t)
                                        ? t.value
                                        : ut(t)
                                        ? Tr(t)
                                        : Object(s.q)(t)
                                        ? Lt(t, c, 2)
                                        : void 0
                                )
                          : Object(s.q)(t)
                          ? e
                              ? () => Lt(t, c, 2)
                              : () => {
                                    if (!c || !c.isUnmounted)
                                        return d && d(), Lt(t, c, 3, [f]);
                                }
                          : s.d),
                e && r)
            ) {
                const t = l;
                l = () => Tr(t());
            }
            let d;
            const f = (t) => {
                d = v.options.onStop = () => {
                    Lt(t, c, 4);
                };
            };
            let m = Object(s.p)(t) ? [] : wr;
            const y = () => {
                if (v.active)
                    if (e) {
                        const t = v();
                        (r || p || Object(s.l)(t, m)) &&
                            (d && d(),
                            Mt(e, c, 3, [t, m === wr ? void 0 : m, f]),
                            (m = t));
                    } else v();
            };
            let g;
            (y.allowRecurse = !!e),
                "sync" === i
                    ? (g = y)
                    : "pre" === i
                    ? ((y.id = -1),
                      (g = () => {
                          !c || c.isMounted
                              ? (function (t) {
                                    Zt(t, qt, Vt, $t);
                                })(y)
                              : y();
                      }))
                    : (g = () => fr(y, c && c.suspense));
            const v = u(l, {
                lazy: !0,
                onTrack: o,
                onTrigger: a,
                scheduler: g,
            });
            return (
                Jr(v),
                e ? (n ? y() : (m = v())) : v(),
                () => {
                    h(v), c && Object(s.K)(c.effects, v);
                }
            );
        }
        function Er(t, e, n) {
            const r = this.proxy;
            return Ar(
                Object(s.B)(t) ? () => r[t] : t.bind(r),
                e.bind(r),
                n,
                this
            );
        }
        function Tr(t, e = new Set()) {
            if (!Object(s.v)(t) || e.has(t)) return t;
            if ((e.add(t), yt(t))) Tr(t.value, e);
            else if (Object(s.p)(t))
                for (let n = 0; n < t.length; n++) Tr(t[n], e);
            else if (t instanceof Map)
                t.forEach((n, r) => {
                    Tr(t.get(r), e);
                });
            else if (t instanceof Set)
                t.forEach((t) => {
                    Tr(t, e);
                });
            else for (const n in t) Tr(t[n], e);
            return t;
        }
        function Sr(t, e) {
            if (Vr) {
                let n = Vr.provides;
                const r = Vr.parent && Vr.parent.provides;
                r === n && (n = Vr.provides = Object.create(r)), (n[t] = e);
            } else 0;
        }
        function Cr(t, e) {
            const n = Vr || ie;
            if (n) {
                const r = n.provides;
                if (t in r) return r[t];
                if (arguments.length > 1) return e;
            } else 0;
        }
        let Or = !1;
        function kr(t, e, n = [], r = [], i = !1) {
            const {
                    mixins: o,
                    extends: a,
                    data: c,
                    computed: l,
                    methods: u,
                    watch: h,
                    provide: p,
                    inject: d,
                    components: f,
                    directives: m,
                    beforeMount: y,
                    mounted: g,
                    beforeUpdate: v,
                    updated: b,
                    activated: x,
                    deactivated: w,
                    beforeUnmount: P,
                    unmounted: A,
                    render: E,
                    renderTracked: T,
                    renderTriggered: S,
                    errorCaptured: C,
                } = e,
                O = t.proxy,
                k = t.ctx,
                _ = t.appContext.mixins;
            i && E && t.render === s.d && (t.render = E),
                i ||
                    ((Or = !0),
                    _r("beforeCreate", e, O, _),
                    (Or = !1),
                    Ir(t, _, n, r)),
                a && kr(t, a, n, r, !0),
                o && Ir(t, o, n, r);
            if (d)
                if (Object(s.p)(d))
                    for (let t = 0; t < d.length; t++) {
                        const e = d[t];
                        k[e] = Cr(e);
                    }
                else
                    for (const t in d) {
                        const e = d[t];
                        Object(s.v)(e)
                            ? (k[t] = Cr(e.from, e.default))
                            : (k[t] = Cr(e));
                    }
            if (u)
                for (const t in u) {
                    const e = u[t];
                    Object(s.q)(e) && (k[t] = e.bind(O));
                }
            if (
                (i
                    ? c && n.push(c)
                    : (n.length && n.forEach((e) => jr(t, e, O)),
                      c && jr(t, c, O)),
                l)
            )
                for (const t in l) {
                    const e = l[t];
                    0;
                    const n = Qr({
                        get: Object(s.q)(e)
                            ? e.bind(O, O)
                            : Object(s.q)(e.get)
                            ? e.get.bind(O, O)
                            : s.d,
                        set:
                            !Object(s.q)(e) && Object(s.q)(e.set)
                                ? e.set.bind(O)
                                : s.d,
                    });
                    Object.defineProperty(k, t, {
                        enumerable: !0,
                        configurable: !0,
                        get: () => n.value,
                        set: (t) => (n.value = t),
                    });
                }
            if (
                (h && r.push(h),
                !i &&
                    r.length &&
                    r.forEach((t) => {
                        for (const e in t) Lr(t[e], k, O, e);
                    }),
                p)
            ) {
                const t = Object(s.q)(p) ? p.call(O) : p;
                for (const e in t) Sr(e, t[e]);
            }
            i &&
                (f &&
                    Object(s.j)(
                        t.components ||
                            (t.components = Object(s.j)({}, t.type.components)),
                        f
                    ),
                m &&
                    Object(s.j)(
                        t.directives ||
                            (t.directives = Object(s.j)({}, t.type.directives)),
                        m
                    )),
                i || _r("created", e, O, _),
                y && Cn(y.bind(O)),
                g && On(g.bind(O)),
                v && kn(v.bind(O)),
                b && _n(b.bind(O)),
                x && Jn(x.bind(O)),
                w && Xn(w.bind(O)),
                C && Mn(C.bind(O)),
                T && Ln(T.bind(O)),
                S && jn(S.bind(O)),
                P && Nn(P.bind(O)),
                A && In(A.bind(O));
        }
        function _r(t, e, n, r) {
            Nr(t, r, n);
            const { extends: s, mixins: i } = e;
            s &&
                (function t(e, n, r) {
                    n.extends && t(e, n.extends, r);
                    const s = n[e];
                    s && s.call(r);
                })(t, s, n),
                i && Nr(t, i, n);
            const o = e[t];
            o && o.call(n);
        }
        function Nr(t, e, n) {
            for (let r = 0; r < e.length; r++) {
                const s = e[r].mixins;
                s && Nr(t, s, n);
                const i = e[r][t];
                i && i.call(n);
            }
        }
        function Ir(t, e, n, r) {
            for (let s = 0; s < e.length; s++) kr(t, e[s], n, r, !0);
        }
        function jr(t, e, n) {
            const r = e.call(n, n);
            Object(s.v)(r) &&
                (t.data === s.b ? (t.data = it(r)) : Object(s.j)(t.data, r));
        }
        function Lr(t, e, n, r) {
            const i = () => n[r];
            if (Object(s.B)(t)) {
                const n = e[t];
                Object(s.q)(n) && Pr(i, n);
            } else if (Object(s.q)(t)) Pr(i, t.bind(n));
            else if (Object(s.v)(t))
                if (Object(s.p)(t)) t.forEach((t) => Lr(t, e, n, r));
                else {
                    const r = Object(s.q)(t.handler)
                        ? t.handler.bind(n)
                        : e[t.handler];
                    Object(s.q)(r) && Pr(i, r, t);
                }
            else 0;
        }
        function Mr(t, e, n) {
            const r = n.appContext.config.optionMergeStrategies;
            for (const i in e)
                r && Object(s.m)(r, i)
                    ? (t[i] = r[i](t[i], e[i], n.proxy, i))
                    : Object(s.m)(t, i) || (t[i] = e[i]);
        }
        const Rr = Object(s.j)(Object.create(null), {
                $: (t) => t,
                $el: (t) => t.vnode.el,
                $data: (t) => t.data,
                $props: (t) => t.props,
                $attrs: (t) => t.attrs,
                $slots: (t) => t.slots,
                $refs: (t) => t.refs,
                $parent: (t) => t.parent && t.parent.proxy,
                $root: (t) => t.root && t.root.proxy,
                $emit: (t) => t.emit,
                $options: (t) =>
                    __VUE_OPTIONS_API__
                        ? (function (t) {
                              const e = t.type,
                                  { __merged: n, mixins: r, extends: s } = e;
                              if (n) return n;
                              const i = t.appContext.mixins;
                              if (!i.length && !r && !s) return e;
                              const o = {};
                              return (
                                  i.forEach((e) => Mr(o, e, t)),
                                  s && Mr(o, s, t),
                                  r && r.forEach((e) => Mr(o, e, t)),
                                  Mr(o, e, t),
                                  (e.__merged = o)
                              );
                          })(t)
                        : t.type,
                $forceUpdate: (t) => () => Yt(t.update),
                $nextTick: () => Xt,
                $watch: (t) => (__VUE_OPTIONS_API__ ? Er.bind(t) : s.d),
            }),
            Dr = {
                get({ _: t }, e) {
                    const {
                        ctx: n,
                        setupState: r,
                        data: i,
                        props: o,
                        accessCache: a,
                        type: c,
                        appContext: l,
                    } = t;
                    if ("__v_skip" === e) return !0;
                    let u;
                    if ("$" !== e[0]) {
                        const t = a[e];
                        if (void 0 !== t)
                            switch (t) {
                                case 0:
                                    return r[e];
                                case 1:
                                    return i[e];
                                case 3:
                                    return n[e];
                                case 2:
                                    return o[e];
                            }
                        else {
                            if (r !== s.b && Object(s.m)(r, e))
                                return (a[e] = 0), r[e];
                            if (i !== s.b && Object(s.m)(i, e))
                                return (a[e] = 1), i[e];
                            if ((u = xn(c)[0]) && Object(s.m)(u, e))
                                return (a[e] = 2), o[e];
                            if (n !== s.b && Object(s.m)(n, e))
                                return (a[e] = 3), n[e];
                            (__VUE_OPTIONS_API__ && Or) || (a[e] = 4);
                        }
                    }
                    const h = Rr[e];
                    let p, d;
                    return h
                        ? ("$attrs" === e && v(t, 0, e), h(t))
                        : (p = c.__cssModules) && (p = p[e])
                        ? p
                        : n !== s.b && Object(s.m)(n, e)
                        ? ((a[e] = 3), n[e])
                        : ((d = l.config.globalProperties),
                          Object(s.m)(d, e) ? d[e] : void 0);
                },
                set({ _: t }, e, n) {
                    const { data: r, setupState: i, ctx: o } = t;
                    if (i !== s.b && Object(s.m)(i, e)) i[e] = n;
                    else if (r !== s.b && Object(s.m)(r, e)) r[e] = n;
                    else if (e in t.props) return !1;
                    return (
                        ("$" !== e[0] || !(e.slice(1) in t)) && ((o[e] = n), !0)
                    );
                },
                has(
                    {
                        _: {
                            data: t,
                            setupState: e,
                            accessCache: n,
                            ctx: r,
                            type: i,
                            appContext: o,
                        },
                    },
                    a
                ) {
                    let c;
                    return (
                        void 0 !== n[a] ||
                        (t !== s.b && Object(s.m)(t, a)) ||
                        (e !== s.b && Object(s.m)(e, a)) ||
                        ((c = xn(i)[0]) && Object(s.m)(c, a)) ||
                        Object(s.m)(r, a) ||
                        Object(s.m)(Rr, a) ||
                        Object(s.m)(o.config.globalProperties, a)
                    );
                },
            };
        const Fr = Object(s.j)({}, Dr, {
            get(t, e) {
                if (e !== Symbol.unscopables) return Dr.get(t, e, t);
            },
            has: (t, e) => "_" !== e[0] && !Object(s.r)(e),
        });
        const Br = ar();
        let Ur = 0;
        let Vr = null;
        const qr = () => Vr || ie,
            $r = (t) => {
                Vr = t;
            };
        let zr,
            Hr = !1;
        function Wr(t, e, n) {
            Object(s.q)(e)
                ? (t.render = e)
                : Object(s.v)(e) &&
                  (__VUE_PROD_DEVTOOLS__ && (t.devtoolsRawSetupState = e),
                  (t.setupState = Et(e))),
                Kr(t);
        }
        function Gr(t) {
            zr = t;
        }
        function Kr(t, e) {
            const n = t.type;
            t.render ||
                (zr &&
                    n.template &&
                    !n.render &&
                    (n.render = zr(n.template, {
                        isCustomElement: t.appContext.config.isCustomElement,
                        delimiters: n.delimiters,
                    })),
                (t.render = n.render || s.d),
                t.render._rc && (t.withProxy = new Proxy(t.ctx, Fr))),
                __VUE_OPTIONS_API__ && ((Vr = t), kr(t, n), (Vr = null));
        }
        function Jr(t) {
            Vr && (Vr.effects || (Vr.effects = [])).push(t);
        }
        const Xr = /(?:^|[-_])(\w)/g;
        function Yr(t, e, n = !1) {
            let r = (Object(s.q)(e) && e.displayName) || e.name;
            if (!r && e.__file) {
                const t = e.__file.match(/([^/\\]+)\.vue$/);
                t && (r = t[1]);
            }
            if (!r && t && t.parent) {
                const n = (t) => {
                    for (const n in t) if (t[n] === e) return n;
                };
                r =
                    n(t.components || t.parent.type.components) ||
                    n(t.appContext.components);
            }
            return r
                ? r.replace(Xr, (t) => t.toUpperCase()).replace(/[-_]/g, "")
                : n
                ? "App"
                : "Anonymous";
        }
        function Qr(t) {
            const e = (function (t) {
                let e, n;
                return (
                    Object(s.q)(t)
                        ? ((e = t), (n = s.d))
                        : ((e = t.get), (n = t.set)),
                    new _t(e, n, Object(s.q)(t) || !t.set)
                );
            })(t);
            return Jr(e.effect), e;
        }
        function Zr(t) {
            return Object(s.q)(t) ? { setup: t, name: t.name } : t;
        }
        function ts(t) {
            Object(s.q)(t) && (t = { loader: t });
            const {
                loader: e,
                loadingComponent: n,
                errorComponent: r,
                delay: i = 200,
                timeout: o,
                suspensible: a = !0,
                onError: c,
            } = t;
            let l,
                u = null,
                h = 0;
            const p = () => {
                let t;
                return (
                    u ||
                    (t = u =
                        e()
                            .catch((t) => {
                                if (
                                    ((t =
                                        t instanceof Error
                                            ? t
                                            : new Error(String(t))),
                                    c)
                                )
                                    return new Promise((e, n) => {
                                        c(
                                            t,
                                            () => e((h++, (u = null), p())),
                                            () => n(t),
                                            h + 1
                                        );
                                    });
                                throw t;
                            })
                            .then((e) =>
                                t !== u && u
                                    ? u
                                    : (e &&
                                          (e.__esModule ||
                                              "Module" ===
                                                  e[Symbol.toStringTag]) &&
                                          (e = e.default),
                                      (l = e),
                                      e)
                            ))
                );
            };
            return Zr({
                __asyncLoader: p,
                name: "AsyncComponentWrapper",
                setup() {
                    const t = Vr;
                    if (l) return () => es(l, t);
                    const e = (e) => {
                        (u = null), Rt(e, t, 13);
                    };
                    if (a && t.suspense)
                        return p()
                            .then((e) => () => es(e, t))
                            .catch(
                                (t) => (
                                    e(t), () => (r ? Ze(r, { error: t }) : null)
                                )
                            );
                    const s = gt(!1),
                        c = gt(),
                        h = gt(!!i);
                    return (
                        i &&
                            setTimeout(() => {
                                h.value = !1;
                            }, i),
                        null != o &&
                            setTimeout(() => {
                                if (!s.value) {
                                    const t = new Error(
                                        `Async component timed out after ${o}ms.`
                                    );
                                    e(t), (c.value = t);
                                }
                            }, o),
                        p()
                            .then(() => {
                                s.value = !0;
                            })
                            .catch((t) => {
                                e(t), (c.value = t);
                            }),
                        () =>
                            s.value && l
                                ? es(l, t)
                                : c.value && r
                                ? Ze(r, { error: c.value })
                                : n && !h.value
                                ? Ze(n)
                                : void 0
                    );
                },
            });
        }
        function es(t, { vnode: { props: e, children: n } }) {
            return Ze(t, e, n);
        }
        function ns(t, e, n) {
            const r = arguments.length;
            return 2 === r
                ? Object(s.v)(e) && !Object(s.p)(e)
                    ? Ge(e)
                        ? Ze(t, null, [e])
                        : Ze(t, e)
                    : Ze(t, null, e)
                : (r > 3
                      ? (n = Array.prototype.slice.call(arguments, 2))
                      : 3 === r && Ge(n) && (n = [n]),
                  Ze(t, e, n));
        }
        const rs = Symbol(""),
            ss = () => {
                {
                    const t = Cr(rs);
                    return (
                        t ||
                            It(
                                "Server rendering context not provided. Make sure to only call useSsrContext() conditionally in the server build."
                            ),
                        t
                    );
                }
            };
        function is(t, e) {
            let n;
            if (Object(s.p)(t) || Object(s.B)(t)) {
                n = new Array(t.length);
                for (let r = 0, s = t.length; r < s; r++) n[r] = e(t[r], r);
            } else if ("number" == typeof t) {
                n = new Array(t);
                for (let r = 0; r < t; r++) n[r] = e(r + 1, r);
            } else if (Object(s.v)(t))
                if (t[Symbol.iterator]) n = Array.from(t, e);
                else {
                    const r = Object.keys(t);
                    n = new Array(r.length);
                    for (let s = 0, i = r.length; s < i; s++) {
                        const i = r[s];
                        n[s] = e(t[i], i, s);
                    }
                }
            else n = [];
            return n;
        }
        function os(t) {
            const e = {};
            for (const n in t) e["on" + Object(s.h)(n)] = t[n];
            return e;
        }
        function as(t, e) {
            for (let n = 0; n < e.length; n++) {
                const r = e[n];
                if (Object(s.p)(r))
                    for (let e = 0; e < r.length; e++) t[r[e].name] = r[e].fn;
                else r && (t[r.name] = r.fn);
            }
            return t;
        }
        const cs = "3.0.0-rc.9",
            ls = null,
            us = "http://www.w3.org/2000/svg",
            hs = "undefined" != typeof document ? document : null;
        let ps, ds;
        const fs = {
            insert: (t, e, n) => {
                e.insertBefore(t, n || null);
            },
            remove: (t) => {
                const e = t.parentNode;
                e && e.removeChild(t);
            },
            createElement: (t, e, n) =>
                e
                    ? hs.createElementNS(us, t)
                    : hs.createElement(t, n ? { is: n } : void 0),
            createText: (t) => hs.createTextNode(t),
            createComment: (t) => hs.createComment(t),
            setText: (t, e) => {
                t.nodeValue = e;
            },
            setElementText: (t, e) => {
                t.textContent = e;
            },
            parentNode: (t) => t.parentNode,
            nextSibling: (t) => t.nextSibling,
            querySelector: (t) => hs.querySelector(t),
            setScopeId(t, e) {
                t.setAttribute(e, "");
            },
            cloneNode: (t) => t.cloneNode(!0),
            insertStaticContent(t, e, n, r) {
                const s = r
                    ? ds || (ds = hs.createElementNS(us, "svg"))
                    : ps || (ps = hs.createElement("div"));
                s.innerHTML = t;
                const i = s.firstChild;
                let o = i,
                    a = o;
                for (; o; ) (a = o), fs.insert(o, e, n), (o = s.firstChild);
                return [i, a];
            },
        };
        const ms = /\s*!important$/;
        function ys(t, e, n) {
            if (Object(s.p)(n)) n.forEach((n) => ys(t, e, n));
            else if (e.startsWith("--")) t.setProperty(e, n);
            else {
                const r = (function (t, e) {
                    const n = vs[e];
                    if (n) return n;
                    let r = Object(s.g)(e);
                    if ("filter" !== r && r in t) return (vs[e] = r);
                    r = Object(s.h)(r);
                    for (let n = 0; n < gs.length; n++) {
                        const s = gs[n] + r;
                        if (s in t) return (vs[e] = s);
                    }
                    return e;
                })(t, e);
                ms.test(n)
                    ? t.setProperty(
                          Object(s.n)(r),
                          n.replace(ms, ""),
                          "important"
                      )
                    : (t[r] = n);
            }
        }
        const gs = ["Webkit", "Moz", "ms"],
            vs = {};
        const bs = "http://www.w3.org/1999/xlink";
        let xs = Date.now;
        "undefined" != typeof document &&
            xs() > document.createEvent("Event").timeStamp &&
            (xs = () => performance.now());
        let ws = 0;
        const Ps = Promise.resolve(),
            As = () => {
                ws = 0;
            };
        function Es(t, e, n, r) {
            t.addEventListener(e, n, r);
        }
        function Ts(t, e, n, r, i = null) {
            const o = t._vei || (t._vei = {}),
                a = o[e];
            if (r && a) a.value = r;
            else {
                const [n, c] = (function (t) {
                    let e;
                    if (Ss.test(t)) {
                        let n;
                        for (e = {}; (n = t.match(Ss)); )
                            (t = t.slice(0, t.length - n[0].length)),
                                (e[n[0].toLowerCase()] = !0);
                    }
                    return [t.slice(2).toLowerCase(), e];
                })(e);
                if (r) {
                    Es(
                        t,
                        n,
                        (o[e] = (function (t, e) {
                            const n = (t) => {
                                (t.timeStamp || xs()) >= n.attached - 1 &&
                                    Mt(
                                        (function (t, e) {
                                            if (Object(s.p)(e)) {
                                                const n =
                                                    t.stopImmediatePropagation;
                                                return (
                                                    (t.stopImmediatePropagation =
                                                        () => {
                                                            n.call(t),
                                                                (t._stopped =
                                                                    !0);
                                                        }),
                                                    e.map(
                                                        (t) => (e) =>
                                                            !e._stopped && t(e)
                                                    )
                                                );
                                            }
                                            return e;
                                        })(t, n.value),
                                        e,
                                        5,
                                        [t]
                                    );
                            };
                            return (
                                (n.value = t),
                                (n.attached = (() =>
                                    ws || (Ps.then(As), (ws = xs())))()),
                                n
                            );
                        })(r, i)),
                        c
                    );
                } else
                    a &&
                        (!(function (t, e, n, r) {
                            t.removeEventListener(e, n, r);
                        })(t, n, a, c),
                        (o[e] = void 0));
            }
        }
        const Ss = /(?:Once|Passive|Capture)$/;
        const Cs = /^on[a-z]/;
        function Os(t = "$style") {
            {
                const e = qr();
                if (!e) return s.b;
                const n = e.type.__cssModules;
                if (!n) return s.b;
                const r = n[t];
                return r || s.b;
            }
        }
        function ks(t, e = !1) {
            const n = qr();
            if (!n) return;
            const r =
                e && n.type.__scopeId
                    ? n.type.__scopeId.replace(/^data-v-/, "") + "-"
                    : "";
            On(() => {
                xr(() => {
                    !(function t(e, n, r) {
                        if (128 & e.shapeFlag) {
                            const {
                                isResolved: s,
                                isHydrating: i,
                                fallbackTree: o,
                                subTree: a,
                            } = e.suspense;
                            s || i
                                ? (e = a)
                                : (e.suspense.effects.push(() => {
                                      t(a, n, r);
                                  }),
                                  (e = o));
                        }
                        for (; e.component; ) e = e.component.subTree;
                        if (1 & e.shapeFlag && e.el) {
                            const t = e.el.style;
                            for (const e in n)
                                t.setProperty(`--${r}${e}`, Pt(n[e]));
                        } else
                            e.type === Me &&
                                e.children.forEach((e) => t(e, n, r));
                    })(n.subTree, t(n.proxy), r);
                });
            });
        }
        const _s = "transition",
            Ns = "animation",
            Is = (t, { slots: e }) => ns(Fn, Ms(t), e);
        Is.displayName = "Transition";
        const js = {
                name: String,
                type: String,
                css: { type: Boolean, default: !0 },
                duration: [String, Number, Object],
                enterFromClass: String,
                enterActiveClass: String,
                enterToClass: String,
                appearFromClass: String,
                appearActiveClass: String,
                appearToClass: String,
                leaveFromClass: String,
                leaveActiveClass: String,
                leaveToClass: String,
            },
            Ls = (Is.props = Object(s.j)({}, Fn.props, js));
        function Ms(t) {
            let {
                name: e = "v",
                type: n,
                css: r = !0,
                duration: i,
                enterFromClass: o = e + "-enter-from",
                enterActiveClass: a = e + "-enter-active",
                enterToClass: c = e + "-enter-to",
                appearFromClass: l = o,
                appearActiveClass: u = a,
                appearToClass: h = c,
                leaveFromClass: p = e + "-leave-from",
                leaveActiveClass: d = e + "-leave-active",
                leaveToClass: f = e + "-leave-to",
            } = t;
            const m = {};
            for (const e in t) e in js || (m[e] = t[e]);
            if (!r) return m;
            const y = (function (t) {
                    if (null == t) return null;
                    if (Object(s.v)(t)) return [Rs(t.enter), Rs(t.leave)];
                    {
                        const e = Rs(t);
                        return [e, e];
                    }
                })(i),
                g = y && y[0],
                v = y && y[1],
                {
                    onBeforeEnter: b,
                    onEnter: x,
                    onEnterCancelled: w,
                    onLeave: P,
                    onLeaveCancelled: A,
                    onBeforeAppear: E = b,
                    onAppear: T = x,
                    onAppearCancelled: S = w,
                } = m,
                C = (t, e, n) => {
                    Fs(t, e ? h : c), Fs(t, e ? u : a), n && n();
                },
                O = (t, e) => {
                    Fs(t, f), Fs(t, d), e && e();
                },
                k = (t) => (e, r) => {
                    const s = t ? T : x,
                        i = () => C(e, t, r);
                    s && s(e, i),
                        Bs(() => {
                            Fs(e, t ? l : o),
                                Ds(e, t ? h : c),
                                (s && s.length > 1) ||
                                    (g ? setTimeout(i, g) : Us(e, n, i));
                        });
                };
            return Object(s.j)(m, {
                onBeforeEnter(t) {
                    b && b(t), Ds(t, a), Ds(t, o);
                },
                onBeforeAppear(t) {
                    E && E(t), Ds(t, u), Ds(t, l);
                },
                onEnter: k(!1),
                onAppear: k(!0),
                onLeave(t, e) {
                    const r = () => O(t, e);
                    Ds(t, d),
                        Ds(t, p),
                        Bs(() => {
                            Fs(t, p),
                                Ds(t, f),
                                (P && P.length > 1) ||
                                    (v ? setTimeout(r, v) : Us(t, n, r));
                        }),
                        P && P(t, r);
                },
                onEnterCancelled(t) {
                    C(t, !1), w && w(t);
                },
                onAppearCancelled(t) {
                    C(t, !0), S && S(t);
                },
                onLeaveCancelled(t) {
                    O(t), A && A(t);
                },
            });
        }
        function Rs(t) {
            return Object(s.M)(t);
        }
        function Ds(t, e) {
            e.split(/\s+/).forEach((e) => e && t.classList.add(e)),
                (t._vtc || (t._vtc = new Set())).add(e);
        }
        function Fs(t, e) {
            e.split(/\s+/).forEach((e) => e && t.classList.remove(e));
            const { _vtc: n } = t;
            n && (n.delete(e), n.size || (t._vtc = void 0));
        }
        function Bs(t) {
            requestAnimationFrame(() => {
                requestAnimationFrame(t);
            });
        }
        function Us(t, e, n) {
            const { type: r, timeout: s, propCount: i } = Vs(t, e);
            if (!r) return n();
            const o = r + "end";
            let a = 0;
            const c = () => {
                    t.removeEventListener(o, l), n();
                },
                l = (e) => {
                    e.target === t && ++a >= i && c();
                };
            setTimeout(() => {
                a < i && c();
            }, s + 1),
                t.addEventListener(o, l);
        }
        function Vs(t, e) {
            const n = window.getComputedStyle(t),
                r = (t) => (n[t] || "").split(", "),
                s = r("transitionDelay"),
                i = r("transitionDuration"),
                o = qs(s, i),
                a = r("animationDelay"),
                c = r("animationDuration"),
                l = qs(a, c);
            let u = null,
                h = 0,
                p = 0;
            e === _s
                ? o > 0 && ((u = _s), (h = o), (p = i.length))
                : e === Ns
                ? l > 0 && ((u = Ns), (h = l), (p = c.length))
                : ((h = Math.max(o, l)),
                  (u = h > 0 ? (o > l ? _s : Ns) : null),
                  (p = u ? (u === _s ? i.length : c.length) : 0));
            return {
                type: u,
                timeout: h,
                propCount: p,
                hasTransform:
                    u === _s &&
                    /\b(transform|all)(,|$)/.test(n.transitionProperty),
            };
        }
        function qs(t, e) {
            for (; t.length < e.length; ) t = t.concat(t);
            return Math.max(...e.map((e, n) => $s(e) + $s(t[n])));
        }
        function $s(t) {
            return 1e3 * Number(t.slice(0, -1).replace(",", "."));
        }
        const zs = new WeakMap(),
            Hs = new WeakMap(),
            Ws = {
                name: "TransitionGroup",
                props: Object(s.j)({}, Ls, { tag: String, moveClass: String }),
                setup(t, { slots: e }) {
                    const n = qr(),
                        r = Rn();
                    let s, i;
                    return (
                        _n(() => {
                            if (!s.length) return;
                            const e = t.moveClass || (t.name || "v") + "-move";
                            if (
                                !(function (t, e, n) {
                                    const r = t.cloneNode();
                                    t._vtc &&
                                        t._vtc.forEach((t) => {
                                            t.split(/\s+/).forEach(
                                                (t) =>
                                                    t && r.classList.remove(t)
                                            );
                                        });
                                    n
                                        .split(/\s+/)
                                        .forEach(
                                            (t) => t && r.classList.add(t)
                                        ),
                                        (r.style.display = "none");
                                    const s =
                                        1 === e.nodeType ? e : e.parentNode;
                                    s.appendChild(r);
                                    const { hasTransform: i } = Vs(r);
                                    return s.removeChild(r), i;
                                })(s[0].el, n.vnode.el, e)
                            )
                                return;
                            s.forEach(Gs), s.forEach(Ks);
                            const r = s.filter(Js);
                            document.body.offsetHeight,
                                r.forEach((t) => {
                                    const n = t.el,
                                        r = n.style;
                                    Ds(n, e),
                                        (r.transform =
                                            r.webkitTransform =
                                            r.transitionDuration =
                                                "");
                                    const s = (n._moveCb = (t) => {
                                        (t && t.target !== n) ||
                                            (t &&
                                                !/transform$/.test(
                                                    t.propertyName
                                                )) ||
                                            (n.removeEventListener(
                                                "transitionend",
                                                s
                                            ),
                                            (n._moveCb = null),
                                            Fs(n, e));
                                    });
                                    n.addEventListener("transitionend", s);
                                });
                        }),
                        () => {
                            const o = (function t(e) {
                                    return (e && t(e.__v_raw)) || e;
                                })(t),
                                a = Ms(o),
                                c = o.tag || Me;
                            (s = i), (i = e.default ? zn(e.default()) : []);
                            for (let t = 0; t < i.length; t++) {
                                const e = i[t];
                                null != e.key && $n(e, Un(e, a, r, n));
                            }
                            if (s)
                                for (let t = 0; t < s.length; t++) {
                                    const e = s[t];
                                    $n(e, Un(e, a, r, n)),
                                        zs.set(e, e.el.getBoundingClientRect());
                                }
                            return Ze(c, null, i);
                        }
                    );
                },
            };
        function Gs(t) {
            const e = t.el;
            e._moveCb && e._moveCb(), e._enterCb && e._enterCb();
        }
        function Ks(t) {
            Hs.set(t, t.el.getBoundingClientRect());
        }
        function Js(t) {
            const e = zs.get(t),
                n = Hs.get(t),
                r = e.left - n.left,
                s = e.top - n.top;
            if (r || s) {
                const e = t.el.style;
                return (
                    (e.transform = e.webkitTransform =
                        `translate(${r}px,${s}px)`),
                    (e.transitionDuration = "0s"),
                    t
                );
            }
        }
        const Xs = (t) => {
            const e = t.props["onUpdate:modelValue"];
            return Object(s.p)(e) ? (t) => Object(s.o)(e, t) : e;
        };
        function Ys(t) {
            t.target.composing = !0;
        }
        function Qs(t) {
            const e = t.target;
            e.composing &&
                ((e.composing = !1),
                (function (t, e) {
                    const n = document.createEvent("HTMLEvents");
                    n.initEvent(e, !0, !0), t.dispatchEvent(n);
                })(e, "input"));
        }
        const Zs = {
                created(
                    t,
                    { value: e, modifiers: { lazy: n, trim: r, number: i } },
                    o
                ) {
                    (t.value = null == e ? "" : e), (t._assign = Xs(o));
                    const a = i || "number" === t.type;
                    Es(t, n ? "change" : "input", (e) => {
                        if (e.target.composing) return;
                        let n = t.value;
                        r ? (n = n.trim()) : a && (n = Object(s.M)(n)),
                            t._assign(n);
                    }),
                        r &&
                            Es(t, "change", () => {
                                t.value = t.value.trim();
                            }),
                        n ||
                            (Es(t, "compositionstart", Ys),
                            Es(t, "compositionend", Qs),
                            Es(t, "change", Qs));
                },
                beforeUpdate(
                    t,
                    { value: e, modifiers: { trim: n, number: r } },
                    i
                ) {
                    if (((t._assign = Xs(i)), document.activeElement === t)) {
                        if (n && t.value.trim() === e) return;
                        if (
                            (r || "number" === t.type) &&
                            Object(s.M)(t.value) === e
                        )
                            return;
                    }
                    const o = null == e ? "" : e;
                    t.value !== o && (t.value = o);
                },
            },
            ti = {
                created(t, e, n) {
                    ei(t, e, n),
                        (t._assign = Xs(n)),
                        Es(t, "change", () => {
                            const e = t._modelValue,
                                n = ii(t),
                                r = t.checked,
                                i = t._assign;
                            if (Object(s.p)(e)) {
                                const t = Object(s.F)(e, n),
                                    o = -1 !== t;
                                if (r && !o) i(e.concat(n));
                                else if (!r && o) {
                                    const n = [...e];
                                    n.splice(t, 1), i(n);
                                }
                            } else i(oi(t, r));
                        });
                },
                beforeUpdate(t, e, n) {
                    (t._assign = Xs(n)), ei(t, e, n);
                },
            };
        function ei(t, { value: e, oldValue: n }, r) {
            (t._modelValue = e),
                Object(s.p)(e)
                    ? (t.checked = Object(s.F)(e, r.props.value) > -1)
                    : e !== n && (t.checked = Object(s.E)(e, oi(t, !0)));
        }
        const ni = {
                created(t, { value: e }, n) {
                    (t.checked = Object(s.E)(e, n.props.value)),
                        (t._assign = Xs(n)),
                        Es(t, "change", () => {
                            t._assign(ii(t));
                        });
                },
                beforeUpdate(t, { value: e, oldValue: n }, r) {
                    (t._assign = Xs(r)),
                        e !== n && (t.checked = Object(s.E)(e, r.props.value));
                },
            },
            ri = {
                created(t, e, n) {
                    Es(t, "change", () => {
                        const e = Array.prototype.filter
                            .call(t.options, (t) => t.selected)
                            .map(ii);
                        t._assign(t.multiple ? e : e[0]);
                    }),
                        (t._assign = Xs(n));
                },
                mounted(t, { value: e }) {
                    si(t, e);
                },
                beforeUpdate(t, e, n) {
                    t._assign = Xs(n);
                },
                updated(t, { value: e }) {
                    si(t, e);
                },
            };
        function si(t, e) {
            const n = t.multiple;
            if (!n || Object(s.p)(e)) {
                for (let r = 0, i = t.options.length; r < i; r++) {
                    const i = t.options[r],
                        o = ii(i);
                    if (n) i.selected = Object(s.F)(e, o) > -1;
                    else if (Object(s.E)(ii(i), e))
                        return void (t.selectedIndex = r);
                }
                n || (t.selectedIndex = -1);
            }
        }
        function ii(t) {
            return "_value" in t ? t._value : t.value;
        }
        function oi(t, e) {
            const n = e ? "_trueValue" : "_falseValue";
            return n in t ? t[n] : e;
        }
        const ai = {
            created(t, e, n) {
                ci(t, e, n, null, "created");
            },
            mounted(t, e, n) {
                ci(t, e, n, null, "mounted");
            },
            beforeUpdate(t, e, n, r) {
                ci(t, e, n, r, "beforeUpdate");
            },
            updated(t, e, n, r) {
                ci(t, e, n, r, "updated");
            },
        };
        function ci(t, e, n, r, s) {
            let i;
            switch (t.tagName) {
                case "SELECT":
                    i = ri;
                    break;
                case "TEXTAREA":
                    i = Zs;
                    break;
                default:
                    switch (n.props && n.props.type) {
                        case "checkbox":
                            i = ti;
                            break;
                        case "radio":
                            i = ni;
                            break;
                        default:
                            i = Zs;
                    }
            }
            const o = i[s];
            o && o(t, e, n, r);
        }
        const li = ["ctrl", "shift", "alt", "meta"],
            ui = {
                stop: (t) => t.stopPropagation(),
                prevent: (t) => t.preventDefault(),
                self: (t) => t.target !== t.currentTarget,
                ctrl: (t) => !t.ctrlKey,
                shift: (t) => !t.shiftKey,
                alt: (t) => !t.altKey,
                meta: (t) => !t.metaKey,
                left: (t) => "button" in t && 0 !== t.button,
                middle: (t) => "button" in t && 1 !== t.button,
                right: (t) => "button" in t && 2 !== t.button,
                exact: (t, e) => li.some((n) => t[n + "Key"] && !e.includes(n)),
            },
            hi =
                (t, e) =>
                (n, ...r) => {
                    for (let t = 0; t < e.length; t++) {
                        const r = ui[e[t]];
                        if (r && r(n, e)) return;
                    }
                    return t(n, ...r);
                },
            pi = {
                esc: "escape",
                space: " ",
                up: "arrow-up",
                left: "arrow-left",
                right: "arrow-right",
                down: "arrow-down",
                delete: "backspace",
            },
            di = (t, e) => (n) => {
                if (!("key" in n)) return;
                const r = Object(s.n)(n.key);
                return e.some((t) => t === r || pi[t] === r) ? t(n) : void 0;
            },
            fi = {
                beforeMount(t, { value: e }, { transition: n }) {
                    (t._vod =
                        "none" === t.style.display ? "" : t.style.display),
                        n && e ? n.beforeEnter(t) : mi(t, e);
                },
                mounted(t, { value: e }, { transition: n }) {
                    n && e && n.enter(t);
                },
                updated(t, { value: e, oldValue: n }, { transition: r }) {
                    !e != !n &&
                        (r
                            ? e
                                ? (r.beforeEnter(t), mi(t, !0), r.enter(t))
                                : r.leave(t, () => {
                                      mi(t, !1);
                                  })
                            : mi(t, e));
                },
                beforeUnmount(t, { value: e }) {
                    mi(t, e);
                },
            };
        function mi(t, e) {
            t.style.display = e ? t._vod : "none";
        }
        const yi = Object(s.j)(
            {
                patchProp: (t, e, n, r, i = !1, o, a, c, l) => {
                    switch (e) {
                        case "class":
                            !(function (t, e, n) {
                                if ((null == e && (e = ""), n))
                                    t.setAttribute("class", e);
                                else {
                                    const n = t._vtc;
                                    n &&
                                        (e = (e ? [e, ...n] : [...n]).join(
                                            " "
                                        )),
                                        (t.className = e);
                                }
                            })(t, r, i);
                            break;
                        case "style":
                            !(function (t, e, n) {
                                const r = t.style;
                                if (n)
                                    if (Object(s.B)(n))
                                        e !== n && (r.cssText = n);
                                    else {
                                        for (const t in n) ys(r, t, n[t]);
                                        if (e && !Object(s.B)(e))
                                            for (const t in e)
                                                null == n[t] && ys(r, t, "");
                                    }
                                else t.removeAttribute("style");
                            })(t, n, r);
                            break;
                        default:
                            Object(s.w)(e)
                                ? Object(s.u)(e) || Ts(t, e, 0, r, a)
                                : (function (t, e, n, r) {
                                      if (r)
                                          return (
                                              "innerHTML" === e ||
                                              !!(
                                                  e in t &&
                                                  Cs.test(e) &&
                                                  Object(s.q)(n)
                                              )
                                          );
                                      if (
                                          "spellcheck" === e ||
                                          "draggable" === e
                                      )
                                          return !1;
                                      if ("form" === e && "string" == typeof n)
                                          return !1;
                                      if ("list" === e && "INPUT" === t.tagName)
                                          return !1;
                                      if (Cs.test(e) && Object(s.B)(n))
                                          return !1;
                                      return e in t;
                                  })(t, e, r, i)
                                ? (function (t, e, n, r, s, i, o) {
                                      if (
                                          "innerHTML" === e ||
                                          "textContent" === e
                                      )
                                          return (
                                              r && o(r, s, i),
                                              void (t[e] = null == n ? "" : n)
                                          );
                                      if (
                                          "value" !== e ||
                                          "PROGRESS" === t.tagName
                                      )
                                          if (
                                              "" === n &&
                                              "boolean" == typeof t[e]
                                          )
                                              t[e] = !0;
                                          else if (
                                              null == n &&
                                              "string" == typeof t[e]
                                          )
                                              (t[e] = ""), t.removeAttribute(e);
                                          else
                                              try {
                                                  t[e] = n;
                                              } catch (t) {}
                                      else {
                                          t._value = n;
                                          const e = null == n ? "" : n;
                                          t.value !== e && (t.value = e);
                                      }
                                  })(t, e, r, o, a, c, l)
                                : ("true-value" === e
                                      ? (t._trueValue = r)
                                      : "false-value" === e &&
                                        (t._falseValue = r),
                                  (function (t, e, n, r) {
                                      if (r && e.startsWith("xlink:"))
                                          null == n
                                              ? t.removeAttributeNS(
                                                    bs,
                                                    e.slice(6, e.length)
                                                )
                                              : t.setAttributeNS(bs, e, n);
                                      else {
                                          const r = Object(s.A)(e);
                                          null == n || (r && !1 === n)
                                              ? t.removeAttribute(e)
                                              : t.setAttribute(e, r ? "" : n);
                                      }
                                  })(t, e, r, i));
                    }
                },
                forcePatchProp: (t, e) => "value" === e,
            },
            fs
        );
        let gi,
            vi = !1;
        function bi() {
            return gi || (gi = yr(yi));
        }
        function xi() {
            return (gi = vi ? gi : gr(yi)), (vi = !0), gi;
        }
        const wi = (...t) => {
                bi().render(...t);
            },
            Pi = (...t) => {
                xi().hydrate(...t);
            },
            Ai = (...t) => {
                const e = bi().createApp(...t);
                const { mount: n } = e;
                return (
                    (e.mount = (t) => {
                        const r = Ti(t);
                        if (!r) return;
                        const i = e._component;
                        Object(s.q)(i) ||
                            i.render ||
                            i.template ||
                            (i.template = r.innerHTML),
                            (r.innerHTML = "");
                        const o = n(r);
                        return (
                            r.removeAttribute("v-cloak"),
                            r.setAttribute("data-v-app", ""),
                            o
                        );
                    }),
                    e
                );
            },
            Ei = (...t) => {
                const e = xi().createApp(...t);
                const { mount: n } = e;
                return (
                    (e.mount = (t) => {
                        const e = Ti(t);
                        if (e) return n(e, !0);
                    }),
                    e
                );
            };
        function Ti(t) {
            if (Object(s.B)(t)) {
                return document.querySelector(t);
            }
            return t;
        }
        n(165);
        function Si(t) {
            throw t;
        }
        function Ci(t, e, n, r) {
            const s = new SyntaxError(String(t));
            return (s.code = t), (s.loc = e), s;
        }
        const Oi = Symbol(""),
            ki = Symbol(""),
            _i = Symbol(""),
            Ni = Symbol(""),
            Ii = Symbol(""),
            ji = Symbol(""),
            Li = Symbol(""),
            Mi = Symbol(""),
            Ri = Symbol(""),
            Di = Symbol(""),
            Fi = Symbol(""),
            Bi = Symbol(""),
            Ui = Symbol(""),
            Vi = Symbol(""),
            qi = Symbol(""),
            $i = Symbol(""),
            zi = Symbol(""),
            Hi = Symbol(""),
            Wi = Symbol(""),
            Gi = Symbol(""),
            Ki = Symbol(""),
            Ji = Symbol(""),
            Xi = Symbol(""),
            Yi = Symbol(""),
            Qi = Symbol(""),
            Zi = Symbol(""),
            to = Symbol(""),
            eo = Symbol(""),
            no = {
                [Oi]: "Fragment",
                [ki]: "Teleport",
                [_i]: "Suspense",
                [Ni]: "KeepAlive",
                [Ii]: "BaseTransition",
                [ji]: "openBlock",
                [Li]: "createBlock",
                [Mi]: "createVNode",
                [Ri]: "createCommentVNode",
                [Di]: "createTextVNode",
                [Fi]: "createStaticVNode",
                [Bi]: "resolveComponent",
                [Ui]: "resolveDynamicComponent",
                [Vi]: "resolveDirective",
                [qi]: "withDirectives",
                [$i]: "renderList",
                [zi]: "renderSlot",
                [Hi]: "createSlots",
                [Wi]: "toDisplayString",
                [Gi]: "mergeProps",
                [Ki]: "toHandlers",
                [Ji]: "camelize",
                [Xi]: "capitalize",
                [Yi]: "setBlockTracking",
                [Qi]: "pushScopeId",
                [Zi]: "popScopeId",
                [to]: "withScopeId",
                [eo]: "withCtx",
            };
        const ro = {
            source: "",
            start: { line: 1, column: 1, offset: 0 },
            end: { line: 1, column: 1, offset: 0 },
        };
        function so(t, e, n, r, s, i, o, a = !1, c = !1, l = ro) {
            return (
                t &&
                    (a ? (t.helper(ji), t.helper(Li)) : t.helper(Mi),
                    o && t.helper(qi)),
                {
                    type: 13,
                    tag: e,
                    props: n,
                    children: r,
                    patchFlag: s,
                    dynamicProps: i,
                    directives: o,
                    isBlock: a,
                    disableTracking: c,
                    loc: l,
                }
            );
        }
        function io(t, e = ro) {
            return { type: 17, loc: e, elements: t };
        }
        function oo(t, e = ro) {
            return { type: 15, loc: e, properties: t };
        }
        function ao(t, e) {
            return {
                type: 16,
                loc: ro,
                key: Object(s.B)(t) ? co(t, !0) : t,
                value: e,
            };
        }
        function co(t, e, n = ro, r = !1) {
            return { type: 4, loc: n, isConstant: r, content: t, isStatic: e };
        }
        function lo(t, e = ro) {
            return { type: 8, loc: e, children: t };
        }
        function uo(t, e = [], n = ro) {
            return { type: 14, loc: n, callee: t, arguments: e };
        }
        function ho(t, e, n = !1, r = !1, s = ro) {
            return {
                type: 18,
                params: t,
                returns: e,
                newline: n,
                isSlot: r,
                loc: s,
            };
        }
        function po(t, e, n, r = !0) {
            return {
                type: 19,
                test: t,
                consequent: e,
                alternate: n,
                newline: r,
                loc: ro,
            };
        }
        const fo = (t) => 4 === t.type && t.isStatic,
            mo = (t, e) => t === e || t === Object(s.n)(e);
        function yo(t) {
            return mo(t, "Teleport")
                ? ki
                : mo(t, "Suspense")
                ? _i
                : mo(t, "KeepAlive")
                ? Ni
                : mo(t, "BaseTransition")
                ? Ii
                : void 0;
        }
        const go = /^\d|[^\$\w]/,
            vo = (t) => !go.test(t),
            bo = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\[[^\]]+\])*$/,
            xo = (t) => !!t && bo.test(t.trim());
        function wo(t, e, n) {
            const r = {
                source: t.source.substr(e, n),
                start: Po(t.start, t.source, e),
                end: t.end,
            };
            return null != n && (r.end = Po(t.start, t.source, e + n)), r;
        }
        function Po(t, e, n = e.length) {
            return Ao(Object(s.j)({}, t), e, n);
        }
        function Ao(t, e, n = e.length) {
            let r = 0,
                s = -1;
            for (let t = 0; t < n; t++)
                10 === e.charCodeAt(t) && (r++, (s = t));
            return (
                (t.offset += n),
                (t.line += r),
                (t.column = -1 === s ? t.column + n : n - s),
                t
            );
        }
        function Eo(t, e, n = !1) {
            for (let r = 0; r < t.props.length; r++) {
                const i = t.props[r];
                if (
                    7 === i.type &&
                    (n || i.exp) &&
                    (Object(s.B)(e) ? i.name === e : e.test(i.name))
                )
                    return i;
            }
        }
        function To(t, e, n = !1, r = !1) {
            for (let s = 0; s < t.props.length; s++) {
                const i = t.props[s];
                if (6 === i.type) {
                    if (n) continue;
                    if (i.name === e && (i.value || r)) return i;
                } else if ("bind" === i.name && (i.exp || r) && So(i.arg, e))
                    return i;
            }
        }
        function So(t, e) {
            return !(!t || !fo(t) || t.content !== e);
        }
        function Co(t) {
            return 5 === t.type || 2 === t.type;
        }
        function Oo(t) {
            return 7 === t.type && "slot" === t.name;
        }
        function ko(t) {
            return 1 === t.type && 3 === t.tagType;
        }
        function _o(t) {
            return 1 === t.type && 2 === t.tagType;
        }
        function No(t, e, n) {
            let r;
            const i = 13 === t.type ? t.props : t.arguments[2];
            if (null == i || Object(s.B)(i)) r = oo([e]);
            else if (14 === i.type) {
                const t = i.arguments[0];
                Object(s.B)(t) || 15 !== t.type
                    ? i.arguments.unshift(oo([e]))
                    : t.properties.unshift(e),
                    (r = i);
            } else if (15 === i.type) {
                let t = !1;
                if (4 === e.key.type) {
                    const n = e.key.content;
                    t = i.properties.some(
                        (t) => 4 === t.key.type && t.key.content === n
                    );
                }
                t || i.properties.unshift(e), (r = i);
            } else r = uo(n.helper(Gi), [oo([e]), i]);
            13 === t.type ? (t.props = r) : (t.arguments[2] = r);
        }
        function Io(t, e) {
            return `_${e}_${t.replace(/[^\w]/g, "_")}`;
        }
        const jo = /&(gt|lt|amp|apos|quot);/g,
            Lo = { gt: ">", lt: "<", amp: "&", apos: "'", quot: '"' },
            Mo = {
                delimiters: ["{{", "}}"],
                getNamespace: () => 0,
                getTextMode: () => 0,
                isVoidTag: s.c,
                isPreTag: s.c,
                isCustomElement: s.c,
                decodeEntities: (t) => t.replace(jo, (t, e) => Lo[e]),
                onError: Si,
                comments: !1,
            };
        function Ro(t, e = {}) {
            const n = (function (t, e) {
                    const n = Object(s.j)({}, Mo);
                    for (const t in e) n[t] = e[t] || Mo[t];
                    return {
                        options: n,
                        column: 1,
                        line: 1,
                        offset: 0,
                        originalSource: t,
                        source: t,
                        inPre: !1,
                        inVPre: !1,
                    };
                })(t, e),
                r = Xo(n);
            return (function (t, e = ro) {
                return {
                    type: 0,
                    children: t,
                    helpers: [],
                    components: [],
                    directives: [],
                    hoists: [],
                    imports: [],
                    cached: 0,
                    temps: 0,
                    codegenNode: void 0,
                    loc: e,
                };
            })(Do(n, 0, []), Yo(n, r));
        }
        function Do(t, e, n) {
            const r = Qo(n),
                i = r ? r.ns : 0,
                o = [];
            for (; !sa(t, e, n); ) {
                const a = t.source;
                let c = void 0;
                if (0 === e || 1 === e)
                    if (!t.inVPre && Zo(a, t.options.delimiters[0]))
                        c = Go(t, e);
                    else if (0 === e && "<" === a[0])
                        if (1 === a.length) ra(t, 5, 1);
                        else if ("!" === a[1])
                            Zo(a, "\x3c!--")
                                ? (c = Uo(t))
                                : Zo(a, "<!DOCTYPE")
                                ? (c = Vo(t))
                                : Zo(a, "<![CDATA[")
                                ? 0 !== i
                                    ? (c = Bo(t, n))
                                    : (ra(t, 1), (c = Vo(t)))
                                : (ra(t, 11), (c = Vo(t)));
                        else if ("/" === a[1])
                            if (2 === a.length) ra(t, 5, 2);
                            else {
                                if (">" === a[2]) {
                                    ra(t, 14, 2), ta(t, 3);
                                    continue;
                                }
                                if (/[a-z]/i.test(a[2])) {
                                    ra(t, 23), zo(t, 1, r);
                                    continue;
                                }
                                ra(t, 12, 2), (c = Vo(t));
                            }
                        else
                            /[a-z]/i.test(a[1])
                                ? (c = qo(t, n))
                                : "?" === a[1]
                                ? (ra(t, 21, 1), (c = Vo(t)))
                                : ra(t, 12, 1);
                if ((c || (c = Ko(t, e)), Object(s.p)(c)))
                    for (let t = 0; t < c.length; t++) Fo(o, c[t]);
                else Fo(o, c);
            }
            let a = !1;
            if (2 !== e)
                if (t.inPre) {
                    if (r && t.options.isPreTag(r.tag)) {
                        const t = o[0];
                        t &&
                            2 === t.type &&
                            (t.content = t.content.replace(/^\r?\n/, ""));
                    }
                } else
                    for (let e = 0; e < o.length; e++) {
                        const n = o[e];
                        if (2 === n.type)
                            if (/[^\t\r\n\f ]/.test(n.content))
                                n.content = n.content.replace(
                                    /[\t\r\n\f ]+/g,
                                    " "
                                );
                            else {
                                const t = o[e - 1],
                                    r = o[e + 1];
                                !t ||
                                !r ||
                                3 === t.type ||
                                3 === r.type ||
                                (1 === t.type &&
                                    1 === r.type &&
                                    /[\r\n]/.test(n.content))
                                    ? ((a = !0), (o[e] = null))
                                    : (n.content = " ");
                            }
                        else
                            3 !== n.type ||
                                t.options.comments ||
                                ((a = !0), (o[e] = null));
                    }
            return a ? o.filter(Boolean) : o;
        }
        function Fo(t, e) {
            if (2 === e.type) {
                const n = Qo(t);
                if (
                    n &&
                    2 === n.type &&
                    n.loc.end.offset === e.loc.start.offset
                )
                    return (
                        (n.content += e.content),
                        (n.loc.end = e.loc.end),
                        void (n.loc.source += e.loc.source)
                    );
            }
            t.push(e);
        }
        function Bo(t, e) {
            ta(t, 9);
            const n = Do(t, 3, e);
            return 0 === t.source.length ? ra(t, 6) : ta(t, 3), n;
        }
        function Uo(t) {
            const e = Xo(t);
            let n;
            const r = /--(\!)?>/.exec(t.source);
            if (r) {
                r.index <= 3 && ra(t, 0),
                    r[1] && ra(t, 10),
                    (n = t.source.slice(4, r.index));
                const e = t.source.slice(0, r.index);
                let s = 1,
                    i = 0;
                for (; -1 !== (i = e.indexOf("\x3c!--", s)); )
                    ta(t, i - s + 1),
                        i + 4 < e.length && ra(t, 16),
                        (s = i + 1);
                ta(t, r.index + r[0].length - s + 1);
            } else (n = t.source.slice(4)), ta(t, t.source.length), ra(t, 7);
            return { type: 3, content: n, loc: Yo(t, e) };
        }
        function Vo(t) {
            const e = Xo(t),
                n = "?" === t.source[1] ? 1 : 2;
            let r;
            const s = t.source.indexOf(">");
            return (
                -1 === s
                    ? ((r = t.source.slice(n)), ta(t, t.source.length))
                    : ((r = t.source.slice(n, s)), ta(t, s + 1)),
                { type: 3, content: r, loc: Yo(t, e) }
            );
        }
        function qo(t, e) {
            const n = t.inPre,
                r = t.inVPre,
                s = Qo(e),
                i = zo(t, 0, s),
                o = t.inPre && !n,
                a = t.inVPre && !r;
            if (i.isSelfClosing || t.options.isVoidTag(i.tag)) return i;
            e.push(i);
            const c = t.options.getTextMode(i, s),
                l = Do(t, c, e);
            if ((e.pop(), (i.children = l), ia(t.source, i.tag))) zo(t, 1, s);
            else if (
                (ra(t, 24, 0, i.loc.start),
                0 === t.source.length && "script" === i.tag.toLowerCase())
            ) {
                const e = l[0];
                e && Zo(e.loc.source, "\x3c!--") && ra(t, 8);
            }
            return (
                (i.loc = Yo(t, i.loc.start)),
                o && (t.inPre = !1),
                a && (t.inVPre = !1),
                i
            );
        }
        const $o = Object(s.G)("if,else,else-if,for,slot");
        function zo(t, e, n) {
            const r = Xo(t),
                i = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(t.source),
                o = i[1],
                a = t.options.getNamespace(o, n);
            ta(t, i[0].length), ea(t);
            const c = Xo(t),
                l = t.source;
            let u = Ho(t, e);
            t.options.isPreTag(o) && (t.inPre = !0),
                !t.inVPre &&
                    u.some((t) => 7 === t.type && "pre" === t.name) &&
                    ((t.inVPre = !0),
                    Object(s.j)(t, c),
                    (t.source = l),
                    (u = Ho(t, e).filter((t) => "v-pre" !== t.name)));
            let h = !1;
            0 === t.source.length
                ? ra(t, 9)
                : ((h = Zo(t.source, "/>")),
                  1 === e && h && ra(t, 4),
                  ta(t, h ? 2 : 1));
            let p = 0;
            const d = t.options;
            if (!t.inVPre && !d.isCustomElement(o)) {
                const t = u.some((t) => 7 === t.type && "is" === t.name);
                d.isNativeTag && !t
                    ? d.isNativeTag(o) || (p = 1)
                    : (t ||
                          yo(o) ||
                          (d.isBuiltInComponent && d.isBuiltInComponent(o)) ||
                          /^[A-Z]/.test(o) ||
                          "component" === o) &&
                      (p = 1),
                    "slot" === o
                        ? (p = 2)
                        : "template" === o &&
                          u.some((t) => 7 === t.type && $o(t.name)) &&
                          (p = 3);
            }
            return {
                type: 1,
                ns: a,
                tag: o,
                tagType: p,
                props: u,
                isSelfClosing: h,
                children: [],
                loc: Yo(t, r),
                codegenNode: void 0,
            };
        }
        function Ho(t, e) {
            const n = [],
                r = new Set();
            for (
                ;
                t.source.length > 0 &&
                !Zo(t.source, ">") &&
                !Zo(t.source, "/>");

            ) {
                if (Zo(t.source, "/")) {
                    ra(t, 22), ta(t, 1), ea(t);
                    continue;
                }
                1 === e && ra(t, 3);
                const s = Wo(t, r);
                0 === e && n.push(s),
                    /^[^\t\r\n\f />]/.test(t.source) && ra(t, 15),
                    ea(t);
            }
            return n;
        }
        function Wo(t, e) {
            const n = Xo(t),
                r = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(t.source)[0];
            e.has(r) && ra(t, 2), e.add(r), "=" === r[0] && ra(t, 19);
            {
                const e = /["'<]/g;
                let n;
                for (; (n = e.exec(r)); ) ra(t, 17, n.index);
            }
            ta(t, r.length);
            let s = void 0;
            /^[\t\r\n\f ]*=/.test(t.source) &&
                (ea(t),
                ta(t, 1),
                ea(t),
                (s = (function (t) {
                    const e = Xo(t);
                    let n;
                    const r = t.source[0],
                        s = '"' === r || "'" === r;
                    if (s) {
                        ta(t, 1);
                        const e = t.source.indexOf(r);
                        -1 === e
                            ? (n = Jo(t, t.source.length, 4))
                            : ((n = Jo(t, e, 4)), ta(t, 1));
                    } else {
                        const e = /^[^\t\r\n\f >]+/.exec(t.source);
                        if (!e) return;
                        const r = /["'<=`]/g;
                        let s;
                        for (; (s = r.exec(e[0])); ) ra(t, 18, s.index);
                        n = Jo(t, e[0].length, 4);
                    }
                    return { content: n, isQuoted: s, loc: Yo(t, e) };
                })(t)),
                s || ra(t, 13));
            const i = Yo(t, n);
            if (!t.inVPre && /^(v-|:|@|#)/.test(r)) {
                const e =
                        /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(
                            r
                        ),
                    o =
                        e[1] ||
                        (Zo(r, ":") ? "bind" : Zo(r, "@") ? "on" : "slot");
                let a;
                if (e[2]) {
                    const s = "slot" === o,
                        i = r.indexOf(e[2]),
                        c = Yo(
                            t,
                            na(t, n, i),
                            na(
                                t,
                                n,
                                i + e[2].length + ((s && e[3]) || "").length
                            )
                        );
                    let l = e[2],
                        u = !0;
                    l.startsWith("[")
                        ? ((u = !1),
                          l.endsWith("]") || ra(t, 26),
                          (l = l.substr(1, l.length - 2)))
                        : s && (l += e[3] || ""),
                        (a = {
                            type: 4,
                            content: l,
                            isStatic: u,
                            isConstant: u,
                            loc: c,
                        });
                }
                if (s && s.isQuoted) {
                    const t = s.loc;
                    t.start.offset++,
                        t.start.column++,
                        (t.end = Po(t.start, s.content)),
                        (t.source = t.source.slice(1, -1));
                }
                return {
                    type: 7,
                    name: o,
                    exp: s && {
                        type: 4,
                        content: s.content,
                        isStatic: !1,
                        isConstant: !1,
                        loc: s.loc,
                    },
                    arg: a,
                    modifiers: e[3] ? e[3].substr(1).split(".") : [],
                    loc: i,
                };
            }
            return {
                type: 6,
                name: r,
                value: s && { type: 2, content: s.content, loc: s.loc },
                loc: i,
            };
        }
        function Go(t, e) {
            const [n, r] = t.options.delimiters,
                s = t.source.indexOf(r, n.length);
            if (-1 === s) return void ra(t, 25);
            const i = Xo(t);
            ta(t, n.length);
            const o = Xo(t),
                a = Xo(t),
                c = s - n.length,
                l = t.source.slice(0, c),
                u = Jo(t, c, e),
                h = u.trim(),
                p = u.indexOf(h);
            p > 0 && Ao(o, l, p);
            return (
                Ao(a, l, c - (u.length - h.length - p)),
                ta(t, r.length),
                {
                    type: 5,
                    content: {
                        type: 4,
                        isStatic: !1,
                        isConstant: !1,
                        content: h,
                        loc: Yo(t, o, a),
                    },
                    loc: Yo(t, i),
                }
            );
        }
        function Ko(t, e) {
            const n = ["<", t.options.delimiters[0]];
            3 === e && n.push("]]>");
            let r = t.source.length;
            for (let e = 0; e < n.length; e++) {
                const s = t.source.indexOf(n[e], 1);
                -1 !== s && r > s && (r = s);
            }
            const s = Xo(t);
            return { type: 2, content: Jo(t, r, e), loc: Yo(t, s) };
        }
        function Jo(t, e, n) {
            const r = t.source.slice(0, e);
            return (
                ta(t, e),
                2 === n || 3 === n || -1 === r.indexOf("&")
                    ? r
                    : t.options.decodeEntities(r, 4 === n)
            );
        }
        function Xo(t) {
            const { column: e, line: n, offset: r } = t;
            return { column: e, line: n, offset: r };
        }
        function Yo(t, e, n) {
            return {
                start: e,
                end: (n = n || Xo(t)),
                source: t.originalSource.slice(e.offset, n.offset),
            };
        }
        function Qo(t) {
            return t[t.length - 1];
        }
        function Zo(t, e) {
            return t.startsWith(e);
        }
        function ta(t, e) {
            const { source: n } = t;
            Ao(t, n, e), (t.source = n.slice(e));
        }
        function ea(t) {
            const e = /^[\t\r\n\f ]+/.exec(t.source);
            e && ta(t, e[0].length);
        }
        function na(t, e, n) {
            return Po(e, t.originalSource.slice(e.offset, n), n);
        }
        function ra(t, e, n, r = Xo(t)) {
            n && ((r.offset += n), (r.column += n)),
                t.options.onError(Ci(e, { start: r, end: r, source: "" }));
        }
        function sa(t, e, n) {
            const r = t.source;
            switch (e) {
                case 0:
                    if (Zo(r, "</"))
                        for (let t = n.length - 1; t >= 0; --t)
                            if (ia(r, n[t].tag)) return !0;
                    break;
                case 1:
                case 2: {
                    const t = Qo(n);
                    if (t && ia(r, t.tag)) return !0;
                    break;
                }
                case 3:
                    if (Zo(r, "]]>")) return !0;
            }
            return !r;
        }
        function ia(t, e) {
            return (
                Zo(t, "</") &&
                t.substr(2, e.length).toLowerCase() === e.toLowerCase() &&
                /[\t\r\n\f />]/.test(t[2 + e.length] || ">")
            );
        }
        function oa(t, e) {
            !(function t(e, n, r, s = !1) {
                let i = !1,
                    o = !1;
                const { children: a } = e;
                for (let e = 0; e < a.length; e++) {
                    const c = a[e];
                    if (1 === c.type && 0 === c.tagType) {
                        let t;
                        if (!s && (t = ca(c, r)) > 0) {
                            2 === t && (o = !0),
                                (c.codegenNode.patchFlag = "-1"),
                                (c.codegenNode = n.hoist(c.codegenNode)),
                                (i = !0);
                            continue;
                        }
                        {
                            const t = c.codegenNode;
                            if (13 === t.type) {
                                const e = ha(t);
                                if (!((e && 512 !== e && 1 !== e) || la(c))) {
                                    const e = ua(c);
                                    e && (t.props = n.hoist(e));
                                }
                            }
                        }
                    } else if (12 === c.type) {
                        const t = ca(c.content, r);
                        t > 0 &&
                            (2 === t && (o = !0),
                            (c.codegenNode = n.hoist(c.codegenNode)),
                            (i = !0));
                    }
                    if (1 === c.type) t(c, n, r);
                    else if (11 === c.type) t(c, n, r, 1 === c.children.length);
                    else if (9 === c.type)
                        for (let e = 0; e < c.branches.length; e++)
                            t(
                                c.branches[e],
                                n,
                                r,
                                1 === c.branches[e].children.length
                            );
                }
                !o && i && n.transformHoist && n.transformHoist(a, n, e);
            })(t, e, new Map(), aa(t, t.children[0]));
        }
        function aa(t, e) {
            const { children: n } = t;
            return 1 === n.length && 1 === e.type && !_o(e);
        }
        function ca(t, e = new Map()) {
            switch (t.type) {
                case 1:
                    if (0 !== t.tagType) return 0;
                    const n = e.get(t);
                    if (void 0 !== n) return n;
                    const r = t.codegenNode;
                    if (13 !== r.type) return 0;
                    if (ha(r) || la(t)) return e.set(t, 0), 0;
                    {
                        let n = 1;
                        for (let r = 0; r < t.children.length; r++) {
                            const s = ca(t.children[r], e);
                            if (0 === s) return e.set(t, 0), 0;
                            2 === s && (n = 2);
                        }
                        if (2 !== n)
                            for (let e = 0; e < t.props.length; e++) {
                                const r = t.props[e];
                                7 === r.type &&
                                    "bind" === r.name &&
                                    r.exp &&
                                    (8 === r.exp.type ||
                                        r.exp.isRuntimeConstant) &&
                                    (n = 2);
                            }
                        return r.isBlock && (r.isBlock = !1), e.set(t, n), n;
                    }
                case 2:
                case 3:
                    return 1;
                case 9:
                case 11:
                case 10:
                    return 0;
                case 5:
                case 12:
                    return ca(t.content, e);
                case 4:
                    return t.isConstant ? (t.isRuntimeConstant ? 2 : 1) : 0;
                case 8:
                    let i = 1;
                    for (let n = 0; n < t.children.length; n++) {
                        const r = t.children[n];
                        if (Object(s.B)(r) || Object(s.C)(r)) continue;
                        const o = ca(r, e);
                        if (0 === o) return 0;
                        2 === o && (i = 2);
                    }
                    return i;
                default:
                    return 0;
            }
        }
        function la(t) {
            const e = ua(t);
            if (e && 15 === e.type) {
                const { properties: t } = e;
                for (let e = 0; e < t.length; e++) {
                    const { key: n, value: r } = t[e];
                    if (
                        4 !== n.type ||
                        !n.isStatic ||
                        4 !== r.type ||
                        (!r.isStatic && !r.isConstant)
                    )
                        return !0;
                }
            }
            return !1;
        }
        function ua(t) {
            const e = t.codegenNode;
            if (13 === e.type) return e.props;
        }
        function ha(t) {
            const e = t.patchFlag;
            return e ? parseInt(e, 10) : void 0;
        }
        function pa(
            t,
            {
                prefixIdentifiers: e = !1,
                hoistStatic: n = !1,
                cacheHandlers: r = !1,
                nodeTransforms: i = [],
                directiveTransforms: o = {},
                transformHoist: a = null,
                isBuiltInComponent: c = s.d,
                isCustomElement: l = s.d,
                expressionPlugins: u = [],
                scopeId: h = null,
                ssr: p = !1,
                ssrCssVars: d = "",
                bindingMetadata: f = {},
                onError: m = Si,
            }
        ) {
            const y = {
                prefixIdentifiers: e,
                hoistStatic: n,
                cacheHandlers: r,
                nodeTransforms: i,
                directiveTransforms: o,
                transformHoist: a,
                isBuiltInComponent: c,
                isCustomElement: l,
                expressionPlugins: u,
                scopeId: h,
                ssr: p,
                ssrCssVars: d,
                bindingMetadata: f,
                onError: m,
                root: t,
                helpers: new Set(),
                components: new Set(),
                directives: new Set(),
                hoists: [],
                imports: new Set(),
                temps: 0,
                cached: 0,
                identifiers: Object.create(null),
                scopes: { vFor: 0, vSlot: 0, vPre: 0, vOnce: 0 },
                parent: null,
                currentNode: t,
                childIndex: 0,
                helper: (t) => (y.helpers.add(t), t),
                helperString: (t) => "_" + no[y.helper(t)],
                replaceNode(t) {
                    y.parent.children[y.childIndex] = y.currentNode = t;
                },
                removeNode(t) {
                    const e = y.parent.children,
                        n = t
                            ? e.indexOf(t)
                            : y.currentNode
                            ? y.childIndex
                            : -1;
                    t && t !== y.currentNode
                        ? y.childIndex > n &&
                          (y.childIndex--, y.onNodeRemoved())
                        : ((y.currentNode = null), y.onNodeRemoved()),
                        y.parent.children.splice(n, 1);
                },
                onNodeRemoved: () => {},
                addIdentifiers(t) {},
                removeIdentifiers(t) {},
                hoist(t) {
                    y.hoists.push(t);
                    const e = co("_hoisted_" + y.hoists.length, !1, t.loc, !0);
                    return (e.hoisted = t), e;
                },
                cache: (t, e = !1) =>
                    (function (t, e, n = !1) {
                        return {
                            type: 20,
                            index: t,
                            value: e,
                            isVNode: n,
                            loc: ro,
                        };
                    })(++y.cached, t, e),
            };
            return y;
        }
        function da(t, e) {
            const n = pa(t, e);
            fa(t, n),
                e.hoistStatic && oa(t, n),
                e.ssr ||
                    (function (t, e) {
                        const { helper: n } = e,
                            { children: r } = t,
                            i = r[0];
                        if (1 === r.length)
                            if (aa(t, i) && i.codegenNode) {
                                const e = i.codegenNode;
                                13 === e.type &&
                                    ((e.isBlock = !0), n(ji), n(Li)),
                                    (t.codegenNode = e);
                            } else t.codegenNode = i;
                        else
                            r.length > 1 &&
                                (t.codegenNode = so(
                                    e,
                                    n(Oi),
                                    void 0,
                                    t.children,
                                    `64 /* ${s.e[64]} */`,
                                    void 0,
                                    void 0,
                                    !0
                                ));
                    })(t, n),
                (t.helpers = [...n.helpers]),
                (t.components = [...n.components]),
                (t.directives = [...n.directives]),
                (t.imports = [...n.imports]),
                (t.hoists = n.hoists),
                (t.temps = n.temps),
                (t.cached = n.cached);
        }
        function fa(t, e) {
            e.currentNode = t;
            const { nodeTransforms: n } = e,
                r = [];
            for (let i = 0; i < n.length; i++) {
                const o = n[i](t, e);
                if (
                    (o && (Object(s.p)(o) ? r.push(...o) : r.push(o)),
                    !e.currentNode)
                )
                    return;
                t = e.currentNode;
            }
            switch (t.type) {
                case 3:
                    e.ssr || e.helper(Ri);
                    break;
                case 5:
                    e.ssr || e.helper(Wi);
                    break;
                case 9:
                    for (let n = 0; n < t.branches.length; n++)
                        fa(t.branches[n], e);
                    break;
                case 10:
                case 11:
                case 1:
                case 0:
                    !(function (t, e) {
                        let n = 0;
                        const r = () => {
                            n--;
                        };
                        for (; n < t.children.length; n++) {
                            const i = t.children[n];
                            Object(s.B)(i) ||
                                ((e.parent = t),
                                (e.childIndex = n),
                                (e.onNodeRemoved = r),
                                fa(i, e));
                        }
                    })(t, e);
            }
            let i = r.length;
            for (; i--; ) r[i]();
        }
        function ma(t, e) {
            const n = Object(s.B)(t) ? (e) => e === t : (e) => t.test(e);
            return (t, r) => {
                if (1 === t.type) {
                    const { props: s } = t;
                    if (3 === t.tagType && s.some(Oo)) return;
                    const i = [];
                    for (let o = 0; o < s.length; o++) {
                        const a = s[o];
                        if (7 === a.type && n(a.name)) {
                            s.splice(o, 1), o--;
                            const n = e(t, a, r);
                            n && i.push(n);
                        }
                    }
                    return i;
                }
            };
        }
        const ya = "/*#__PURE__*/";
        function ga(t, e = {}) {
            const n = (function (
                t,
                {
                    mode: e = "function",
                    prefixIdentifiers: n = "module" === e,
                    sourceMap: r = !1,
                    filename: s = "template.vue.html",
                    scopeId: i = null,
                    optimizeImports: o = !1,
                    runtimeGlobalName: a = "Vue",
                    runtimeModuleName: c = "vue",
                    ssr: l = !1,
                }
            ) {
                const u = {
                    mode: e,
                    prefixIdentifiers: n,
                    sourceMap: r,
                    filename: s,
                    scopeId: i,
                    optimizeImports: o,
                    runtimeGlobalName: a,
                    runtimeModuleName: c,
                    ssr: l,
                    source: t.loc.source,
                    code: "",
                    column: 1,
                    line: 1,
                    offset: 0,
                    indentLevel: 0,
                    pure: !1,
                    map: void 0,
                    helper: (t) => "_" + no[t],
                    push(t, e) {
                        u.code += t;
                    },
                    indent() {
                        h(++u.indentLevel);
                    },
                    deindent(t = !1) {
                        t ? --u.indentLevel : h(--u.indentLevel);
                    },
                    newline() {
                        h(u.indentLevel);
                    },
                };
                function h(t) {
                    u.push("\n" + "  ".repeat(t));
                }
                return u;
            })(t, e);
            e.onContextCreated && e.onContextCreated(n);
            const {
                    mode: r,
                    push: s,
                    prefixIdentifiers: i,
                    indent: o,
                    deindent: a,
                    newline: c,
                    scopeId: l,
                    ssr: u,
                } = n,
                h = t.helpers.length > 0,
                p = !i && "module" !== r;
            !(function (t, e) {
                const {
                        ssr: n,
                        prefixIdentifiers: r,
                        push: s,
                        newline: i,
                        runtimeModuleName: o,
                        runtimeGlobalName: a,
                    } = e,
                    c = a,
                    l = (t) => `${no[t]}: _${no[t]}`;
                if (
                    t.helpers.length > 0 &&
                    (s(`const _Vue = ${c}\n`), t.hoists.length)
                ) {
                    s(
                        `const { ${[Mi, Ri, Di, Fi]
                            .filter((e) => t.helpers.includes(e))
                            .map(l)
                            .join(", ")} } = _Vue\n`
                    );
                }
                (function (t, e) {
                    if (!t.length) return;
                    e.pure = !0;
                    const {
                        push: n,
                        newline: r,
                        helper: s,
                        scopeId: i,
                        mode: o,
                    } = e;
                    r(),
                        t.forEach((t, s) => {
                            t &&
                                (n(`const _hoisted_${s + 1} = `),
                                wa(t, e),
                                r());
                        }),
                        (e.pure = !1);
                })(t.hoists, e),
                    i(),
                    s("return ");
            })(t, n);
            const d = e.bindingMetadata
                ? ", $props, $setup, $data, $options"
                : "";
            if (
                (s(
                    u
                        ? `function ssrRender(_ctx, _push, _parent, _attrs${d}) {`
                        : `function render(_ctx, _cache${d}) {`
                ),
                o(),
                p &&
                    (s("with (_ctx) {"),
                    o(),
                    h &&
                        (s(
                            `const { ${t.helpers
                                .map((t) => `${no[t]}: _${no[t]}`)
                                .join(", ")} } = _Vue`
                        ),
                        s("\n"),
                        c())),
                t.components.length &&
                    (va(t.components, "component", n),
                    (t.directives.length || t.temps > 0) && c()),
                t.directives.length &&
                    (va(t.directives, "directive", n), t.temps > 0 && c()),
                t.temps > 0)
            ) {
                s("let ");
                for (let e = 0; e < t.temps; e++)
                    s(`${e > 0 ? ", " : ""}_temp${e}`);
            }
            return (
                (t.components.length || t.directives.length || t.temps) &&
                    (s("\n"), c()),
                u || s("return "),
                t.codegenNode ? wa(t.codegenNode, n) : s("null"),
                p && (a(), s("}")),
                a(),
                s("}"),
                { ast: t, code: n.code, map: n.map ? n.map.toJSON() : void 0 }
            );
        }
        function va(t, e, { helper: n, push: r, newline: s }) {
            const i = n("component" === e ? Bi : Vi);
            for (let n = 0; n < t.length; n++) {
                const o = t[n];
                r(`const ${Io(o, e)} = ${i}(${JSON.stringify(o)})`),
                    n < t.length - 1 && s();
            }
        }
        function ba(t, e) {
            const n = t.length > 3 || !1;
            e.push("["),
                n && e.indent(),
                xa(t, e, n),
                n && e.deindent(),
                e.push("]");
        }
        function xa(t, e, n = !1, r = !0) {
            const { push: i, newline: o } = e;
            for (let a = 0; a < t.length; a++) {
                const c = t[a];
                Object(s.B)(c) ? i(c) : Object(s.p)(c) ? ba(c, e) : wa(c, e),
                    a < t.length - 1 && (n ? (r && i(","), o()) : r && i(", "));
            }
        }
        function wa(t, e) {
            if (Object(s.B)(t)) e.push(t);
            else if (Object(s.C)(t)) e.push(e.helper(t));
            else
                switch (t.type) {
                    case 1:
                    case 9:
                    case 11:
                        wa(t.codegenNode, e);
                        break;
                    case 2:
                        !(function (t, e) {
                            e.push(JSON.stringify(t.content), t);
                        })(t, e);
                        break;
                    case 4:
                        Pa(t, e);
                        break;
                    case 5:
                        !(function (t, e) {
                            const { push: n, helper: r, pure: s } = e;
                            s && n(ya);
                            n(r(Wi) + "("), wa(t.content, e), n(")");
                        })(t, e);
                        break;
                    case 12:
                        wa(t.codegenNode, e);
                        break;
                    case 8:
                        Aa(t, e);
                        break;
                    case 3:
                        break;
                    case 13:
                        !(function (t, e) {
                            const { push: n, helper: r, pure: s } = e,
                                {
                                    tag: i,
                                    props: o,
                                    children: a,
                                    patchFlag: c,
                                    dynamicProps: l,
                                    directives: u,
                                    isBlock: h,
                                    disableTracking: p,
                                } = t;
                            u && n(r(qi) + "(");
                            h && n(`(${r(ji)}(${p ? "true" : ""}), `);
                            s && n(ya);
                            n(r(h ? Li : Mi) + "(", t),
                                xa(
                                    (function (t) {
                                        let e = t.length;
                                        for (; e-- && null == t[e]; );
                                        return t
                                            .slice(0, e + 1)
                                            .map((t) => t || "null");
                                    })([i, o, a, c, l]),
                                    e
                                ),
                                n(")"),
                                h && n(")");
                            u && (n(", "), wa(u, e), n(")"));
                        })(t, e);
                        break;
                    case 14:
                        !(function (t, e) {
                            const { push: n, helper: r, pure: i } = e,
                                o = Object(s.B)(t.callee)
                                    ? t.callee
                                    : r(t.callee);
                            i && n(ya);
                            n(o + "(", t), xa(t.arguments, e), n(")");
                        })(t, e);
                        break;
                    case 15:
                        !(function (t, e) {
                            const {
                                    push: n,
                                    indent: r,
                                    deindent: s,
                                    newline: i,
                                } = e,
                                { properties: o } = t;
                            if (!o.length) return void n("{}", t);
                            const a = o.length > 1 || !1;
                            n(a ? "{" : "{ "), a && r();
                            for (let t = 0; t < o.length; t++) {
                                const { key: r, value: s } = o[t];
                                Ea(r, e),
                                    n(": "),
                                    wa(s, e),
                                    t < o.length - 1 && (n(","), i());
                            }
                            a && s(), n(a ? "}" : " }");
                        })(t, e);
                        break;
                    case 17:
                        !(function (t, e) {
                            ba(t.elements, e);
                        })(t, e);
                        break;
                    case 18:
                        !(function (t, e) {
                            const {
                                    push: n,
                                    indent: r,
                                    deindent: i,
                                    scopeId: o,
                                    mode: a,
                                } = e,
                                {
                                    params: c,
                                    returns: l,
                                    body: u,
                                    newline: h,
                                    isSlot: p,
                                } = t;
                            p && n(`_${no[eo]}(`);
                            n("(", t),
                                Object(s.p)(c) ? xa(c, e) : c && wa(c, e);
                            n(") => "), (h || u) && (n("{"), r());
                            l
                                ? (h && n("return "),
                                  Object(s.p)(l) ? ba(l, e) : wa(l, e))
                                : u && wa(u, e);
                            (h || u) && (i(), n("}"));
                            p && n(")");
                        })(t, e);
                        break;
                    case 19:
                        !(function (t, e) {
                            const {
                                    test: n,
                                    consequent: r,
                                    alternate: s,
                                    newline: i,
                                } = t,
                                {
                                    push: o,
                                    indent: a,
                                    deindent: c,
                                    newline: l,
                                } = e;
                            if (4 === n.type) {
                                const t = !vo(n.content);
                                t && o("("), Pa(n, e), t && o(")");
                            } else o("("), wa(n, e), o(")");
                            i && a(),
                                e.indentLevel++,
                                i || o(" "),
                                o("? "),
                                wa(r, e),
                                e.indentLevel--,
                                i && l(),
                                i || o(" "),
                                o(": ");
                            const u = 19 === s.type;
                            u || e.indentLevel++;
                            wa(s, e), u || e.indentLevel--;
                            i && c(!0);
                        })(t, e);
                        break;
                    case 20:
                        !(function (t, e) {
                            const {
                                push: n,
                                helper: r,
                                indent: s,
                                deindent: i,
                                newline: o,
                            } = e;
                            n(`_cache[${t.index}] || (`),
                                t.isVNode && (s(), n(r(Yi) + "(-1),"), o());
                            n(`_cache[${t.index}] = `),
                                wa(t.value, e),
                                t.isVNode &&
                                    (n(","),
                                    o(),
                                    n(r(Yi) + "(1),"),
                                    o(),
                                    n(`_cache[${t.index}]`),
                                    i());
                            n(")");
                        })(t, e);
                        break;
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 10:
                        break;
                    default:
                        0;
                }
        }
        function Pa(t, e) {
            const { content: n, isStatic: r } = t;
            e.push(r ? JSON.stringify(n) : n, t);
        }
        function Aa(t, e) {
            for (let n = 0; n < t.children.length; n++) {
                const r = t.children[n];
                Object(s.B)(r) ? e.push(r) : wa(r, e);
            }
        }
        function Ea(t, e) {
            const { push: n } = e;
            if (8 === t.type) n("["), Aa(t, e), n("]");
            else if (t.isStatic) {
                n(vo(t.content) ? t.content : JSON.stringify(t.content), t);
            } else n(`[${t.content}]`, t);
        }
        new RegExp(
            "\\b" +
                "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments,typeof,void"
                    .split(",")
                    .join("\\b|\\b") +
                "\\b"
        );
        const Ta = ma(/^(if|else|else-if)$/, (t, e, n) =>
            (function (t, e, n, r) {
                if (!("else" === e.name || (e.exp && e.exp.content.trim()))) {
                    const r = e.exp ? e.exp.loc : t.loc;
                    n.onError(Ci(27, e.loc)), (e.exp = co("true", !1, r));
                }
                0;
                if ("if" === e.name) {
                    const s = Sa(t, e),
                        i = { type: 9, loc: t.loc, branches: [s] };
                    if ((n.replaceNode(i), r)) return r(i, s, !0);
                } else {
                    const s = n.parent.children;
                    let i = s.indexOf(t);
                    for (; i-- >= -1; ) {
                        const o = s[i];
                        if (o && 9 === o.type) {
                            n.removeNode();
                            const s = Sa(t, e);
                            0, o.branches.push(s);
                            const i = r && r(o, s, !1);
                            fa(s, n), i && i(), (n.currentNode = null);
                        } else n.onError(Ci(29, t.loc));
                        break;
                    }
                }
            })(t, e, n, (t, e, r) => {
                const s = n.parent.children;
                let i = s.indexOf(t),
                    o = 0;
                for (; i-- >= 0; ) {
                    const t = s[i];
                    t && 9 === t.type && (o += t.branches.length);
                }
                return () => {
                    if (r) t.codegenNode = Ca(e, o, n);
                    else {
                        let r = t.codegenNode;
                        for (; 19 === r.alternate.type; ) r = r.alternate;
                        r.alternate = Ca(e, o + t.branches.length - 1, n);
                    }
                };
            })
        );
        function Sa(t, e) {
            return {
                type: 10,
                loc: t.loc,
                condition: "else" === e.name ? void 0 : e.exp,
                children: 3 !== t.tagType || Eo(t, "for") ? [t] : t.children,
                userKey: To(t, "key"),
            };
        }
        function Ca(t, e, n) {
            return t.condition
                ? po(t.condition, Oa(t, e, n), uo(n.helper(Ri), ['""', "true"]))
                : Oa(t, e, n);
        }
        function Oa(t, e, n) {
            const { helper: r } = n,
                i = ao("key", co("" + e, !1, ro, !0)),
                { children: o } = t,
                a = o[0];
            if (1 !== o.length || 1 !== a.type) {
                if (1 === o.length && 11 === a.type) {
                    const t = a.codegenNode;
                    return No(t, i, n), t;
                }
                return so(
                    n,
                    r(Oi),
                    oo([i]),
                    o,
                    `64 /* ${s.e[64]} */`,
                    void 0,
                    void 0,
                    !0,
                    !1,
                    t.loc
                );
            }
            {
                const t = a.codegenNode;
                return (
                    13 !== t.type ||
                        (1 === a.tagType && t.tag !== ki) ||
                        ((t.isBlock = !0), r(ji), r(Li)),
                    No(t, i, n),
                    t
                );
            }
        }
        const ka = ma("for", (t, e, n) => {
            const { helper: r } = n;
            return (function (t, e, n, r) {
                if (!e.exp) return void n.onError(Ci(30, e.loc));
                const s = ja(e.exp, n);
                if (!s) return void n.onError(Ci(31, e.loc));
                const {
                        addIdentifiers: i,
                        removeIdentifiers: o,
                        scopes: a,
                    } = n,
                    { source: c, value: l, key: u, index: h } = s,
                    p = {
                        type: 11,
                        loc: e.loc,
                        source: c,
                        valueAlias: l,
                        keyAlias: u,
                        objectIndexAlias: h,
                        parseResult: s,
                        children: ko(t) ? t.children : [t],
                    };
                n.replaceNode(p), a.vFor++;
                const d = r && r(p);
                return () => {
                    a.vFor--, d && d();
                };
            })(t, e, n, (e) => {
                const i = uo(r($i), [e.source]),
                    o = To(t, "key"),
                    a = 4 === e.source.type && e.source.isConstant,
                    c = a ? 64 : o ? 128 : 256;
                return (
                    (e.codegenNode = so(
                        n,
                        r(Oi),
                        void 0,
                        i,
                        `${c} /* ${s.e[c]} */`,
                        void 0,
                        void 0,
                        !0,
                        !a,
                        t.loc
                    )),
                    () => {
                        let c;
                        const l = ko(t),
                            { children: u } = e;
                        const h = 1 !== u.length || 1 !== u[0].type,
                            p = _o(t)
                                ? t
                                : l &&
                                  1 === t.children.length &&
                                  _o(t.children[0])
                                ? t.children[0]
                                : null,
                            d = o
                                ? ao(
                                      "key",
                                      6 === o.type
                                          ? co(o.value.content, !0)
                                          : o.exp
                                  )
                                : null;
                        p
                            ? ((c = p.codegenNode), l && d && No(c, d, n))
                            : h
                            ? (c = so(
                                  n,
                                  r(Oi),
                                  d ? oo([d]) : void 0,
                                  t.children,
                                  `64 /* ${s.e[64]} */`,
                                  void 0,
                                  void 0,
                                  !0
                              ))
                            : ((c = u[0].codegenNode),
                              l && d && No(c, d, n),
                              (c.isBlock = !a),
                              c.isBlock && (r(ji), r(Li))),
                            i.arguments.push(ho(Ma(e.parseResult), c, !0));
                    }
                );
            });
        });
        const _a = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,
            Na = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/,
            Ia = /^\(|\)$/g;
        function ja(t, e) {
            const n = t.loc,
                r = t.content,
                s = r.match(_a);
            if (!s) return;
            const [, i, o] = s,
                a = {
                    source: La(n, o.trim(), r.indexOf(o, i.length)),
                    value: void 0,
                    key: void 0,
                    index: void 0,
                };
            let c = i.trim().replace(Ia, "").trim();
            const l = i.indexOf(c),
                u = c.match(Na);
            if (u) {
                c = c.replace(Na, "").trim();
                const t = u[1].trim();
                let e;
                if (
                    (t &&
                        ((e = r.indexOf(t, l + c.length)),
                        (a.key = La(n, t, e))),
                    u[2])
                ) {
                    const s = u[2].trim();
                    s &&
                        (a.index = La(
                            n,
                            s,
                            r.indexOf(s, a.key ? e + t.length : l + c.length)
                        ));
                }
            }
            return c && (a.value = La(n, c, l)), a;
        }
        function La(t, e, n) {
            return co(e, !1, wo(t, n, e.length));
        }
        function Ma({ value: t, key: e, index: n }) {
            const r = [];
            return (
                t && r.push(t),
                e && (t || r.push(co("_", !1)), r.push(e)),
                n &&
                    (e || (t || r.push(co("_", !1)), r.push(co("__", !1))),
                    r.push(n)),
                r
            );
        }
        const Ra = co("undefined", !1),
            Da = (t, e) => {
                if (1 === t.type && (1 === t.tagType || 3 === t.tagType)) {
                    const n = Eo(t, "slot");
                    if (n) {
                        n.exp;
                        return (
                            e.scopes.vSlot++,
                            () => {
                                e.scopes.vSlot--;
                            }
                        );
                    }
                }
            },
            Fa = (t, e, n) => ho(t, e, !1, !0, e.length ? e[0].loc : n);
        function Ba(t, e, n = Fa) {
            e.helper(eo);
            const { children: r, loc: s } = t,
                i = [],
                o = [],
                a = (t, e) => ao("default", n(t, e, s));
            let c = e.scopes.vSlot > 0 || e.scopes.vFor > 0;
            const l = Eo(t, "slot", !0);
            if (l) {
                const { arg: t, exp: e } = l;
                t && !fo(t) && (c = !0),
                    i.push(ao(t || co("default", !0), n(e, r, s)));
            }
            let u = !1,
                h = !1;
            const p = [],
                d = new Set();
            for (let t = 0; t < r.length; t++) {
                const s = r[t];
                let a;
                if (!ko(s) || !(a = Eo(s, "slot", !0))) {
                    3 !== s.type && p.push(s);
                    continue;
                }
                if (l) {
                    e.onError(Ci(36, a.loc));
                    break;
                }
                u = !0;
                const { children: f, loc: m } = s,
                    { arg: y = co("default", !0), exp: g, loc: v } = a;
                let b;
                fo(y) ? (b = y ? y.content : "default") : (c = !0);
                const x = n(g, f, m);
                let w, P, A;
                if ((w = Eo(s, "if")))
                    (c = !0), o.push(po(w.exp, Ua(y, x), Ra));
                else if ((P = Eo(s, /^else(-if)?$/, !0))) {
                    let n,
                        s = t;
                    for (; s-- && ((n = r[s]), 3 === n.type); );
                    if (n && ko(n) && Eo(n, "if")) {
                        r.splice(t, 1), t--;
                        let e = o[o.length - 1];
                        for (; 19 === e.alternate.type; ) e = e.alternate;
                        e.alternate = P.exp
                            ? po(P.exp, Ua(y, x), Ra)
                            : Ua(y, x);
                    } else e.onError(Ci(29, P.loc));
                } else if ((A = Eo(s, "for"))) {
                    c = !0;
                    const t = A.parseResult || ja(A.exp);
                    t
                        ? o.push(
                              uo(e.helper($i), [
                                  t.source,
                                  ho(Ma(t), Ua(y, x), !0),
                              ])
                          )
                        : e.onError(Ci(31, A.loc));
                } else {
                    if (b) {
                        if (d.has(b)) {
                            e.onError(Ci(37, v));
                            continue;
                        }
                        d.add(b), "default" === b && (h = !0);
                    }
                    i.push(ao(y, x));
                }
            }
            l ||
                (u
                    ? p.length &&
                      (h ? e.onError(Ci(38, p[0].loc)) : i.push(a(void 0, p)))
                    : i.push(a(void 0, r)));
            const f = c
                ? 2
                : (function t(e) {
                      for (let n = 0; n < e.length; n++) {
                          const r = e[n];
                          if (
                              1 === r.type &&
                              (2 === r.tagType ||
                                  (0 === r.tagType && t(r.children)))
                          )
                              return !0;
                      }
                      return !1;
                  })(t.children)
                ? 3
                : 1;
            let m = oo(i.concat(ao("_", co("" + f, !1))), s);
            return (
                o.length && (m = uo(e.helper(Hi), [m, io(o)])),
                { slots: m, hasDynamicSlots: c }
            );
        }
        function Ua(t, e) {
            return oo([ao("name", t), ao("fn", e)]);
        }
        const Va = new WeakMap(),
            qa = (t, e) => {
                if (1 === t.type && (0 === t.tagType || 1 === t.tagType))
                    return function () {
                        const { tag: n, props: r } = t,
                            i = 1 === t.tagType,
                            o = i
                                ? (function (t, e, n = !1) {
                                      const { tag: r } = t,
                                          s =
                                              "component" === t.tag
                                                  ? To(t, "is")
                                                  : Eo(t, "is");
                                      if (s) {
                                          const t =
                                              6 === s.type
                                                  ? s.value &&
                                                    co(s.value.content, !0)
                                                  : s.exp;
                                          if (t) return uo(e.helper(Ui), [t]);
                                      }
                                      const i =
                                          yo(r) || e.isBuiltInComponent(r);
                                      if (i) return n || e.helper(i), i;
                                      if ("setup" === e.bindingMetadata[r])
                                          return `$setup[${JSON.stringify(r)}]`;
                                      return (
                                          e.helper(Bi),
                                          e.components.add(r),
                                          Io(r, "component")
                                      );
                                  })(t, e)
                                : `"${n}"`;
                        let a,
                            c,
                            l,
                            u,
                            h,
                            p,
                            d = 0,
                            f =
                                (Object(s.v)(o) && o.callee === Ui) ||
                                o === ki ||
                                o === _i ||
                                (!i &&
                                    ("svg" === n ||
                                        "foreignObject" === n ||
                                        To(t, "key", !0)));
                        if (r.length > 0) {
                            const n = $a(t, e);
                            (a = n.props),
                                (d = n.patchFlag),
                                (h = n.dynamicPropNames);
                            const r = n.directives;
                            p =
                                r && r.length
                                    ? io(
                                          r.map((t) =>
                                              (function (t, e) {
                                                  const n = [],
                                                      r = Va.get(t);
                                                  r
                                                      ? n.push(
                                                            e.helperString(r)
                                                        )
                                                      : (e.helper(Vi),
                                                        e.directives.add(
                                                            t.name
                                                        ),
                                                        n.push(
                                                            Io(
                                                                t.name,
                                                                "directive"
                                                            )
                                                        ));
                                                  const { loc: s } = t;
                                                  t.exp && n.push(t.exp);
                                                  t.arg &&
                                                      (t.exp ||
                                                          n.push("void 0"),
                                                      n.push(t.arg));
                                                  if (
                                                      Object.keys(t.modifiers)
                                                          .length
                                                  ) {
                                                      t.arg ||
                                                          (t.exp ||
                                                              n.push("void 0"),
                                                          n.push("void 0"));
                                                      const e = co(
                                                          "true",
                                                          !1,
                                                          s
                                                      );
                                                      n.push(
                                                          oo(
                                                              t.modifiers.map(
                                                                  (t) =>
                                                                      ao(t, e)
                                                              ),
                                                              s
                                                          )
                                                      );
                                                  }
                                                  return io(n, t.loc);
                                              })(t, e)
                                          )
                                      )
                                    : void 0;
                        }
                        if (t.children.length > 0) {
                            o === Ni && ((f = !0), (d |= 1024));
                            if (i && o !== ki && o !== Ni) {
                                const { slots: n, hasDynamicSlots: r } = Ba(
                                    t,
                                    e
                                );
                                (c = n), r && (d |= 1024);
                            } else if (1 === t.children.length && o !== ki) {
                                const e = t.children[0],
                                    n = e.type,
                                    r = 5 === n || 8 === n;
                                r && !ca(e) && (d |= 1),
                                    (c = r || 2 === n ? e : t.children);
                            } else c = t.children;
                        }
                        0 !== d &&
                            ((l = String(d)),
                            h &&
                                h.length &&
                                (u = (function (t) {
                                    let e = "[";
                                    for (let n = 0, r = t.length; n < r; n++)
                                        (e += JSON.stringify(t[n])),
                                            n < r - 1 && (e += ", ");
                                    return e + "]";
                                })(h))),
                            (t.codegenNode = so(
                                e,
                                o,
                                a,
                                c,
                                l,
                                u,
                                p,
                                !!f,
                                !1,
                                t.loc
                            ));
                    };
            };
        function $a(t, e, n = t.props, r = !1) {
            const { tag: i, loc: o } = t,
                a = 1 === t.tagType;
            let c = [];
            const l = [],
                u = [];
            let h = 0,
                p = !1,
                d = !1,
                f = !1,
                m = !1,
                y = !1,
                g = !1;
            const v = [],
                b = ({ key: t, value: e }) => {
                    if (fo(t)) {
                        const n = t.content,
                            r = Object(s.w)(n);
                        if (
                            (a ||
                                !r ||
                                "onclick" === n.toLowerCase() ||
                                "onUpdate:modelValue" === n ||
                                Object(s.y)(n) ||
                                (m = !0),
                            r && Object(s.y)(n) && (g = !0),
                            20 === e.type ||
                                ((4 === e.type || 8 === e.type) && ca(e) > 0))
                        )
                            return;
                        "ref" === n
                            ? (p = !0)
                            : "class" !== n || a
                            ? "style" !== n || a
                                ? "key" === n || v.includes(n) || v.push(n)
                                : (f = !0)
                            : (d = !0);
                    } else y = !0;
                };
            for (let h = 0; h < n.length; h++) {
                const d = n[h];
                if (6 === d.type) {
                    const { loc: t, name: e, value: n } = d;
                    if (
                        ("ref" === e && (p = !0),
                        "is" === e && "component" === i)
                    )
                        continue;
                    c.push(
                        ao(
                            co(e, !0, wo(t, 0, e.length)),
                            co(n ? n.content : "", !0, n ? n.loc : t)
                        )
                    );
                } else {
                    const { name: n, arg: h, exp: p, loc: f } = d,
                        m = "bind" === n,
                        g = "on" === n;
                    if ("slot" === n) {
                        a || e.onError(Ci(39, f));
                        continue;
                    }
                    if ("once" === n) continue;
                    if ("is" === n || (m && "component" === i && So(h, "is")))
                        continue;
                    if (g && r) continue;
                    if (!h && (m || g)) {
                        (y = !0),
                            p
                                ? (c.length && (l.push(oo(za(c), o)), (c = [])),
                                  m
                                      ? l.push(p)
                                      : l.push({
                                            type: 14,
                                            loc: f,
                                            callee: e.helper(Ki),
                                            arguments: [p],
                                        }))
                                : e.onError(Ci(m ? 33 : 34, f));
                        continue;
                    }
                    const v = e.directiveTransforms[n];
                    if (v) {
                        const { props: n, needRuntime: i } = v(d, t, e);
                        !r && n.forEach(b),
                            c.push(...n),
                            i && (u.push(d), Object(s.C)(i) && Va.set(d, i));
                    } else u.push(d);
                }
            }
            let x = void 0;
            return (
                l.length
                    ? (c.length && l.push(oo(za(c), o)),
                      (x = l.length > 1 ? uo(e.helper(Gi), l, o) : l[0]))
                    : c.length && (x = oo(za(c), o)),
                y
                    ? (h |= 16)
                    : (d && (h |= 2),
                      f && (h |= 4),
                      v.length && (h |= 8),
                      m && (h |= 32)),
                (0 !== h && 32 !== h) ||
                    !(p || g || u.length > 0) ||
                    (h |= 512),
                { props: x, directives: u, patchFlag: h, dynamicPropNames: v }
            );
        }
        function za(t) {
            const e = new Map(),
                n = [];
            for (let r = 0; r < t.length; r++) {
                const s = t[r];
                if (8 === s.key.type || !s.key.isStatic) {
                    n.push(s);
                    continue;
                }
                const i = s.key.content,
                    o = e.get(i);
                o
                    ? ("style" === i || "class" === i || i.startsWith("on")) &&
                      Ha(o, s)
                    : (e.set(i, s), n.push(s));
            }
            return n;
        }
        function Ha(t, e) {
            17 === t.value.type
                ? t.value.elements.push(e.value)
                : (t.value = io([t.value, e.value], t.loc));
        }
        const Wa = (t, e) => {
            if (_o(t)) {
                const { children: n, loc: r } = t,
                    { slotName: s, slotProps: i } = (function (t, e) {
                        let n = '"default"',
                            r = void 0;
                        const s = To(t, "name");
                        s &&
                            (6 === s.type && s.value
                                ? (n = JSON.stringify(s.value.content))
                                : 7 === s.type && s.exp && (n = s.exp));
                        const i = s ? t.props.filter((t) => t !== s) : t.props;
                        if (i.length > 0) {
                            const { props: n, directives: s } = $a(t, e, i);
                            (r = n), s.length && e.onError(Ci(35, s[0].loc));
                        }
                        return { slotName: n, slotProps: r };
                    })(t, e),
                    o = [e.prefixIdentifiers ? "_ctx.$slots" : "$slots", s];
                i && o.push(i),
                    n.length &&
                        (i || o.push("{}"), o.push(ho([], n, !1, !1, r))),
                    (t.codegenNode = uo(e.helper(zi), o, r));
            }
        };
        const Ga =
                /^\s*([\w$_]+|\([^)]*?\))\s*=>|^\s*function(?:\s+[\w$]+)?\s*\(/,
            Ka = (t, e, n, r) => {
                const { loc: i, modifiers: o, arg: a } = t;
                let c;
                if ((t.exp || o.length || n.onError(Ci(34, i)), 4 === a.type))
                    if (a.isStatic) {
                        const t = a.content;
                        c = co(
                            "on" +
                                (t.startsWith("vnode")
                                    ? Object(s.h)(Object(s.g)(t))
                                    : Object(s.h)(t)),
                            !0,
                            a.loc
                        );
                    } else c = lo([`"on" + ${n.helperString(Xi)}(`, a, ")"]);
                else
                    (c = a),
                        c.children.unshift(`"on" + ${n.helperString(Xi)}(`),
                        c.children.push(")");
                let l = t.exp;
                l && !l.content.trim() && (l = void 0);
                let u = n.cacheHandlers && !l;
                if (l) {
                    const t = xo(l.content),
                        e = !(t || Ga.test(l.content)),
                        n = l.content.includes(";");
                    0,
                        (e || (u && t)) &&
                            (l = lo([
                                `${e ? "$event" : "(...args)"} => ${
                                    n ? "{" : "("
                                }`,
                                l,
                                n ? "}" : ")",
                            ]));
                }
                let h = { props: [ao(c, l || co("() => {}", !1, i))] };
                return (
                    r && (h = r(h)),
                    u && (h.props[0].value = n.cache(h.props[0].value)),
                    h
                );
            },
            Ja = (t, e, n) => {
                const { exp: r, modifiers: i, loc: o } = t,
                    a = t.arg;
                return (
                    i.includes("camel") &&
                        (4 === a.type
                            ? a.isStatic
                                ? (a.content = Object(s.g)(a.content))
                                : (a.content = `${n.helperString(Ji)}(${
                                      a.content
                                  })`)
                            : (a.children.unshift(n.helperString(Ji) + "("),
                              a.children.push(")"))),
                    !r || (4 === r.type && !r.content.trim())
                        ? (n.onError(Ci(33, o)),
                          { props: [ao(a, co("", !0, o))] })
                        : { props: [ao(a, r)] }
                );
            },
            Xa = (t, e) => {
                if (
                    0 === t.type ||
                    1 === t.type ||
                    11 === t.type ||
                    10 === t.type
                )
                    return () => {
                        const n = t.children;
                        let r = void 0,
                            i = !1;
                        for (let t = 0; t < n.length; t++) {
                            const e = n[t];
                            if (Co(e)) {
                                i = !0;
                                for (let s = t + 1; s < n.length; s++) {
                                    const i = n[s];
                                    if (!Co(i)) {
                                        r = void 0;
                                        break;
                                    }
                                    r ||
                                        (r = n[t] =
                                            {
                                                type: 8,
                                                loc: e.loc,
                                                children: [e],
                                            }),
                                        r.children.push(" + ", i),
                                        n.splice(s, 1),
                                        s--;
                                }
                            }
                        }
                        if (
                            i &&
                            (1 !== n.length ||
                                (0 !== t.type &&
                                    (1 !== t.type || 0 !== t.tagType)))
                        )
                            for (let t = 0; t < n.length; t++) {
                                const r = n[t];
                                if (Co(r) || 8 === r.type) {
                                    const i = [];
                                    (2 === r.type && " " === r.content) ||
                                        i.push(r),
                                        e.ssr ||
                                            2 === r.type ||
                                            i.push(`1 /* ${s.e[1]} */`),
                                        (n[t] = {
                                            type: 12,
                                            content: r,
                                            loc: r.loc,
                                            codegenNode: uo(e.helper(Di), i),
                                        });
                                }
                            }
                    };
            },
            Ya = (t, e) => {
                if (1 === t.type && Eo(t, "once", !0))
                    return (
                        e.helper(Yi),
                        () => {
                            t.codegenNode &&
                                (t.codegenNode = e.cache(t.codegenNode, !0));
                        }
                    );
            },
            Qa = (t, e, n) => {
                const { exp: r, arg: s } = t;
                if (!r) return n.onError(Ci(40, t.loc)), Za();
                const i = 4 === r.type ? r.content : r.loc.source;
                if (!xo(i)) return n.onError(Ci(41, r.loc)), Za();
                const o = s || co("modelValue", !0),
                    a = s
                        ? fo(s)
                            ? "onUpdate:" + s.content
                            : lo(['"onUpdate:" + ', s])
                        : "onUpdate:modelValue",
                    c = [
                        ao(o, t.exp),
                        ao(a, lo(["$event => (", r, " = $event)"])),
                    ];
                if (t.modifiers.length && 1 === e.tagType) {
                    const e = t.modifiers
                            .map(
                                (t) =>
                                    (vo(t) ? t : JSON.stringify(t)) + ": true"
                            )
                            .join(", "),
                        n = s
                            ? fo(s)
                                ? s.content + "Modifiers"
                                : lo([s, ' + "Modifiers"'])
                            : "modelModifiers";
                    c.push(ao(n, co(`{ ${e} }`, !1, t.loc, !0)));
                }
                return Za(c);
            };
        function Za(t = []) {
            return { props: t };
        }
        function tc(t, e = {}) {
            const n = e.onError || Si,
                r = "module" === e.mode;
            !0 === e.prefixIdentifiers ? n(Ci(45)) : r && n(Ci(46));
            e.cacheHandlers && n(Ci(47)), e.scopeId && !r && n(Ci(48));
            const i = Object(s.B)(t) ? Ro(t, e) : t,
                [o, a] = [
                    [Ya, Ta, ka, Wa, qa, Da, Xa],
                    { on: Ka, bind: Ja, model: Qa },
                ];
            return (
                da(
                    i,
                    Object(s.j)({}, e, {
                        prefixIdentifiers: false,
                        nodeTransforms: [...o, ...(e.nodeTransforms || [])],
                        directiveTransforms: Object(s.j)(
                            {},
                            a,
                            e.directiveTransforms || {}
                        ),
                    })
                ),
                ga(i, Object(s.j)({}, e, { prefixIdentifiers: false }))
            );
        }
        const ec = Symbol(""),
            nc = Symbol(""),
            rc = Symbol(""),
            sc = Symbol(""),
            ic = Symbol(""),
            oc = Symbol(""),
            ac = Symbol(""),
            cc = Symbol(""),
            lc = Symbol(""),
            uc = Symbol("");
        var hc;
        let pc;
        (hc = {
            [ec]: "vModelRadio",
            [nc]: "vModelCheckbox",
            [rc]: "vModelText",
            [sc]: "vModelSelect",
            [ic]: "vModelDynamic",
            [oc]: "withModifiers",
            [ac]: "withKeys",
            [cc]: "vShow",
            [lc]: "Transition",
            [uc]: "TransitionGroup",
        }),
            Object.getOwnPropertySymbols(hc).forEach((t) => {
                no[t] = hc[t];
            });
        const dc = Object(s.G)("style,iframe,script,noscript", !0),
            fc = {
                isVoidTag: s.D,
                isNativeTag: (t) => Object(s.s)(t) || Object(s.z)(t),
                isPreTag: (t) => "pre" === t,
                decodeEntities: function (t) {
                    return (
                        ((
                            pc || (pc = document.createElement("div"))
                        ).innerHTML = t),
                        pc.textContent
                    );
                },
                isBuiltInComponent: (t) =>
                    mo(t, "Transition")
                        ? lc
                        : mo(t, "TransitionGroup")
                        ? uc
                        : void 0,
                getNamespace(t, e) {
                    let n = e ? e.ns : 0;
                    if (e && 2 === n)
                        if ("annotation-xml" === e.tag) {
                            if ("svg" === t) return 1;
                            e.props.some(
                                (t) =>
                                    6 === t.type &&
                                    "encoding" === t.name &&
                                    null != t.value &&
                                    ("text/html" === t.value.content ||
                                        "application/xhtml+xml" ===
                                            t.value.content)
                            ) && (n = 0);
                        } else
                            /^m(?:[ions]|text)$/.test(e.tag) &&
                                "mglyph" !== t &&
                                "malignmark" !== t &&
                                (n = 0);
                    else
                        e &&
                            1 === n &&
                            (("foreignObject" !== e.tag &&
                                "desc" !== e.tag &&
                                "title" !== e.tag) ||
                                (n = 0));
                    if (0 === n) {
                        if ("svg" === t) return 1;
                        if ("math" === t) return 2;
                    }
                    return n;
                },
                getTextMode({ tag: t, ns: e }) {
                    if (0 === e) {
                        if ("textarea" === t || "title" === t) return 1;
                        if (dc(t)) return 2;
                    }
                    return 0;
                },
            },
            mc = (t, e) => {
                const n = Object(s.J)(t);
                return co(JSON.stringify(n), !1, e, !0);
            };
        function yc(t, e) {
            return Ci(t, e);
        }
        const gc = Object(s.G)("passive,once,capture"),
            vc = Object(s.G)(
                "stop,prevent,self,ctrl,shift,alt,meta,exact,middle"
            ),
            bc = Object(s.G)("left,right"),
            xc = Object(s.G)("onkeyup,onkeydown,onkeypress", !0),
            wc = (t, e) =>
                fo(t) && "onclick" === t.content.toLowerCase()
                    ? co(e, !0)
                    : 4 !== t.type
                    ? lo(["(", t, `) === "onClick" ? "${e}" : (`, t, ")"])
                    : t;
        const Pc = (t, e) => {
                1 !== t.type ||
                    0 !== t.tagType ||
                    ("script" !== t.tag && "style" !== t.tag) ||
                    (e.onError(yc(59, t.loc)), e.removeNode());
            },
            Ac = [
                (t) => {
                    1 === t.type &&
                        t.props.forEach((e, n) => {
                            6 === e.type &&
                                "style" === e.name &&
                                e.value &&
                                (t.props[n] = {
                                    type: 7,
                                    name: "bind",
                                    arg: co("style", !0, e.loc),
                                    exp: mc(e.value.content, e.loc),
                                    modifiers: [],
                                    loc: e.loc,
                                });
                        });
                },
            ],
            Ec = {
                cloak: () => ({ props: [] }),
                html: (t, e, n) => {
                    const { exp: r, loc: s } = t;
                    return (
                        r || n.onError(yc(49, s)),
                        e.children.length &&
                            (n.onError(yc(50, s)), (e.children.length = 0)),
                        { props: [ao(co("innerHTML", !0, s), r || co("", !0))] }
                    );
                },
                text: (t, e, n) => {
                    const { exp: r, loc: s } = t;
                    return (
                        r || n.onError(yc(51, s)),
                        e.children.length &&
                            (n.onError(yc(52, s)), (e.children.length = 0)),
                        {
                            props: [
                                ao(co("textContent", !0, s), r || co("", !0)),
                            ],
                        }
                    );
                },
                model: (t, e, n) => {
                    const r = Qa(t, e, n);
                    if (!r.props.length || 1 === e.tagType) return r;
                    t.arg && n.onError(yc(54, t.arg.loc));
                    const { tag: s } = e,
                        i = n.isCustomElement(s);
                    if (
                        "input" === s ||
                        "textarea" === s ||
                        "select" === s ||
                        i
                    ) {
                        let o = rc,
                            a = !1;
                        if ("input" === s || i) {
                            const r = To(e, "type");
                            if (r) {
                                if (7 === r.type) o = ic;
                                else if (r.value)
                                    switch (r.value.content) {
                                        case "radio":
                                            o = ec;
                                            break;
                                        case "checkbox":
                                            o = nc;
                                            break;
                                        case "file":
                                            (a = !0), n.onError(yc(55, t.loc));
                                    }
                            } else
                                (function (t) {
                                    return t.props.some(
                                        (t) =>
                                            !(
                                                7 !== t.type ||
                                                "bind" !== t.name ||
                                                (t.arg &&
                                                    4 === t.arg.type &&
                                                    t.arg.isStatic)
                                            )
                                    );
                                })(e) && (o = ic);
                        } else "select" === s && (o = sc);
                        a || (r.needRuntime = n.helper(o));
                    } else n.onError(yc(53, t.loc));
                    return (
                        (r.props = r.props.filter(
                            (t) =>
                                !(
                                    4 === t.key.type &&
                                    "modelValue" === t.key.content
                                )
                        )),
                        r
                    );
                },
                on: (t, e, n) =>
                    Ka(t, 0, n, (e) => {
                        const { modifiers: r } = t;
                        if (!r.length) return e;
                        let { key: i, value: o } = e.props[0];
                        const {
                            keyModifiers: a,
                            nonKeyModifiers: c,
                            eventOptionModifiers: l,
                        } = ((t, e) => {
                            const n = [],
                                r = [],
                                s = [];
                            for (let i = 0; i < e.length; i++) {
                                const o = e[i];
                                gc(o)
                                    ? s.push(o)
                                    : bc(o)
                                    ? fo(t)
                                        ? xc(t.content)
                                            ? n.push(o)
                                            : r.push(o)
                                        : (n.push(o), r.push(o))
                                    : vc(o)
                                    ? r.push(o)
                                    : n.push(o);
                            }
                            return {
                                keyModifiers: n,
                                nonKeyModifiers: r,
                                eventOptionModifiers: s,
                            };
                        })(i, r);
                        if (
                            (c.includes("right") &&
                                (i = wc(i, "onContextmenu")),
                            c.includes("middle") && (i = wc(i, "onMouseup")),
                            c.length &&
                                (o = uo(n.helper(oc), [o, JSON.stringify(c)])),
                            !a.length ||
                                (fo(i) && !xc(i.content)) ||
                                (o = uo(n.helper(ac), [o, JSON.stringify(a)])),
                            l.length)
                        ) {
                            const t = l.map(s.h).join("");
                            i = fo(i)
                                ? co(`${i.content}${t}`, !0)
                                : lo(["(", i, `) + "${t}"`]);
                        }
                        return { props: [ao(i, o)] };
                    }),
                show: (t, e, n) => {
                    const { exp: r, loc: s } = t;
                    return (
                        r || n.onError(yc(57, s)),
                        { props: [], needRuntime: n.helper(cc) }
                    );
                },
            };
        const Tc = Object.create(null);
        Gr(function (t, e) {
            if (!Object(s.B)(t)) {
                if (!t.nodeType) return s.d;
                t = t.innerHTML;
            }
            const n = t,
                i = Tc[n];
            if (i) return i;
            if ("#" === t[0]) {
                const e = document.querySelector(t);
                0, (t = e ? e.innerHTML : "");
            }
            const { code: o } = (function (t, e = {}) {
                    return tc(
                        t,
                        Object(s.j)({}, fc, e, {
                            nodeTransforms: [
                                Pc,
                                ...Ac,
                                ...(e.nodeTransforms || []),
                            ],
                            directiveTransforms: Object(s.j)(
                                {},
                                Ec,
                                e.directiveTransforms || {}
                            ),
                            transformHoist: null,
                        })
                    );
                })(
                    t,
                    Object(s.j)(
                        {
                            hoistStatic: !0,
                            onError(t) {
                                throw t;
                            },
                        },
                        e
                    )
                ),
                a = new Function("Vue", o)(r);
            return (a._rc = !0), (Tc[n] = a);
        });
    },
    function (t, e, n) {
        var r = n(3),
            s = n(9),
            i = n(17),
            o = n(13),
            a = n(21),
            c = function (t, e, n) {
                var l,
                    u,
                    h,
                    p,
                    d = t & c.F,
                    f = t & c.G,
                    m = t & c.S,
                    y = t & c.P,
                    g = t & c.B,
                    v = f
                        ? r
                        : m
                        ? r[e] || (r[e] = {})
                        : (r[e] || {}).prototype,
                    b = f ? s : s[e] || (s[e] = {}),
                    x = b.prototype || (b.prototype = {});
                for (l in (f && (n = e), n))
                    (h = ((u = !d && v && void 0 !== v[l]) ? v : n)[l]),
                        (p =
                            g && u
                                ? a(h, r)
                                : y && "function" == typeof h
                                ? a(Function.call, h)
                                : h),
                        v && o(v, l, h, t & c.U),
                        b[l] != h && i(b, l, p),
                        y && x[l] != h && (x[l] = h);
            };
        (r.core = s),
            (c.F = 1),
            (c.G = 2),
            (c.S = 4),
            (c.P = 8),
            (c.B = 16),
            (c.W = 32),
            (c.U = 64),
            (c.R = 128),
            (t.exports = c);
    },
    function (t, e) {
        var n = (t.exports =
            "undefined" != typeof window && window.Math == Math
                ? window
                : "undefined" != typeof self && self.Math == Math
                ? self
                : Function("return this")());
        "number" == typeof __g && (__g = n);
    },
    function (t, e) {
        t.exports = function (t) {
            try {
                return !!t();
            } catch (t) {
                return !0;
            }
        };
    },
    function (t, e, n) {
        var r = n(6);
        t.exports = function (t) {
            if (!r(t)) throw TypeError(t + " is not an object!");
            return t;
        };
    },
    function (t, e) {
        t.exports = function (t) {
            return "object" == typeof t ? null !== t : "function" == typeof t;
        };
    },
    function (t, e, n) {
        var r = n(53)("wks"),
            s = n(33),
            i = n(3).Symbol,
            o = "function" == typeof i;
        (t.exports = function (t) {
            return r[t] || (r[t] = (o && i[t]) || (o ? i : s)("Symbol." + t));
        }).store = r;
    },
    function (t, e, n) {
        var r = n(23),
            s = Math.min;
        t.exports = function (t) {
            return t > 0 ? s(r(t), 9007199254740991) : 0;
        };
    },
    function (t, e) {
        var n = (t.exports = { version: "2.6.11" });
        "number" == typeof __e && (__e = n);
    },
    function (t, e, n) {
        t.exports = !n(4)(function () {
            return (
                7 !=
                Object.defineProperty({}, "a", {
                    get: function () {
                        return 7;
                    },
                }).a
            );
        });
    },
    function (t, e, n) {
        var r = n(5),
            s = n(93),
            i = n(30),
            o = Object.defineProperty;
        e.f = n(10)
            ? Object.defineProperty
            : function (t, e, n) {
                  if ((r(t), (e = i(e, !0)), r(n), s))
                      try {
                          return o(t, e, n);
                      } catch (t) {}
                  if ("get" in n || "set" in n)
                      throw TypeError("Accessors not supported!");
                  return "value" in n && (t[e] = n.value), t;
              };
    },
    function (t, e, n) {
        var r = n(28);
        t.exports = function (t) {
            return Object(r(t));
        };
    },
    function (t, e, n) {
        var r = n(3),
            s = n(17),
            i = n(16),
            o = n(33)("src"),
            a = n(173),
            c = "toString",
            l = ("" + a).split(c);
        (n(9).inspectSource = function (t) {
            return a.call(t);
        }),
            (t.exports = function (t, e, n, a) {
                var c = "function" == typeof n;
                c && (i(n, "name") || s(n, "name", e)),
                    t[e] !== n &&
                        (c &&
                            (i(n, o) ||
                                s(n, o, t[e] ? "" + t[e] : l.join(String(e)))),
                        t === r
                            ? (t[e] = n)
                            : a
                            ? t[e]
                                ? (t[e] = n)
                                : s(t, e, n)
                            : (delete t[e], s(t, e, n)));
            })(Function.prototype, c, function () {
                return ("function" == typeof this && this[o]) || a.call(this);
            });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(4),
            i = n(28),
            o = /"/g,
            a = function (t, e, n, r) {
                var s = String(i(t)),
                    a = "<" + e;
                return (
                    "" !== n &&
                        (a +=
                            " " +
                            n +
                            '="' +
                            String(r).replace(o, "&quot;") +
                            '"'),
                    a + ">" + s + "</" + e + ">"
                );
            };
        t.exports = function (t, e) {
            var n = {};
            (n[t] = e(a)),
                r(
                    r.P +
                        r.F *
                            s(function () {
                                var e = ""[t]('"');
                                return (
                                    e !== e.toLowerCase() ||
                                    e.split('"').length > 3
                                );
                            }),
                    "String",
                    n
                );
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(127),
            s = Object.prototype.toString;
        function i(t) {
            return "[object Array]" === s.call(t);
        }
        function o(t) {
            return void 0 === t;
        }
        function a(t) {
            return null !== t && "object" == typeof t;
        }
        function c(t) {
            if ("[object Object]" !== s.call(t)) return !1;
            var e = Object.getPrototypeOf(t);
            return null === e || e === Object.prototype;
        }
        function l(t) {
            return "[object Function]" === s.call(t);
        }
        function u(t, e) {
            if (null != t)
                if (("object" != typeof t && (t = [t]), i(t)))
                    for (var n = 0, r = t.length; n < r; n++)
                        e.call(null, t[n], n, t);
                else
                    for (var s in t)
                        Object.prototype.hasOwnProperty.call(t, s) &&
                            e.call(null, t[s], s, t);
        }
        t.exports = {
            isArray: i,
            isArrayBuffer: function (t) {
                return "[object ArrayBuffer]" === s.call(t);
            },
            isBuffer: function (t) {
                return (
                    null !== t &&
                    !o(t) &&
                    null !== t.constructor &&
                    !o(t.constructor) &&
                    "function" == typeof t.constructor.isBuffer &&
                    t.constructor.isBuffer(t)
                );
            },
            isFormData: function (t) {
                return "undefined" != typeof FormData && t instanceof FormData;
            },
            isArrayBufferView: function (t) {
                return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView
                    ? ArrayBuffer.isView(t)
                    : t && t.buffer && t.buffer instanceof ArrayBuffer;
            },
            isString: function (t) {
                return "string" == typeof t;
            },
            isNumber: function (t) {
                return "number" == typeof t;
            },
            isObject: a,
            isPlainObject: c,
            isUndefined: o,
            isDate: function (t) {
                return "[object Date]" === s.call(t);
            },
            isFile: function (t) {
                return "[object File]" === s.call(t);
            },
            isBlob: function (t) {
                return "[object Blob]" === s.call(t);
            },
            isFunction: l,
            isStream: function (t) {
                return a(t) && l(t.pipe);
            },
            isURLSearchParams: function (t) {
                return (
                    "undefined" != typeof URLSearchParams &&
                    t instanceof URLSearchParams
                );
            },
            isStandardBrowserEnv: function () {
                return (
                    ("undefined" == typeof navigator ||
                        ("ReactNative" !== navigator.product &&
                            "NativeScript" !== navigator.product &&
                            "NS" !== navigator.product)) &&
                    "undefined" != typeof window &&
                    "undefined" != typeof document
                );
            },
            forEach: u,
            merge: function t() {
                var e = {};
                function n(n, r) {
                    c(e[r]) && c(n)
                        ? (e[r] = t(e[r], n))
                        : c(n)
                        ? (e[r] = t({}, n))
                        : i(n)
                        ? (e[r] = n.slice())
                        : (e[r] = n);
                }
                for (var r = 0, s = arguments.length; r < s; r++)
                    u(arguments[r], n);
                return e;
            },
            extend: function (t, e, n) {
                return (
                    u(e, function (e, s) {
                        t[s] = n && "function" == typeof e ? r(e, n) : e;
                    }),
                    t
                );
            },
            trim: function (t) {
                return t.replace(/^\s*/, "").replace(/\s*$/, "");
            },
            stripBOM: function (t) {
                return 65279 === t.charCodeAt(0) && (t = t.slice(1)), t;
            },
        };
    },
    function (t, e) {
        var n = {}.hasOwnProperty;
        t.exports = function (t, e) {
            return n.call(t, e);
        };
    },
    function (t, e, n) {
        var r = n(11),
            s = n(32);
        t.exports = n(10)
            ? function (t, e, n) {
                  return r.f(t, e, s(1, n));
              }
            : function (t, e, n) {
                  return (t[e] = n), t;
              };
    },
    function (t, e, n) {
        var r = n(49),
            s = n(28);
        t.exports = function (t) {
            return r(s(t));
        };
    },
    function (t, e) {
        function n(t, e) {
            return (
                (function (t) {
                    if (Array.isArray(t)) return t;
                })(t) ||
                (function (t, e) {
                    if (
                        "undefined" == typeof Symbol ||
                        !(Symbol.iterator in Object(t))
                    )
                        return;
                    var n = [],
                        r = !0,
                        s = !1,
                        i = void 0;
                    try {
                        for (
                            var o, a = t[Symbol.iterator]();
                            !(r = (o = a.next()).done) &&
                            (n.push(o.value), !e || n.length !== e);
                            r = !0
                        );
                    } catch (t) {
                        (s = !0), (i = t);
                    } finally {
                        try {
                            r || null == a.return || a.return();
                        } finally {
                            if (s) throw i;
                        }
                    }
                    return n;
                })(t, e) ||
                (function (t, e) {
                    if (!t) return;
                    if ("string" == typeof t) return r(t, e);
                    var n = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === n && t.constructor && (n = t.constructor.name);
                    if ("Map" === n || "Set" === n) return Array.from(t);
                    if (
                        "Arguments" === n ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                    )
                        return r(t, e);
                })(t, e) ||
                (function () {
                    throw new TypeError(
                        "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                    );
                })()
            );
        }
        function r(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
            return r;
        }
        var s = {
                load: function (t) {
                    return t
                        .slice(1)
                        .split("&")
                        .map(function (t) {
                            return t.split("=");
                        })
                        .reduce(function (t, e) {
                            var r = n(e, 2),
                                s = r[0],
                                i = r[1];
                            return (
                                /^\d+$/.test(i) && (i = parseInt(i)),
                                s in t
                                    ? Array.isArray(t[s])
                                        ? t[s].push(i)
                                        : (t[s] = [t[s], i])
                                    : (t[s] = i),
                                t
                            );
                        }, {});
                },
                dump: function (t) {
                    return (
                        "?" +
                        Object.entries(t)
                            .map(function (t) {
                                var e = n(t, 2),
                                    r = e[0],
                                    s = e[1];
                                return Array.isArray(s)
                                    ? s
                                          .map(function (t) {
                                              return ""
                                                  .concat(r, "=")
                                                  .concat(t);
                                          })
                                          .join("&")
                                    : "".concat(r, "=").concat(s);
                            })
                            .join("&")
                    );
                },
            },
            i = {
                get: function (t) {
                    return document.querySelector(
                        'meta[name="'.concat(t, '"]')
                    );
                },
                set: function (t, e) {
                    var n = this.get(t);
                    Object.entries(e).forEach(function (t) {
                        n.setAttribute(t[0], t[1]);
                    });
                },
            };
        t.exports = {
            scrollTop: function () {
                document.body.scrollIntoView({
                    behavior: "smooth",
                    block: "start",
                    inline: "nearest",
                });
            },
            delay: function (t, e) {
                var n,
                    r,
                    s = [];
                return (n = {
                    delay: function (t, e) {
                        return (
                            s.length || r
                                ? s.push({ fn: t, t: e })
                                : (function t(e, n) {
                                      r = setTimeout(function () {
                                          if (((r = null), e(), s.length)) {
                                              var n = s.shift();
                                              t(n.fn, n.t);
                                          }
                                      }, n);
                                  })(t, e),
                            n
                        );
                    },
                    cancel: function () {
                        return clearTimeout(r), (s = []), n;
                    },
                }).delay(t, e);
            },
            emitEvent: function (t, e) {
                window.dispatchEvent(new CustomEvent(t, { detail: e }));
            },
            copytoClipboard: function (t) {
                var e = document.createElement("input");
                (e.value = t),
                    document.body.appendChild(e),
                    e.select(),
                    document.execCommand("copy"),
                    e.remove();
            },
            donwloadUrl: function (t, e) {
                var n = document.createElement("a");
                (e = void 0 === e ? "download" : e),
                    (n.innerText = "download"),
                    n.setAttribute("href", t),
                    n.setAttribute("download", e),
                    document.body.appendChild(n),
                    n.click(),
                    n.remove();
            },
            shuffle: function (t) {
                for (var e = t.length - 1; e > 0; e--) {
                    var n = Math.floor(Math.random() * (e + 1)),
                        r = [t[n], t[e]];
                    (t[e] = r[0]), (t[n] = r[1]);
                }
                return t;
            },
            queryString: s,
            debounce: function (t, e) {
                for (
                    var n = arguments.length,
                        r = new Array(n > 2 ? n - 2 : 0),
                        s = 2;
                    s < n;
                    s++
                )
                    r[s - 2] = arguments[s];
                clearTimeout(t._tId),
                    (t._tId = setTimeout(function () {
                        t.apply(void 0, r);
                    }, e));
            },
            striptags: function (t) {
                try {
                    return t.replace(/(<([^>]+)>)/gi, "");
                } catch (e) {
                    return t;
                }
            },
            splitlist: function (t, e) {
                try {
                    return t
                        ? Array.from(t).reduce(function (t, n) {
                              return (
                                  0 === t.length
                                      ? t.push([n])
                                      : t[t.length - 1].length < e
                                      ? t[t.length - 1].push(n)
                                      : t.push([n]),
                                  t
                              );
                          }, [])
                        : [];
                } catch (t) {
                    return [];
                }
            },
            WebpIsSupported: function (t) {
                if (window.createImageBitmap) {
                    fetch(
                        "data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoCAAEAAQAcJaQAA3AA/v3AgAA="
                    )
                        .then(function (t) {
                            return t.blob();
                        })
                        .then(function (e) {
                            createImageBitmap(e).then(
                                function () {
                                    t(!0);
                                },
                                function () {
                                    t(!1);
                                }
                            );
                        });
                } else t(!1);
            },
            metaTag: i,
            embedIframe: function (t) {
                try {
                    var e = t
                        .replace(/<iframe/g, '<div class="embed"><iframe')
                        .replace(/<\/iframe>/g, "</iframe></div>");
                    return (
                        (
                            e.match(
                                /<div class="embed"><iframe[^>]+facebook.*?>*/g
                            ) || []
                        ).forEach(function (t) {
                            e = e.replace(
                                t,
                                t.replace(
                                    'class="embed"',
                                    'class="embed embed-fb"'
                                )
                            );
                        }),
                        e
                    );
                } catch (e) {
                    return t;
                }
            },
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(4);
        t.exports = function (t, e) {
            return (
                !!t &&
                r(function () {
                    e ? t.call(null, function () {}, 1) : t.call(null);
                })
            );
        };
    },
    function (t, e, n) {
        var r = n(22);
        t.exports = function (t, e, n) {
            if ((r(t), void 0 === e)) return t;
            switch (n) {
                case 1:
                    return function (n) {
                        return t.call(e, n);
                    };
                case 2:
                    return function (n, r) {
                        return t.call(e, n, r);
                    };
                case 3:
                    return function (n, r, s) {
                        return t.call(e, n, r, s);
                    };
            }
            return function () {
                return t.apply(e, arguments);
            };
        };
    },
    function (t, e) {
        t.exports = function (t) {
            if ("function" != typeof t)
                throw TypeError(t + " is not a function!");
            return t;
        };
    },
    function (t, e) {
        var n = Math.ceil,
            r = Math.floor;
        t.exports = function (t) {
            return isNaN((t = +t)) ? 0 : (t > 0 ? r : n)(t);
        };
    },
    function (t, e, n) {
        var r = n(50),
            s = n(32),
            i = n(18),
            o = n(30),
            a = n(16),
            c = n(93),
            l = Object.getOwnPropertyDescriptor;
        e.f = n(10)
            ? l
            : function (t, e) {
                  if (((t = i(t)), (e = o(e, !0)), c))
                      try {
                          return l(t, e);
                      } catch (t) {}
                  if (a(t, e)) return s(!r.f.call(t, e), t[e]);
              };
    },
    function (t, e, n) {
        var r = n(2),
            s = n(9),
            i = n(4);
        t.exports = function (t, e) {
            var n = (s.Object || {})[t] || Object[t],
                o = {};
            (o[t] = e(n)),
                r(
                    r.S +
                        r.F *
                            i(function () {
                                n(1);
                            }),
                    "Object",
                    o
                );
        };
    },
    function (t, e, n) {
        var r = n(21),
            s = n(49),
            i = n(12),
            o = n(8),
            a = n(109);
        t.exports = function (t, e) {
            var n = 1 == t,
                c = 2 == t,
                l = 3 == t,
                u = 4 == t,
                h = 6 == t,
                p = 5 == t || h,
                d = e || a;
            return function (e, a, f) {
                for (
                    var m,
                        y,
                        g = i(e),
                        v = s(g),
                        b = r(a, f, 3),
                        x = o(v.length),
                        w = 0,
                        P = n ? d(e, x) : c ? d(e, 0) : void 0;
                    x > w;
                    w++
                )
                    if ((p || w in v) && ((y = b((m = v[w]), w, g)), t))
                        if (n) P[w] = y;
                        else if (y)
                            switch (t) {
                                case 3:
                                    return !0;
                                case 5:
                                    return m;
                                case 6:
                                    return w;
                                case 2:
                                    P.push(m);
                            }
                        else if (u) return !1;
                return h ? -1 : l || u ? u : P;
            };
        };
    },
    function (t, e) {
        var n = {}.toString;
        t.exports = function (t) {
            return n.call(t).slice(8, -1);
        };
    },
    function (t, e) {
        t.exports = function (t) {
            if (null == t) throw TypeError("Can't call method on  " + t);
            return t;
        };
    },
    function (t, e, n) {
        "use strict";
        if (n(10)) {
            var r = n(34),
                s = n(3),
                i = n(4),
                o = n(2),
                a = n(64),
                c = n(89),
                l = n(21),
                u = n(47),
                h = n(32),
                p = n(17),
                d = n(48),
                f = n(23),
                m = n(8),
                y = n(120),
                g = n(36),
                v = n(30),
                b = n(16),
                x = n(51),
                w = n(6),
                P = n(12),
                A = n(81),
                E = n(37),
                T = n(39),
                S = n(38).f,
                C = n(83),
                O = n(33),
                k = n(7),
                _ = n(26),
                N = n(54),
                I = n(52),
                j = n(85),
                L = n(45),
                M = n(57),
                R = n(46),
                D = n(84),
                F = n(111),
                B = n(11),
                U = n(24),
                V = B.f,
                q = U.f,
                $ = s.RangeError,
                z = s.TypeError,
                H = s.Uint8Array,
                W = "ArrayBuffer",
                G = "SharedArrayBuffer",
                K = "BYTES_PER_ELEMENT",
                J = Array.prototype,
                X = c.ArrayBuffer,
                Y = c.DataView,
                Q = _(0),
                Z = _(2),
                tt = _(3),
                et = _(4),
                nt = _(5),
                rt = _(6),
                st = N(!0),
                it = N(!1),
                ot = j.values,
                at = j.keys,
                ct = j.entries,
                lt = J.lastIndexOf,
                ut = J.reduce,
                ht = J.reduceRight,
                pt = J.join,
                dt = J.sort,
                ft = J.slice,
                mt = J.toString,
                yt = J.toLocaleString,
                gt = k("iterator"),
                vt = k("toStringTag"),
                bt = O("typed_constructor"),
                xt = O("def_constructor"),
                wt = a.CONSTR,
                Pt = a.TYPED,
                At = a.VIEW,
                Et = "Wrong length!",
                Tt = _(1, function (t, e) {
                    return _t(I(t, t[xt]), e);
                }),
                St = i(function () {
                    return 1 === new H(new Uint16Array([1]).buffer)[0];
                }),
                Ct =
                    !!H &&
                    !!H.prototype.set &&
                    i(function () {
                        new H(1).set({});
                    }),
                Ot = function (t, e) {
                    var n = f(t);
                    if (n < 0 || n % e) throw $("Wrong offset!");
                    return n;
                },
                kt = function (t) {
                    if (w(t) && Pt in t) return t;
                    throw z(t + " is not a typed array!");
                },
                _t = function (t, e) {
                    if (!w(t) || !(bt in t))
                        throw z("It is not a typed array constructor!");
                    return new t(e);
                },
                Nt = function (t, e) {
                    return It(I(t, t[xt]), e);
                },
                It = function (t, e) {
                    for (var n = 0, r = e.length, s = _t(t, r); r > n; )
                        s[n] = e[n++];
                    return s;
                },
                jt = function (t, e, n) {
                    V(t, e, {
                        get: function () {
                            return this._d[n];
                        },
                    });
                },
                Lt = function (t) {
                    var e,
                        n,
                        r,
                        s,
                        i,
                        o,
                        a = P(t),
                        c = arguments.length,
                        u = c > 1 ? arguments[1] : void 0,
                        h = void 0 !== u,
                        p = C(a);
                    if (null != p && !A(p)) {
                        for (
                            o = p.call(a), r = [], e = 0;
                            !(i = o.next()).done;
                            e++
                        )
                            r.push(i.value);
                        a = r;
                    }
                    for (
                        h && c > 2 && (u = l(u, arguments[2], 2)),
                            e = 0,
                            n = m(a.length),
                            s = _t(this, n);
                        n > e;
                        e++
                    )
                        s[e] = h ? u(a[e], e) : a[e];
                    return s;
                },
                Mt = function () {
                    for (
                        var t = 0, e = arguments.length, n = _t(this, e);
                        e > t;

                    )
                        n[t] = arguments[t++];
                    return n;
                },
                Rt =
                    !!H &&
                    i(function () {
                        yt.call(new H(1));
                    }),
                Dt = function () {
                    return yt.apply(
                        Rt ? ft.call(kt(this)) : kt(this),
                        arguments
                    );
                },
                Ft = {
                    copyWithin: function (t, e) {
                        return F.call(
                            kt(this),
                            t,
                            e,
                            arguments.length > 2 ? arguments[2] : void 0
                        );
                    },
                    every: function (t) {
                        return et(
                            kt(this),
                            t,
                            arguments.length > 1 ? arguments[1] : void 0
                        );
                    },
                    fill: function (t) {
                        return D.apply(kt(this), arguments);
                    },
                    filter: function (t) {
                        return Nt(
                            this,
                            Z(
                                kt(this),
                                t,
                                arguments.length > 1 ? arguments[1] : void 0
                            )
                        );
                    },
                    find: function (t) {
                        return nt(
                            kt(this),
                            t,
                            arguments.length > 1 ? arguments[1] : void 0
                        );
                    },
                    findIndex: function (t) {
                        return rt(
                            kt(this),
                            t,
                            arguments.length > 1 ? arguments[1] : void 0
                        );
                    },
                    forEach: function (t) {
                        Q(
                            kt(this),
                            t,
                            arguments.length > 1 ? arguments[1] : void 0
                        );
                    },
                    indexOf: function (t) {
                        return it(
                            kt(this),
                            t,
                            arguments.length > 1 ? arguments[1] : void 0
                        );
                    },
                    includes: function (t) {
                        return st(
                            kt(this),
                            t,
                            arguments.length > 1 ? arguments[1] : void 0
                        );
                    },
                    join: function (t) {
                        return pt.apply(kt(this), arguments);
                    },
                    lastIndexOf: function (t) {
                        return lt.apply(kt(this), arguments);
                    },
                    map: function (t) {
                        return Tt(
                            kt(this),
                            t,
                            arguments.length > 1 ? arguments[1] : void 0
                        );
                    },
                    reduce: function (t) {
                        return ut.apply(kt(this), arguments);
                    },
                    reduceRight: function (t) {
                        return ht.apply(kt(this), arguments);
                    },
                    reverse: function () {
                        for (
                            var t,
                                e = this,
                                n = kt(e).length,
                                r = Math.floor(n / 2),
                                s = 0;
                            s < r;

                        )
                            (t = e[s]), (e[s++] = e[--n]), (e[n] = t);
                        return e;
                    },
                    some: function (t) {
                        return tt(
                            kt(this),
                            t,
                            arguments.length > 1 ? arguments[1] : void 0
                        );
                    },
                    sort: function (t) {
                        return dt.call(kt(this), t);
                    },
                    subarray: function (t, e) {
                        var n = kt(this),
                            r = n.length,
                            s = g(t, r);
                        return new (I(n, n[xt]))(
                            n.buffer,
                            n.byteOffset + s * n.BYTES_PER_ELEMENT,
                            m((void 0 === e ? r : g(e, r)) - s)
                        );
                    },
                },
                Bt = function (t, e) {
                    return Nt(this, ft.call(kt(this), t, e));
                },
                Ut = function (t) {
                    kt(this);
                    var e = Ot(arguments[1], 1),
                        n = this.length,
                        r = P(t),
                        s = m(r.length),
                        i = 0;
                    if (s + e > n) throw $(Et);
                    for (; i < s; ) this[e + i] = r[i++];
                },
                Vt = {
                    entries: function () {
                        return ct.call(kt(this));
                    },
                    keys: function () {
                        return at.call(kt(this));
                    },
                    values: function () {
                        return ot.call(kt(this));
                    },
                },
                qt = function (t, e) {
                    return (
                        w(t) &&
                        t[Pt] &&
                        "symbol" != typeof e &&
                        e in t &&
                        String(+e) == String(e)
                    );
                },
                $t = function (t, e) {
                    return qt(t, (e = v(e, !0))) ? h(2, t[e]) : q(t, e);
                },
                zt = function (t, e, n) {
                    return !(qt(t, (e = v(e, !0))) && w(n) && b(n, "value")) ||
                        b(n, "get") ||
                        b(n, "set") ||
                        n.configurable ||
                        (b(n, "writable") && !n.writable) ||
                        (b(n, "enumerable") && !n.enumerable)
                        ? V(t, e, n)
                        : ((t[e] = n.value), t);
                };
            wt || ((U.f = $t), (B.f = zt)),
                o(o.S + o.F * !wt, "Object", {
                    getOwnPropertyDescriptor: $t,
                    defineProperty: zt,
                }),
                i(function () {
                    mt.call({});
                }) &&
                    (mt = yt =
                        function () {
                            return pt.call(this);
                        });
            var Ht = d({}, Ft);
            d(Ht, Vt),
                p(Ht, gt, Vt.values),
                d(Ht, {
                    slice: Bt,
                    set: Ut,
                    constructor: function () {},
                    toString: mt,
                    toLocaleString: Dt,
                }),
                jt(Ht, "buffer", "b"),
                jt(Ht, "byteOffset", "o"),
                jt(Ht, "byteLength", "l"),
                jt(Ht, "length", "e"),
                V(Ht, vt, {
                    get: function () {
                        return this[Pt];
                    },
                }),
                (t.exports = function (t, e, n, c) {
                    var l = t + ((c = !!c) ? "Clamped" : "") + "Array",
                        h = "get" + t,
                        d = "set" + t,
                        f = s[l],
                        g = f || {},
                        v = f && T(f),
                        b = !f || !a.ABV,
                        P = {},
                        A = f && f.prototype,
                        C = function (t, n) {
                            V(t, n, {
                                get: function () {
                                    return (function (t, n) {
                                        var r = t._d;
                                        return r.v[h](n * e + r.o, St);
                                    })(this, n);
                                },
                                set: function (t) {
                                    return (function (t, n, r) {
                                        var s = t._d;
                                        c &&
                                            (r =
                                                (r = Math.round(r)) < 0
                                                    ? 0
                                                    : r > 255
                                                    ? 255
                                                    : 255 & r),
                                            s.v[d](n * e + s.o, r, St);
                                    })(this, n, t);
                                },
                                enumerable: !0,
                            });
                        };
                    b
                        ? ((f = n(function (t, n, r, s) {
                              u(t, f, l, "_d");
                              var i,
                                  o,
                                  a,
                                  c,
                                  h = 0,
                                  d = 0;
                              if (w(n)) {
                                  if (
                                      !(
                                          n instanceof X ||
                                          (c = x(n)) == W ||
                                          c == G
                                      )
                                  )
                                      return Pt in n ? It(f, n) : Lt.call(f, n);
                                  (i = n), (d = Ot(r, e));
                                  var g = n.byteLength;
                                  if (void 0 === s) {
                                      if (g % e) throw $(Et);
                                      if ((o = g - d) < 0) throw $(Et);
                                  } else if ((o = m(s) * e) + d > g)
                                      throw $(Et);
                                  a = o / e;
                              } else (a = y(n)), (i = new X((o = a * e)));
                              for (
                                  p(t, "_d", {
                                      b: i,
                                      o: d,
                                      l: o,
                                      e: a,
                                      v: new Y(i),
                                  });
                                  h < a;

                              )
                                  C(t, h++);
                          })),
                          (A = f.prototype = E(Ht)),
                          p(A, "constructor", f))
                        : (i(function () {
                              f(1);
                          }) &&
                              i(function () {
                                  new f(-1);
                              }) &&
                              M(function (t) {
                                  new f(), new f(null), new f(1.5), new f(t);
                              }, !0)) ||
                          ((f = n(function (t, n, r, s) {
                              var i;
                              return (
                                  u(t, f, l),
                                  w(n)
                                      ? n instanceof X ||
                                        (i = x(n)) == W ||
                                        i == G
                                          ? void 0 !== s
                                              ? new g(n, Ot(r, e), s)
                                              : void 0 !== r
                                              ? new g(n, Ot(r, e))
                                              : new g(n)
                                          : Pt in n
                                          ? It(f, n)
                                          : Lt.call(f, n)
                                      : new g(y(n))
                              );
                          })),
                          Q(
                              v !== Function.prototype
                                  ? S(g).concat(S(v))
                                  : S(g),
                              function (t) {
                                  t in f || p(f, t, g[t]);
                              }
                          ),
                          (f.prototype = A),
                          r || (A.constructor = f));
                    var O = A[gt],
                        k = !!O && ("values" == O.name || null == O.name),
                        _ = Vt.values;
                    p(f, bt, !0),
                        p(A, Pt, l),
                        p(A, At, !0),
                        p(A, xt, f),
                        (c ? new f(1)[vt] == l : vt in A) ||
                            V(A, vt, {
                                get: function () {
                                    return l;
                                },
                            }),
                        (P[l] = f),
                        o(o.G + o.W + o.F * (f != g), P),
                        o(o.S, l, { BYTES_PER_ELEMENT: e }),
                        o(
                            o.S +
                                o.F *
                                    i(function () {
                                        g.of.call(f, 1);
                                    }),
                            l,
                            { from: Lt, of: Mt }
                        ),
                        K in A || p(A, K, e),
                        o(o.P, l, Ft),
                        R(l),
                        o(o.P + o.F * Ct, l, { set: Ut }),
                        o(o.P + o.F * !k, l, Vt),
                        r || A.toString == mt || (A.toString = mt),
                        o(
                            o.P +
                                o.F *
                                    i(function () {
                                        new f(1).slice();
                                    }),
                            l,
                            { slice: Bt }
                        ),
                        o(
                            o.P +
                                o.F *
                                    (i(function () {
                                        return (
                                            [1, 2].toLocaleString() !=
                                            new f([1, 2]).toLocaleString()
                                        );
                                    }) ||
                                        !i(function () {
                                            A.toLocaleString.call([1, 2]);
                                        })),
                            l,
                            { toLocaleString: Dt }
                        ),
                        (L[l] = k ? O : _),
                        r || k || p(A, gt, _);
                });
        } else t.exports = function () {};
    },
    function (t, e, n) {
        var r = n(6);
        t.exports = function (t, e) {
            if (!r(t)) return t;
            var n, s;
            if (
                e &&
                "function" == typeof (n = t.toString) &&
                !r((s = n.call(t)))
            )
                return s;
            if ("function" == typeof (n = t.valueOf) && !r((s = n.call(t))))
                return s;
            if (
                !e &&
                "function" == typeof (n = t.toString) &&
                !r((s = n.call(t)))
            )
                return s;
            throw TypeError("Can't convert object to primitive value");
        };
    },
    function (t, e, n) {
        var r = n(33)("meta"),
            s = n(6),
            i = n(16),
            o = n(11).f,
            a = 0,
            c =
                Object.isExtensible ||
                function () {
                    return !0;
                },
            l = !n(4)(function () {
                return c(Object.preventExtensions({}));
            }),
            u = function (t) {
                o(t, r, { value: { i: "O" + ++a, w: {} } });
            },
            h = (t.exports = {
                KEY: r,
                NEED: !1,
                fastKey: function (t, e) {
                    if (!s(t))
                        return "symbol" == typeof t
                            ? t
                            : ("string" == typeof t ? "S" : "P") + t;
                    if (!i(t, r)) {
                        if (!c(t)) return "F";
                        if (!e) return "E";
                        u(t);
                    }
                    return t[r].i;
                },
                getWeak: function (t, e) {
                    if (!i(t, r)) {
                        if (!c(t)) return !0;
                        if (!e) return !1;
                        u(t);
                    }
                    return t[r].w;
                },
                onFreeze: function (t) {
                    return l && h.NEED && c(t) && !i(t, r) && u(t), t;
                },
            });
    },
    function (t, e) {
        t.exports = function (t, e) {
            return {
                enumerable: !(1 & t),
                configurable: !(2 & t),
                writable: !(4 & t),
                value: e,
            };
        };
    },
    function (t, e) {
        var n = 0,
            r = Math.random();
        t.exports = function (t) {
            return "Symbol(".concat(
                void 0 === t ? "" : t,
                ")_",
                (++n + r).toString(36)
            );
        };
    },
    function (t, e) {
        t.exports = !1;
    },
    function (t, e, n) {
        var r = n(95),
            s = n(68);
        t.exports =
            Object.keys ||
            function (t) {
                return r(t, s);
            };
    },
    function (t, e, n) {
        var r = n(23),
            s = Math.max,
            i = Math.min;
        t.exports = function (t, e) {
            return (t = r(t)) < 0 ? s(t + e, 0) : i(t, e);
        };
    },
    function (t, e, n) {
        var r = n(5),
            s = n(96),
            i = n(68),
            o = n(67)("IE_PROTO"),
            a = function () {},
            c = function () {
                var t,
                    e = n(65)("iframe"),
                    r = i.length;
                for (
                    e.style.display = "none",
                        n(69).appendChild(e),
                        e.src = "javascript:",
                        (t = e.contentWindow.document).open(),
                        t.write("<script>document.F=Object</script>"),
                        t.close(),
                        c = t.F;
                    r--;

                )
                    delete c.prototype[i[r]];
                return c();
            };
        t.exports =
            Object.create ||
            function (t, e) {
                var n;
                return (
                    null !== t
                        ? ((a.prototype = r(t)),
                          (n = new a()),
                          (a.prototype = null),
                          (n[o] = t))
                        : (n = c()),
                    void 0 === e ? n : s(n, e)
                );
            };
    },
    function (t, e, n) {
        var r = n(95),
            s = n(68).concat("length", "prototype");
        e.f =
            Object.getOwnPropertyNames ||
            function (t) {
                return r(t, s);
            };
    },
    function (t, e, n) {
        var r = n(16),
            s = n(12),
            i = n(67)("IE_PROTO"),
            o = Object.prototype;
        t.exports =
            Object.getPrototypeOf ||
            function (t) {
                return (
                    (t = s(t)),
                    r(t, i)
                        ? t[i]
                        : "function" == typeof t.constructor &&
                          t instanceof t.constructor
                        ? t.constructor.prototype
                        : t instanceof Object
                        ? o
                        : null
                );
            };
    },
    function (t, e, n) {
        var r = n(7)("unscopables"),
            s = Array.prototype;
        null == s[r] && n(17)(s, r, {}),
            (t.exports = function (t) {
                s[r][t] = !0;
            });
    },
    function (t, e, n) {
        var r = n(6);
        t.exports = function (t, e) {
            if (!r(t) || t._t !== e)
                throw TypeError("Incompatible receiver, " + e + " required!");
            return t;
        };
    },
    function (t, e, n) {
        t.exports = n(359);
    },
    function (t, e, n) {
        var r = n(11).f,
            s = n(16),
            i = n(7)("toStringTag");
        t.exports = function (t, e, n) {
            t &&
                !s((t = n ? t : t.prototype), i) &&
                r(t, i, { configurable: !0, value: e });
        };
    },
    function (t, e, n) {
        var r = n(2),
            s = n(28),
            i = n(4),
            o = n(71),
            a = "[" + o + "]",
            c = RegExp("^" + a + a + "*"),
            l = RegExp(a + a + "*$"),
            u = function (t, e, n) {
                var s = {},
                    a = i(function () {
                        return !!o[t]() || "" != ""[t]();
                    }),
                    c = (s[t] = a ? e(h) : o[t]);
                n && (s[n] = c), r(r.P + r.F * a, "String", s);
            },
            h = (u.trim = function (t, e) {
                return (
                    (t = String(s(t))),
                    1 & e && (t = t.replace(c, "")),
                    2 & e && (t = t.replace(l, "")),
                    t
                );
            });
        t.exports = u;
    },
    function (t, e) {
        t.exports = {};
    },
    function (t, e, n) {
        "use strict";
        var r = n(3),
            s = n(11),
            i = n(10),
            o = n(7)("species");
        t.exports = function (t) {
            var e = r[t];
            i &&
                e &&
                !e[o] &&
                s.f(e, o, {
                    configurable: !0,
                    get: function () {
                        return this;
                    },
                });
        };
    },
    function (t, e) {
        t.exports = function (t, e, n, r) {
            if (!(t instanceof e) || (void 0 !== r && r in t))
                throw TypeError(n + ": incorrect invocation!");
            return t;
        };
    },
    function (t, e, n) {
        var r = n(13);
        t.exports = function (t, e, n) {
            for (var s in e) r(t, s, e[s], n);
            return t;
        };
    },
    function (t, e, n) {
        var r = n(27);
        t.exports = Object("z").propertyIsEnumerable(0)
            ? Object
            : function (t) {
                  return "String" == r(t) ? t.split("") : Object(t);
              };
    },
    function (t, e) {
        e.f = {}.propertyIsEnumerable;
    },
    function (t, e, n) {
        var r = n(27),
            s = n(7)("toStringTag"),
            i =
                "Arguments" ==
                r(
                    (function () {
                        return arguments;
                    })()
                );
        t.exports = function (t) {
            var e, n, o;
            return void 0 === t
                ? "Undefined"
                : null === t
                ? "Null"
                : "string" ==
                  typeof (n = (function (t, e) {
                      try {
                          return t[e];
                      } catch (t) {}
                  })((e = Object(t)), s))
                ? n
                : i
                ? r(e)
                : "Object" == (o = r(e)) && "function" == typeof e.callee
                ? "Arguments"
                : o;
        };
    },
    function (t, e, n) {
        var r = n(5),
            s = n(22),
            i = n(7)("species");
        t.exports = function (t, e) {
            var n,
                o = r(t).constructor;
            return void 0 === o || null == (n = r(o)[i]) ? e : s(n);
        };
    },
    function (t, e, n) {
        var r = n(9),
            s = n(3),
            i = "__core-js_shared__",
            o = s[i] || (s[i] = {});
        (t.exports = function (t, e) {
            return o[t] || (o[t] = void 0 !== e ? e : {});
        })("versions", []).push({
            version: r.version,
            mode: n(34) ? "pure" : "global",
            copyright: " 2019 Denis Pushkarev (zloirock.ru)",
        });
    },
    function (t, e, n) {
        var r = n(18),
            s = n(8),
            i = n(36);
        t.exports = function (t) {
            return function (e, n, o) {
                var a,
                    c = r(e),
                    l = s(c.length),
                    u = i(o, l);
                if (t && n != n) {
                    for (; l > u; ) if ((a = c[u++]) != a) return !0;
                } else
                    for (; l > u; u++)
                        if ((t || u in c) && c[u] === n) return t || u || 0;
                return !t && -1;
            };
        };
    },
    function (t, e) {
        e.f = Object.getOwnPropertySymbols;
    },
    function (t, e, n) {
        var r = n(27);
        t.exports =
            Array.isArray ||
            function (t) {
                return "Array" == r(t);
            };
    },
    function (t, e, n) {
        var r = n(7)("iterator"),
            s = !1;
        try {
            var i = [7][r]();
            (i.return = function () {
                s = !0;
            }),
                Array.from(i, function () {
                    throw 2;
                });
        } catch (t) {}
        t.exports = function (t, e) {
            if (!e && !s) return !1;
            var n = !1;
            try {
                var i = [7],
                    o = i[r]();
                (o.next = function () {
                    return { done: (n = !0) };
                }),
                    (i[r] = function () {
                        return o;
                    }),
                    t(i);
            } catch (t) {}
            return n;
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(5);
        t.exports = function () {
            var t = r(this),
                e = "";
            return (
                t.global && (e += "g"),
                t.ignoreCase && (e += "i"),
                t.multiline && (e += "m"),
                t.unicode && (e += "u"),
                t.sticky && (e += "y"),
                e
            );
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(51),
            s = RegExp.prototype.exec;
        t.exports = function (t, e) {
            var n = t.exec;
            if ("function" == typeof n) {
                var i = n.call(t, e);
                if ("object" != typeof i)
                    throw new TypeError(
                        "RegExp exec method returned something other than an Object or null"
                    );
                return i;
            }
            if ("RegExp" !== r(t))
                throw new TypeError(
                    "RegExp#exec called on incompatible receiver"
                );
            return s.call(t, e);
        };
    },
    function (t, e, n) {
        "use strict";
        n(113);
        var r = n(13),
            s = n(17),
            i = n(4),
            o = n(28),
            a = n(7),
            c = n(86),
            l = a("species"),
            u = !i(function () {
                var t = /./;
                return (
                    (t.exec = function () {
                        var t = [];
                        return (t.groups = { a: "7" }), t;
                    }),
                    "7" !== "".replace(t, "$<a>")
                );
            }),
            h = (function () {
                var t = /(?:)/,
                    e = t.exec;
                t.exec = function () {
                    return e.apply(this, arguments);
                };
                var n = "ab".split(t);
                return 2 === n.length && "a" === n[0] && "b" === n[1];
            })();
        t.exports = function (t, e, n) {
            var p = a(t),
                d = !i(function () {
                    var e = {};
                    return (
                        (e[p] = function () {
                            return 7;
                        }),
                        7 != ""[t](e)
                    );
                }),
                f = d
                    ? !i(function () {
                          var e = !1,
                              n = /a/;
                          return (
                              (n.exec = function () {
                                  return (e = !0), null;
                              }),
                              "split" === t &&
                                  ((n.constructor = {}),
                                  (n.constructor[l] = function () {
                                      return n;
                                  })),
                              n[p](""),
                              !e
                          );
                      })
                    : void 0;
            if (!d || !f || ("replace" === t && !u) || ("split" === t && !h)) {
                var m = /./[p],
                    y = n(o, p, ""[t], function (t, e, n, r, s) {
                        return e.exec === c
                            ? d && !s
                                ? { done: !0, value: m.call(e, n, r) }
                                : { done: !0, value: t.call(n, e, r) }
                            : { done: !1 };
                    }),
                    g = y[0],
                    v = y[1];
                r(String.prototype, t, g),
                    s(
                        RegExp.prototype,
                        p,
                        2 == e
                            ? function (t, e) {
                                  return v.call(t, this, e);
                              }
                            : function (t) {
                                  return v.call(t, this);
                              }
                    );
            }
        };
    },
    function (t, e, n) {
        var r = n(21),
            s = n(108),
            i = n(81),
            o = n(5),
            a = n(8),
            c = n(83),
            l = {},
            u = {};
        ((e = t.exports =
            function (t, e, n, h, p) {
                var d,
                    f,
                    m,
                    y,
                    g = p
                        ? function () {
                              return t;
                          }
                        : c(t),
                    v = r(n, h, e ? 2 : 1),
                    b = 0;
                if ("function" != typeof g)
                    throw TypeError(t + " is not iterable!");
                if (i(g)) {
                    for (d = a(t.length); d > b; b++)
                        if (
                            (y = e ? v(o((f = t[b]))[0], f[1]) : v(t[b])) ===
                                l ||
                            y === u
                        )
                            return y;
                } else
                    for (m = g.call(t); !(f = m.next()).done; )
                        if ((y = s(m, v, f.value, e)) === l || y === u)
                            return y;
            }).BREAK = l),
            (e.RETURN = u);
    },
    function (t, e, n) {
        var r = n(3).navigator;
        t.exports = (r && r.userAgent) || "";
    },
    function (t, e, n) {
        "use strict";
        var r = n(3),
            s = n(2),
            i = n(13),
            o = n(48),
            a = n(31),
            c = n(61),
            l = n(47),
            u = n(6),
            h = n(4),
            p = n(57),
            d = n(43),
            f = n(72);
        t.exports = function (t, e, n, m, y, g) {
            var v = r[t],
                b = v,
                x = y ? "set" : "add",
                w = b && b.prototype,
                P = {},
                A = function (t) {
                    var e = w[t];
                    i(
                        w,
                        t,
                        "delete" == t || "has" == t
                            ? function (t) {
                                  return (
                                      !(g && !u(t)) &&
                                      e.call(this, 0 === t ? 0 : t)
                                  );
                              }
                            : "get" == t
                            ? function (t) {
                                  return g && !u(t)
                                      ? void 0
                                      : e.call(this, 0 === t ? 0 : t);
                              }
                            : "add" == t
                            ? function (t) {
                                  return e.call(this, 0 === t ? 0 : t), this;
                              }
                            : function (t, n) {
                                  return e.call(this, 0 === t ? 0 : t, n), this;
                              }
                    );
                };
            if (
                "function" == typeof b &&
                (g ||
                    (w.forEach &&
                        !h(function () {
                            new b().entries().next();
                        })))
            ) {
                var E = new b(),
                    T = E[x](g ? {} : -0, 1) != E,
                    S = h(function () {
                        E.has(1);
                    }),
                    C = p(function (t) {
                        new b(t);
                    }),
                    O =
                        !g &&
                        h(function () {
                            for (var t = new b(), e = 5; e--; ) t[x](e, e);
                            return !t.has(-0);
                        });
                C ||
                    (((b = e(function (e, n) {
                        l(e, b, t);
                        var r = f(new v(), e, b);
                        return null != n && c(n, y, r[x], r), r;
                    })).prototype = w),
                    (w.constructor = b)),
                    (S || O) && (A("delete"), A("has"), y && A("get")),
                    (O || T) && A(x),
                    g && w.clear && delete w.clear;
            } else
                (b = m.getConstructor(e, t, y, x)),
                    o(b.prototype, n),
                    (a.NEED = !0);
            return (
                d(b, t),
                (P[t] = b),
                s(s.G + s.W + s.F * (b != v), P),
                g || m.setStrong(b, t, y),
                b
            );
        };
    },
    function (t, e, n) {
        for (
            var r,
                s = n(3),
                i = n(17),
                o = n(33),
                a = o("typed_array"),
                c = o("view"),
                l = !(!s.ArrayBuffer || !s.DataView),
                u = l,
                h = 0,
                p =
                    "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(
                        ","
                    );
            h < 9;

        )
            (r = s[p[h++]])
                ? (i(r.prototype, a, !0), i(r.prototype, c, !0))
                : (u = !1);
        t.exports = { ABV: l, CONSTR: u, TYPED: a, VIEW: c };
    },
    function (t, e, n) {
        var r = n(6),
            s = n(3).document,
            i = r(s) && r(s.createElement);
        t.exports = function (t) {
            return i ? s.createElement(t) : {};
        };
    },
    function (t, e, n) {
        e.f = n(7);
    },
    function (t, e, n) {
        var r = n(53)("keys"),
            s = n(33);
        t.exports = function (t) {
            return r[t] || (r[t] = s(t));
        };
    },
    function (t, e) {
        t.exports =
            "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(
                ","
            );
    },
    function (t, e, n) {
        var r = n(3).document;
        t.exports = r && r.documentElement;
    },
    function (t, e, n) {
        var r = n(6),
            s = n(5),
            i = function (t, e) {
                if ((s(t), !r(e) && null !== e))
                    throw TypeError(e + ": can't set as prototype!");
            };
        t.exports = {
            set:
                Object.setPrototypeOf ||
                ("__proto__" in {}
                    ? (function (t, e, r) {
                          try {
                              (r = n(21)(
                                  Function.call,
                                  n(24).f(Object.prototype, "__proto__").set,
                                  2
                              ))(t, []),
                                  (e = !(t instanceof Array));
                          } catch (t) {
                              e = !0;
                          }
                          return function (t, n) {
                              return (
                                  i(t, n), e ? (t.__proto__ = n) : r(t, n), t
                              );
                          };
                      })({}, !1)
                    : void 0),
            check: i,
        };
    },
    function (t, e) {
        t.exports = "\t\n\v\f\r \u2028\u2029\ufeff";
    },
    function (t, e, n) {
        var r = n(6),
            s = n(70).set;
        t.exports = function (t, e, n) {
            var i,
                o = e.constructor;
            return (
                o !== n &&
                    "function" == typeof o &&
                    (i = o.prototype) !== n.prototype &&
                    r(i) &&
                    s &&
                    s(t, i),
                t
            );
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(23),
            s = n(28);
        t.exports = function (t) {
            var e = String(s(this)),
                n = "",
                i = r(t);
            if (i < 0 || i == 1 / 0)
                throw RangeError("Count can't be negative");
            for (; i > 0; (i >>>= 1) && (e += e)) 1 & i && (n += e);
            return n;
        };
    },
    function (t, e) {
        t.exports =
            Math.sign ||
            function (t) {
                return 0 == (t = +t) || t != t ? t : t < 0 ? -1 : 1;
            };
    },
    function (t, e) {
        var n = Math.expm1;
        t.exports =
            !n ||
            n(10) > 22025.465794806718 ||
            n(10) < 22025.465794806718 ||
            -2e-17 != n(-2e-17)
                ? function (t) {
                      return 0 == (t = +t)
                          ? t
                          : t > -1e-6 && t < 1e-6
                          ? t + (t * t) / 2
                          : Math.exp(t) - 1;
                  }
                : n;
    },
    function (t, e, n) {
        var r = n(23),
            s = n(28);
        t.exports = function (t) {
            return function (e, n) {
                var i,
                    o,
                    a = String(s(e)),
                    c = r(n),
                    l = a.length;
                return c < 0 || c >= l
                    ? t
                        ? ""
                        : void 0
                    : (i = a.charCodeAt(c)) < 55296 ||
                      i > 56319 ||
                      c + 1 === l ||
                      (o = a.charCodeAt(c + 1)) < 56320 ||
                      o > 57343
                    ? t
                        ? a.charAt(c)
                        : i
                    : t
                    ? a.slice(c, c + 2)
                    : o - 56320 + ((i - 55296) << 10) + 65536;
            };
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(34),
            s = n(2),
            i = n(13),
            o = n(17),
            a = n(45),
            c = n(107),
            l = n(43),
            u = n(39),
            h = n(7)("iterator"),
            p = !([].keys && "next" in [].keys()),
            d = "keys",
            f = "values",
            m = function () {
                return this;
            };
        t.exports = function (t, e, n, y, g, v, b) {
            c(n, e, y);
            var x,
                w,
                P,
                A = function (t) {
                    if (!p && t in C) return C[t];
                    switch (t) {
                        case d:
                        case f:
                            return function () {
                                return new n(this, t);
                            };
                    }
                    return function () {
                        return new n(this, t);
                    };
                },
                E = e + " Iterator",
                T = g == f,
                S = !1,
                C = t.prototype,
                O = C[h] || C["@@iterator"] || (g && C[g]),
                k = O || A(g),
                _ = g ? (T ? A("entries") : k) : void 0,
                N = ("Array" == e && C.entries) || O;
            if (
                (N &&
                    (P = u(N.call(new t()))) !== Object.prototype &&
                    P.next &&
                    (l(P, E, !0), r || "function" == typeof P[h] || o(P, h, m)),
                T &&
                    O &&
                    O.name !== f &&
                    ((S = !0),
                    (k = function () {
                        return O.call(this);
                    })),
                (r && !b) || (!p && !S && C[h]) || o(C, h, k),
                (a[e] = k),
                (a[E] = m),
                g)
            )
                if (
                    ((x = {
                        values: T ? k : A(f),
                        keys: v ? k : A(d),
                        entries: _,
                    }),
                    b)
                )
                    for (w in x) w in C || i(C, w, x[w]);
                else s(s.P + s.F * (p || S), e, x);
            return x;
        };
    },
    function (t, e, n) {
        var r = n(79),
            s = n(28);
        t.exports = function (t, e, n) {
            if (r(e)) throw TypeError("String#" + n + " doesn't accept regex!");
            return String(s(t));
        };
    },
    function (t, e, n) {
        var r = n(6),
            s = n(27),
            i = n(7)("match");
        t.exports = function (t) {
            var e;
            return r(t) && (void 0 !== (e = t[i]) ? !!e : "RegExp" == s(t));
        };
    },
    function (t, e, n) {
        var r = n(7)("match");
        t.exports = function (t) {
            var e = /./;
            try {
                "/./"[t](e);
            } catch (n) {
                try {
                    return (e[r] = !1), !"/./"[t](e);
                } catch (t) {}
            }
            return !0;
        };
    },
    function (t, e, n) {
        var r = n(45),
            s = n(7)("iterator"),
            i = Array.prototype;
        t.exports = function (t) {
            return void 0 !== t && (r.Array === t || i[s] === t);
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(11),
            s = n(32);
        t.exports = function (t, e, n) {
            e in t ? r.f(t, e, s(0, n)) : (t[e] = n);
        };
    },
    function (t, e, n) {
        var r = n(51),
            s = n(7)("iterator"),
            i = n(45);
        t.exports = n(9).getIteratorMethod = function (t) {
            if (null != t) return t[s] || t["@@iterator"] || i[r(t)];
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(12),
            s = n(36),
            i = n(8);
        t.exports = function (t) {
            for (
                var e = r(this),
                    n = i(e.length),
                    o = arguments.length,
                    a = s(o > 1 ? arguments[1] : void 0, n),
                    c = o > 2 ? arguments[2] : void 0,
                    l = void 0 === c ? n : s(c, n);
                l > a;

            )
                e[a++] = t;
            return e;
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(40),
            s = n(112),
            i = n(45),
            o = n(18);
        (t.exports = n(77)(
            Array,
            "Array",
            function (t, e) {
                (this._t = o(t)), (this._i = 0), (this._k = e);
            },
            function () {
                var t = this._t,
                    e = this._k,
                    n = this._i++;
                return !t || n >= t.length
                    ? ((this._t = void 0), s(1))
                    : s(0, "keys" == e ? n : "values" == e ? t[n] : [n, t[n]]);
            },
            "values"
        )),
            (i.Arguments = i.Array),
            r("keys"),
            r("values"),
            r("entries");
    },
    function (t, e, n) {
        "use strict";
        var r,
            s,
            i = n(58),
            o = RegExp.prototype.exec,
            a = String.prototype.replace,
            c = o,
            l =
                ((r = /a/),
                (s = /b*/g),
                o.call(r, "a"),
                o.call(s, "a"),
                0 !== r.lastIndex || 0 !== s.lastIndex),
            u = void 0 !== /()??/.exec("")[1];
        (l || u) &&
            (c = function (t) {
                var e,
                    n,
                    r,
                    s,
                    c = this;
                return (
                    u &&
                        (n = new RegExp(
                            "^" + c.source + "$(?!\\s)",
                            i.call(c)
                        )),
                    l && (e = c.lastIndex),
                    (r = o.call(c, t)),
                    l &&
                        r &&
                        (c.lastIndex = c.global ? r.index + r[0].length : e),
                    u &&
                        r &&
                        r.length > 1 &&
                        a.call(r[0], n, function () {
                            for (s = 1; s < arguments.length - 2; s++)
                                void 0 === arguments[s] && (r[s] = void 0);
                        }),
                    r
                );
            }),
            (t.exports = c);
    },
    function (t, e, n) {
        "use strict";
        var r = n(76)(!0);
        t.exports = function (t, e, n) {
            return e + (n ? r(t, e).length : 1);
        };
    },
    function (t, e, n) {
        var r,
            s,
            i,
            o = n(21),
            a = n(101),
            c = n(69),
            l = n(65),
            u = n(3),
            h = u.process,
            p = u.setImmediate,
            d = u.clearImmediate,
            f = u.MessageChannel,
            m = u.Dispatch,
            y = 0,
            g = {},
            v = "onreadystatechange",
            b = function () {
                var t = +this;
                if (g.hasOwnProperty(t)) {
                    var e = g[t];
                    delete g[t], e();
                }
            },
            x = function (t) {
                b.call(t.data);
            };
        (p && d) ||
            ((p = function (t) {
                for (var e = [], n = 1; arguments.length > n; )
                    e.push(arguments[n++]);
                return (
                    (g[++y] = function () {
                        a("function" == typeof t ? t : Function(t), e);
                    }),
                    r(y),
                    y
                );
            }),
            (d = function (t) {
                delete g[t];
            }),
            "process" == n(27)(h)
                ? (r = function (t) {
                      h.nextTick(o(b, t, 1));
                  })
                : m && m.now
                ? (r = function (t) {
                      m.now(o(b, t, 1));
                  })
                : f
                ? ((i = (s = new f()).port2),
                  (s.port1.onmessage = x),
                  (r = o(i.postMessage, i, 1)))
                : u.addEventListener &&
                  "function" == typeof postMessage &&
                  !u.importScripts
                ? ((r = function (t) {
                      u.postMessage(t + "", "*");
                  }),
                  u.addEventListener("message", x, !1))
                : (r =
                      v in l("script")
                          ? function (t) {
                                c.appendChild(l("script")).onreadystatechange =
                                    function () {
                                        c.removeChild(this), b.call(t);
                                    };
                            }
                          : function (t) {
                                setTimeout(o(b, t, 1), 0);
                            })),
            (t.exports = { set: p, clear: d });
    },
    function (t, e, n) {
        "use strict";
        var r = n(3),
            s = n(10),
            i = n(34),
            o = n(64),
            a = n(17),
            c = n(48),
            l = n(4),
            u = n(47),
            h = n(23),
            p = n(8),
            d = n(120),
            f = n(38).f,
            m = n(11).f,
            y = n(84),
            g = n(43),
            v = "ArrayBuffer",
            b = "DataView",
            x = "Wrong index!",
            w = r.ArrayBuffer,
            P = r.DataView,
            A = r.Math,
            E = r.RangeError,
            T = r.Infinity,
            S = w,
            C = A.abs,
            O = A.pow,
            k = A.floor,
            _ = A.log,
            N = A.LN2,
            I = "buffer",
            j = "byteLength",
            L = "byteOffset",
            M = s ? "_b" : I,
            R = s ? "_l" : j,
            D = s ? "_o" : L;
        function F(t, e, n) {
            var r,
                s,
                i,
                o = new Array(n),
                a = 8 * n - e - 1,
                c = (1 << a) - 1,
                l = c >> 1,
                u = 23 === e ? O(2, -24) - O(2, -77) : 0,
                h = 0,
                p = t < 0 || (0 === t && 1 / t < 0) ? 1 : 0;
            for (
                (t = C(t)) != t || t === T
                    ? ((s = t != t ? 1 : 0), (r = c))
                    : ((r = k(_(t) / N)),
                      t * (i = O(2, -r)) < 1 && (r--, (i *= 2)),
                      (t += r + l >= 1 ? u / i : u * O(2, 1 - l)) * i >= 2 &&
                          (r++, (i /= 2)),
                      r + l >= c
                          ? ((s = 0), (r = c))
                          : r + l >= 1
                          ? ((s = (t * i - 1) * O(2, e)), (r += l))
                          : ((s = t * O(2, l - 1) * O(2, e)), (r = 0)));
                e >= 8;
                o[h++] = 255 & s, s /= 256, e -= 8
            );
            for (
                r = (r << e) | s, a += e;
                a > 0;
                o[h++] = 255 & r, r /= 256, a -= 8
            );
            return (o[--h] |= 128 * p), o;
        }
        function B(t, e, n) {
            var r,
                s = 8 * n - e - 1,
                i = (1 << s) - 1,
                o = i >> 1,
                a = s - 7,
                c = n - 1,
                l = t[c--],
                u = 127 & l;
            for (l >>= 7; a > 0; u = 256 * u + t[c], c--, a -= 8);
            for (
                r = u & ((1 << -a) - 1), u >>= -a, a += e;
                a > 0;
                r = 256 * r + t[c], c--, a -= 8
            );
            if (0 === u) u = 1 - o;
            else {
                if (u === i) return r ? NaN : l ? -T : T;
                (r += O(2, e)), (u -= o);
            }
            return (l ? -1 : 1) * r * O(2, u - e);
        }
        function U(t) {
            return (t[3] << 24) | (t[2] << 16) | (t[1] << 8) | t[0];
        }
        function V(t) {
            return [255 & t];
        }
        function q(t) {
            return [255 & t, (t >> 8) & 255];
        }
        function $(t) {
            return [255 & t, (t >> 8) & 255, (t >> 16) & 255, (t >> 24) & 255];
        }
        function z(t) {
            return F(t, 52, 8);
        }
        function H(t) {
            return F(t, 23, 4);
        }
        function W(t, e, n) {
            m(t.prototype, e, {
                get: function () {
                    return this[n];
                },
            });
        }
        function G(t, e, n, r) {
            var s = d(+n);
            if (s + e > t[R]) throw E(x);
            var i = t[M]._b,
                o = s + t[D],
                a = i.slice(o, o + e);
            return r ? a : a.reverse();
        }
        function K(t, e, n, r, s, i) {
            var o = d(+n);
            if (o + e > t[R]) throw E(x);
            for (var a = t[M]._b, c = o + t[D], l = r(+s), u = 0; u < e; u++)
                a[c + u] = l[i ? u : e - u - 1];
        }
        if (o.ABV) {
            if (
                !l(function () {
                    w(1);
                }) ||
                !l(function () {
                    new w(-1);
                }) ||
                l(function () {
                    return new w(), new w(1.5), new w(NaN), w.name != v;
                })
            ) {
                for (
                    var J,
                        X = ((w = function (t) {
                            return u(this, w), new S(d(t));
                        }).prototype = S.prototype),
                        Y = f(S),
                        Q = 0;
                    Y.length > Q;

                )
                    (J = Y[Q++]) in w || a(w, J, S[J]);
                i || (X.constructor = w);
            }
            var Z = new P(new w(2)),
                tt = P.prototype.setInt8;
            Z.setInt8(0, 2147483648),
                Z.setInt8(1, 2147483649),
                (!Z.getInt8(0) && Z.getInt8(1)) ||
                    c(
                        P.prototype,
                        {
                            setInt8: function (t, e) {
                                tt.call(this, t, (e << 24) >> 24);
                            },
                            setUint8: function (t, e) {
                                tt.call(this, t, (e << 24) >> 24);
                            },
                        },
                        !0
                    );
        } else
            (w = function (t) {
                u(this, w, v);
                var e = d(t);
                (this._b = y.call(new Array(e), 0)), (this[R] = e);
            }),
                (P = function (t, e, n) {
                    u(this, P, b), u(t, w, b);
                    var r = t[R],
                        s = h(e);
                    if (s < 0 || s > r) throw E("Wrong offset!");
                    if (s + (n = void 0 === n ? r - s : p(n)) > r)
                        throw E("Wrong length!");
                    (this[M] = t), (this[D] = s), (this[R] = n);
                }),
                s &&
                    (W(w, j, "_l"),
                    W(P, I, "_b"),
                    W(P, j, "_l"),
                    W(P, L, "_o")),
                c(P.prototype, {
                    getInt8: function (t) {
                        return (G(this, 1, t)[0] << 24) >> 24;
                    },
                    getUint8: function (t) {
                        return G(this, 1, t)[0];
                    },
                    getInt16: function (t) {
                        var e = G(this, 2, t, arguments[1]);
                        return (((e[1] << 8) | e[0]) << 16) >> 16;
                    },
                    getUint16: function (t) {
                        var e = G(this, 2, t, arguments[1]);
                        return (e[1] << 8) | e[0];
                    },
                    getInt32: function (t) {
                        return U(G(this, 4, t, arguments[1]));
                    },
                    getUint32: function (t) {
                        return U(G(this, 4, t, arguments[1])) >>> 0;
                    },
                    getFloat32: function (t) {
                        return B(G(this, 4, t, arguments[1]), 23, 4);
                    },
                    getFloat64: function (t) {
                        return B(G(this, 8, t, arguments[1]), 52, 8);
                    },
                    setInt8: function (t, e) {
                        K(this, 1, t, V, e);
                    },
                    setUint8: function (t, e) {
                        K(this, 1, t, V, e);
                    },
                    setInt16: function (t, e) {
                        K(this, 2, t, q, e, arguments[2]);
                    },
                    setUint16: function (t, e) {
                        K(this, 2, t, q, e, arguments[2]);
                    },
                    setInt32: function (t, e) {
                        K(this, 4, t, $, e, arguments[2]);
                    },
                    setUint32: function (t, e) {
                        K(this, 4, t, $, e, arguments[2]);
                    },
                    setFloat32: function (t, e) {
                        K(this, 4, t, H, e, arguments[2]);
                    },
                    setFloat64: function (t, e) {
                        K(this, 8, t, z, e, arguments[2]);
                    },
                });
        g(w, v),
            g(P, b),
            a(P.prototype, o.VIEW, !0),
            (e.ArrayBuffer = w),
            (e.DataView = P);
    },
    function (t, e) {
        var n = (t.exports =
            "undefined" != typeof window && window.Math == Math
                ? window
                : "undefined" != typeof self && self.Math == Math
                ? self
                : Function("return this")());
        "number" == typeof __g && (__g = n);
    },
    function (t, e) {
        t.exports = function (t) {
            return "object" == typeof t ? null !== t : "function" == typeof t;
        };
    },
    function (t, e, n) {
        t.exports = !n(125)(function () {
            return (
                7 !=
                Object.defineProperty({}, "a", {
                    get: function () {
                        return 7;
                    },
                }).a
            );
        });
    },
    function (t, e, n) {
        t.exports =
            !n(10) &&
            !n(4)(function () {
                return (
                    7 !=
                    Object.defineProperty(n(65)("div"), "a", {
                        get: function () {
                            return 7;
                        },
                    }).a
                );
            });
    },
    function (t, e, n) {
        var r = n(3),
            s = n(9),
            i = n(34),
            o = n(66),
            a = n(11).f;
        t.exports = function (t) {
            var e = s.Symbol || (s.Symbol = i ? {} : r.Symbol || {});
            "_" == t.charAt(0) || t in e || a(e, t, { value: o.f(t) });
        };
    },
    function (t, e, n) {
        var r = n(16),
            s = n(18),
            i = n(54)(!1),
            o = n(67)("IE_PROTO");
        t.exports = function (t, e) {
            var n,
                a = s(t),
                c = 0,
                l = [];
            for (n in a) n != o && r(a, n) && l.push(n);
            for (; e.length > c; )
                r(a, (n = e[c++])) && (~i(l, n) || l.push(n));
            return l;
        };
    },
    function (t, e, n) {
        var r = n(11),
            s = n(5),
            i = n(35);
        t.exports = n(10)
            ? Object.defineProperties
            : function (t, e) {
                  s(t);
                  for (var n, o = i(e), a = o.length, c = 0; a > c; )
                      r.f(t, (n = o[c++]), e[n]);
                  return t;
              };
    },
    function (t, e, n) {
        var r = n(18),
            s = n(38).f,
            i = {}.toString,
            o =
                "object" == typeof window &&
                window &&
                Object.getOwnPropertyNames
                    ? Object.getOwnPropertyNames(window)
                    : [];
        t.exports.f = function (t) {
            return o && "[object Window]" == i.call(t)
                ? (function (t) {
                      try {
                          return s(t);
                      } catch (t) {
                          return o.slice();
                      }
                  })(t)
                : s(r(t));
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(10),
            s = n(35),
            i = n(55),
            o = n(50),
            a = n(12),
            c = n(49),
            l = Object.assign;
        t.exports =
            !l ||
            n(4)(function () {
                var t = {},
                    e = {},
                    n = Symbol(),
                    r = "abcdefghijklmnopqrst";
                return (
                    (t[n] = 7),
                    r.split("").forEach(function (t) {
                        e[t] = t;
                    }),
                    7 != l({}, t)[n] || Object.keys(l({}, e)).join("") != r
                );
            })
                ? function (t, e) {
                      for (
                          var n = a(t),
                              l = arguments.length,
                              u = 1,
                              h = i.f,
                              p = o.f;
                          l > u;

                      )
                          for (
                              var d,
                                  f = c(arguments[u++]),
                                  m = h ? s(f).concat(h(f)) : s(f),
                                  y = m.length,
                                  g = 0;
                              y > g;

                          )
                              (d = m[g++]),
                                  (r && !p.call(f, d)) || (n[d] = f[d]);
                      return n;
                  }
                : l;
    },
    function (t, e) {
        t.exports =
            Object.is ||
            function (t, e) {
                return t === e ? 0 !== t || 1 / t == 1 / e : t != t && e != e;
            };
    },
    function (t, e, n) {
        "use strict";
        var r = n(22),
            s = n(6),
            i = n(101),
            o = [].slice,
            a = {},
            c = function (t, e, n) {
                if (!(e in a)) {
                    for (var r = [], s = 0; s < e; s++) r[s] = "a[" + s + "]";
                    a[e] = Function("F,a", "return new F(" + r.join(",") + ")");
                }
                return a[e](t, n);
            };
        t.exports =
            Function.bind ||
            function (t) {
                var e = r(this),
                    n = o.call(arguments, 1),
                    a = function () {
                        var r = n.concat(o.call(arguments));
                        return this instanceof a
                            ? c(e, r.length, r)
                            : i(e, r, t);
                    };
                return s(e.prototype) && (a.prototype = e.prototype), a;
            };
    },
    function (t, e) {
        t.exports = function (t, e, n) {
            var r = void 0 === n;
            switch (e.length) {
                case 0:
                    return r ? t() : t.call(n);
                case 1:
                    return r ? t(e[0]) : t.call(n, e[0]);
                case 2:
                    return r ? t(e[0], e[1]) : t.call(n, e[0], e[1]);
                case 3:
                    return r
                        ? t(e[0], e[1], e[2])
                        : t.call(n, e[0], e[1], e[2]);
                case 4:
                    return r
                        ? t(e[0], e[1], e[2], e[3])
                        : t.call(n, e[0], e[1], e[2], e[3]);
            }
            return t.apply(n, e);
        };
    },
    function (t, e, n) {
        var r = n(3).parseInt,
            s = n(44).trim,
            i = n(71),
            o = /^[-+]?0[xX]/;
        t.exports =
            8 !== r(i + "08") || 22 !== r(i + "0x16")
                ? function (t, e) {
                      var n = s(String(t), 3);
                      return r(n, e >>> 0 || (o.test(n) ? 16 : 10));
                  }
                : r;
    },
    function (t, e, n) {
        var r = n(3).parseFloat,
            s = n(44).trim;
        t.exports =
            1 / r(n(71) + "-0") != -1 / 0
                ? function (t) {
                      var e = s(String(t), 3),
                          n = r(e);
                      return 0 === n && "-" == e.charAt(0) ? -0 : n;
                  }
                : r;
    },
    function (t, e, n) {
        var r = n(27);
        t.exports = function (t, e) {
            if ("number" != typeof t && "Number" != r(t)) throw TypeError(e);
            return +t;
        };
    },
    function (t, e, n) {
        var r = n(6),
            s = Math.floor;
        t.exports = function (t) {
            return !r(t) && isFinite(t) && s(t) === t;
        };
    },
    function (t, e) {
        t.exports =
            Math.log1p ||
            function (t) {
                return (t = +t) > -1e-8 && t < 1e-8
                    ? t - (t * t) / 2
                    : Math.log(1 + t);
            };
    },
    function (t, e, n) {
        "use strict";
        var r = n(37),
            s = n(32),
            i = n(43),
            o = {};
        n(17)(o, n(7)("iterator"), function () {
            return this;
        }),
            (t.exports = function (t, e, n) {
                (t.prototype = r(o, { next: s(1, n) })), i(t, e + " Iterator");
            });
    },
    function (t, e, n) {
        var r = n(5);
        t.exports = function (t, e, n, s) {
            try {
                return s ? e(r(n)[0], n[1]) : e(n);
            } catch (e) {
                var i = t.return;
                throw (void 0 !== i && r(i.call(t)), e);
            }
        };
    },
    function (t, e, n) {
        var r = n(263);
        t.exports = function (t, e) {
            return new (r(t))(e);
        };
    },
    function (t, e, n) {
        var r = n(22),
            s = n(12),
            i = n(49),
            o = n(8);
        t.exports = function (t, e, n, a, c) {
            r(e);
            var l = s(t),
                u = i(l),
                h = o(l.length),
                p = c ? h - 1 : 0,
                d = c ? -1 : 1;
            if (n < 2)
                for (;;) {
                    if (p in u) {
                        (a = u[p]), (p += d);
                        break;
                    }
                    if (((p += d), c ? p < 0 : h <= p))
                        throw TypeError(
                            "Reduce of empty array with no initial value"
                        );
                }
            for (; c ? p >= 0 : h > p; p += d) p in u && (a = e(a, u[p], p, l));
            return a;
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(12),
            s = n(36),
            i = n(8);
        t.exports =
            [].copyWithin ||
            function (t, e) {
                var n = r(this),
                    o = i(n.length),
                    a = s(t, o),
                    c = s(e, o),
                    l = arguments.length > 2 ? arguments[2] : void 0,
                    u = Math.min((void 0 === l ? o : s(l, o)) - c, o - a),
                    h = 1;
                for (
                    c < a &&
                    a < c + u &&
                    ((h = -1), (c += u - 1), (a += u - 1));
                    u-- > 0;

                )
                    c in n ? (n[a] = n[c]) : delete n[a], (a += h), (c += h);
                return n;
            };
    },
    function (t, e) {
        t.exports = function (t, e) {
            return { value: e, done: !!t };
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(86);
        n(2)(
            { target: "RegExp", proto: !0, forced: r !== /./.exec },
            { exec: r }
        );
    },
    function (t, e, n) {
        n(10) &&
            "g" != /./g.flags &&
            n(11).f(RegExp.prototype, "flags", {
                configurable: !0,
                get: n(58),
            });
    },
    function (t, e, n) {
        "use strict";
        var r,
            s,
            i,
            o,
            a = n(34),
            c = n(3),
            l = n(21),
            u = n(51),
            h = n(2),
            p = n(6),
            d = n(22),
            f = n(47),
            m = n(61),
            y = n(52),
            g = n(88).set,
            v = n(283)(),
            b = n(116),
            x = n(284),
            w = n(62),
            P = n(117),
            A = "Promise",
            E = c.TypeError,
            T = c.process,
            S = T && T.versions,
            C = (S && S.v8) || "",
            O = c.Promise,
            k = "process" == u(T),
            _ = function () {},
            N = (s = b.f),
            I = !!(function () {
                try {
                    var t = O.resolve(1),
                        e = ((t.constructor = {})[n(7)("species")] = function (
                            t
                        ) {
                            t(_, _);
                        });
                    return (
                        (k || "function" == typeof PromiseRejectionEvent) &&
                        t.then(_) instanceof e &&
                        0 !== C.indexOf("6.6") &&
                        -1 === w.indexOf("Chrome/66")
                    );
                } catch (t) {}
            })(),
            j = function (t) {
                var e;
                return !(!p(t) || "function" != typeof (e = t.then)) && e;
            },
            L = function (t, e) {
                if (!t._n) {
                    t._n = !0;
                    var n = t._c;
                    v(function () {
                        for (
                            var r = t._v,
                                s = 1 == t._s,
                                i = 0,
                                o = function (e) {
                                    var n,
                                        i,
                                        o,
                                        a = s ? e.ok : e.fail,
                                        c = e.resolve,
                                        l = e.reject,
                                        u = e.domain;
                                    try {
                                        a
                                            ? (s ||
                                                  (2 == t._h && D(t),
                                                  (t._h = 1)),
                                              !0 === a
                                                  ? (n = r)
                                                  : (u && u.enter(),
                                                    (n = a(r)),
                                                    u && (u.exit(), (o = !0))),
                                              n === e.promise
                                                  ? l(E("Promise-chain cycle"))
                                                  : (i = j(n))
                                                  ? i.call(n, c, l)
                                                  : c(n))
                                            : l(r);
                                    } catch (t) {
                                        u && !o && u.exit(), l(t);
                                    }
                                };
                            n.length > i;

                        )
                            o(n[i++]);
                        (t._c = []), (t._n = !1), e && !t._h && M(t);
                    });
                }
            },
            M = function (t) {
                g.call(c, function () {
                    var e,
                        n,
                        r,
                        s = t._v,
                        i = R(t);
                    if (
                        (i &&
                            ((e = x(function () {
                                k
                                    ? T.emit("unhandledRejection", s, t)
                                    : (n = c.onunhandledrejection)
                                    ? n({ promise: t, reason: s })
                                    : (r = c.console) &&
                                      r.error &&
                                      r.error("Unhandled promise rejection", s);
                            })),
                            (t._h = k || R(t) ? 2 : 1)),
                        (t._a = void 0),
                        i && e.e)
                    )
                        throw e.v;
                });
            },
            R = function (t) {
                return 1 !== t._h && 0 === (t._a || t._c).length;
            },
            D = function (t) {
                g.call(c, function () {
                    var e;
                    k
                        ? T.emit("rejectionHandled", t)
                        : (e = c.onrejectionhandled) &&
                          e({ promise: t, reason: t._v });
                });
            },
            F = function (t) {
                var e = this;
                e._d ||
                    ((e._d = !0),
                    ((e = e._w || e)._v = t),
                    (e._s = 2),
                    e._a || (e._a = e._c.slice()),
                    L(e, !0));
            },
            B = function (t) {
                var e,
                    n = this;
                if (!n._d) {
                    (n._d = !0), (n = n._w || n);
                    try {
                        if (n === t)
                            throw E("Promise can't be resolved itself");
                        (e = j(t))
                            ? v(function () {
                                  var r = { _w: n, _d: !1 };
                                  try {
                                      e.call(t, l(B, r, 1), l(F, r, 1));
                                  } catch (t) {
                                      F.call(r, t);
                                  }
                              })
                            : ((n._v = t), (n._s = 1), L(n, !1));
                    } catch (t) {
                        F.call({ _w: n, _d: !1 }, t);
                    }
                }
            };
        I ||
            ((O = function (t) {
                f(this, O, A, "_h"), d(t), r.call(this);
                try {
                    t(l(B, this, 1), l(F, this, 1));
                } catch (t) {
                    F.call(this, t);
                }
            }),
            ((r = function (t) {
                (this._c = []),
                    (this._a = void 0),
                    (this._s = 0),
                    (this._d = !1),
                    (this._v = void 0),
                    (this._h = 0),
                    (this._n = !1);
            }).prototype = n(48)(O.prototype, {
                then: function (t, e) {
                    var n = N(y(this, O));
                    return (
                        (n.ok = "function" != typeof t || t),
                        (n.fail = "function" == typeof e && e),
                        (n.domain = k ? T.domain : void 0),
                        this._c.push(n),
                        this._a && this._a.push(n),
                        this._s && L(this, !1),
                        n.promise
                    );
                },
                catch: function (t) {
                    return this.then(void 0, t);
                },
            })),
            (i = function () {
                var t = new r();
                (this.promise = t),
                    (this.resolve = l(B, t, 1)),
                    (this.reject = l(F, t, 1));
            }),
            (b.f = N =
                function (t) {
                    return t === O || t === o ? new i(t) : s(t);
                })),
            h(h.G + h.W + h.F * !I, { Promise: O }),
            n(43)(O, A),
            n(46)(A),
            (o = n(9).Promise),
            h(h.S + h.F * !I, A, {
                reject: function (t) {
                    var e = N(this);
                    return (0, e.reject)(t), e.promise;
                },
            }),
            h(h.S + h.F * (a || !I), A, {
                resolve: function (t) {
                    return P(a && this === o ? O : this, t);
                },
            }),
            h(
                h.S +
                    h.F *
                        !(
                            I &&
                            n(57)(function (t) {
                                O.all(t).catch(_);
                            })
                        ),
                A,
                {
                    all: function (t) {
                        var e = this,
                            n = N(e),
                            r = n.resolve,
                            s = n.reject,
                            i = x(function () {
                                var n = [],
                                    i = 0,
                                    o = 1;
                                m(t, !1, function (t) {
                                    var a = i++,
                                        c = !1;
                                    n.push(void 0),
                                        o++,
                                        e.resolve(t).then(function (t) {
                                            c ||
                                                ((c = !0),
                                                (n[a] = t),
                                                --o || r(n));
                                        }, s);
                                }),
                                    --o || r(n);
                            });
                        return i.e && s(i.v), n.promise;
                    },
                    race: function (t) {
                        var e = this,
                            n = N(e),
                            r = n.reject,
                            s = x(function () {
                                m(t, !1, function (t) {
                                    e.resolve(t).then(n.resolve, r);
                                });
                            });
                        return s.e && r(s.v), n.promise;
                    },
                }
            );
    },
    function (t, e, n) {
        "use strict";
        var r = n(22);
        function s(t) {
            var e, n;
            (this.promise = new t(function (t, r) {
                if (void 0 !== e || void 0 !== n)
                    throw TypeError("Bad Promise constructor");
                (e = t), (n = r);
            })),
                (this.resolve = r(e)),
                (this.reject = r(n));
        }
        t.exports.f = function (t) {
            return new s(t);
        };
    },
    function (t, e, n) {
        var r = n(5),
            s = n(6),
            i = n(116);
        t.exports = function (t, e) {
            if ((r(t), s(e) && e.constructor === t)) return e;
            var n = i.f(t);
            return (0, n.resolve)(e), n.promise;
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(11).f,
            s = n(37),
            i = n(48),
            o = n(21),
            a = n(47),
            c = n(61),
            l = n(77),
            u = n(112),
            h = n(46),
            p = n(10),
            d = n(31).fastKey,
            f = n(41),
            m = p ? "_s" : "size",
            y = function (t, e) {
                var n,
                    r = d(e);
                if ("F" !== r) return t._i[r];
                for (n = t._f; n; n = n.n) if (n.k == e) return n;
            };
        t.exports = {
            getConstructor: function (t, e, n, l) {
                var u = t(function (t, r) {
                    a(t, u, e, "_i"),
                        (t._t = e),
                        (t._i = s(null)),
                        (t._f = void 0),
                        (t._l = void 0),
                        (t[m] = 0),
                        null != r && c(r, n, t[l], t);
                });
                return (
                    i(u.prototype, {
                        clear: function () {
                            for (
                                var t = f(this, e), n = t._i, r = t._f;
                                r;
                                r = r.n
                            )
                                (r.r = !0),
                                    r.p && (r.p = r.p.n = void 0),
                                    delete n[r.i];
                            (t._f = t._l = void 0), (t[m] = 0);
                        },
                        delete: function (t) {
                            var n = f(this, e),
                                r = y(n, t);
                            if (r) {
                                var s = r.n,
                                    i = r.p;
                                delete n._i[r.i],
                                    (r.r = !0),
                                    i && (i.n = s),
                                    s && (s.p = i),
                                    n._f == r && (n._f = s),
                                    n._l == r && (n._l = i),
                                    n[m]--;
                            }
                            return !!r;
                        },
                        forEach: function (t) {
                            f(this, e);
                            for (
                                var n,
                                    r = o(
                                        t,
                                        arguments.length > 1
                                            ? arguments[1]
                                            : void 0,
                                        3
                                    );
                                (n = n ? n.n : this._f);

                            )
                                for (r(n.v, n.k, this); n && n.r; ) n = n.p;
                        },
                        has: function (t) {
                            return !!y(f(this, e), t);
                        },
                    }),
                    p &&
                        r(u.prototype, "size", {
                            get: function () {
                                return f(this, e)[m];
                            },
                        }),
                    u
                );
            },
            def: function (t, e, n) {
                var r,
                    s,
                    i = y(t, e);
                return (
                    i
                        ? (i.v = n)
                        : ((t._l = i =
                              {
                                  i: (s = d(e, !0)),
                                  k: e,
                                  v: n,
                                  p: (r = t._l),
                                  n: void 0,
                                  r: !1,
                              }),
                          t._f || (t._f = i),
                          r && (r.n = i),
                          t[m]++,
                          "F" !== s && (t._i[s] = i)),
                    t
                );
            },
            getEntry: y,
            setStrong: function (t, e, n) {
                l(
                    t,
                    e,
                    function (t, n) {
                        (this._t = f(t, e)), (this._k = n), (this._l = void 0);
                    },
                    function () {
                        for (var t = this, e = t._k, n = t._l; n && n.r; )
                            n = n.p;
                        return t._t && (t._l = n = n ? n.n : t._t._f)
                            ? u(
                                  0,
                                  "keys" == e
                                      ? n.k
                                      : "values" == e
                                      ? n.v
                                      : [n.k, n.v]
                              )
                            : ((t._t = void 0), u(1));
                    },
                    n ? "entries" : "values",
                    !n,
                    !0
                ),
                    h(e);
            },
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(48),
            s = n(31).getWeak,
            i = n(5),
            o = n(6),
            a = n(47),
            c = n(61),
            l = n(26),
            u = n(16),
            h = n(41),
            p = l(5),
            d = l(6),
            f = 0,
            m = function (t) {
                return t._l || (t._l = new y());
            },
            y = function () {
                this.a = [];
            },
            g = function (t, e) {
                return p(t.a, function (t) {
                    return t[0] === e;
                });
            };
        (y.prototype = {
            get: function (t) {
                var e = g(this, t);
                if (e) return e[1];
            },
            has: function (t) {
                return !!g(this, t);
            },
            set: function (t, e) {
                var n = g(this, t);
                n ? (n[1] = e) : this.a.push([t, e]);
            },
            delete: function (t) {
                var e = d(this.a, function (e) {
                    return e[0] === t;
                });
                return ~e && this.a.splice(e, 1), !!~e;
            },
        }),
            (t.exports = {
                getConstructor: function (t, e, n, i) {
                    var l = t(function (t, r) {
                        a(t, l, e, "_i"),
                            (t._t = e),
                            (t._i = f++),
                            (t._l = void 0),
                            null != r && c(r, n, t[i], t);
                    });
                    return (
                        r(l.prototype, {
                            delete: function (t) {
                                if (!o(t)) return !1;
                                var n = s(t);
                                return !0 === n
                                    ? m(h(this, e)).delete(t)
                                    : n && u(n, this._i) && delete n[this._i];
                            },
                            has: function (t) {
                                if (!o(t)) return !1;
                                var n = s(t);
                                return !0 === n
                                    ? m(h(this, e)).has(t)
                                    : n && u(n, this._i);
                            },
                        }),
                        l
                    );
                },
                def: function (t, e, n) {
                    var r = s(i(e), !0);
                    return !0 === r ? m(t).set(e, n) : (r[t._i] = n), t;
                },
                ufstore: m,
            });
    },
    function (t, e, n) {
        var r = n(23),
            s = n(8);
        t.exports = function (t) {
            if (void 0 === t) return 0;
            var e = r(t),
                n = s(e);
            if (e !== n) throw RangeError("Wrong length!");
            return n;
        };
    },
    function (t, e, n) {
        var r = n(38),
            s = n(55),
            i = n(5),
            o = n(3).Reflect;
        t.exports =
            (o && o.ownKeys) ||
            function (t) {
                var e = r.f(i(t)),
                    n = s.f;
                return n ? e.concat(n(t)) : e;
            };
    },
    function (t, e, n) {
        var r = n(8),
            s = n(73),
            i = n(28);
        t.exports = function (t, e, n, o) {
            var a = String(i(t)),
                c = a.length,
                l = void 0 === n ? " " : String(n),
                u = r(e);
            if (u <= c || "" == l) return a;
            var h = u - c,
                p = s.call(l, Math.ceil(h / l.length));
            return p.length > h && (p = p.slice(0, h)), o ? p + a : a + p;
        };
    },
    function (t, e, n) {
        var r = n(10),
            s = n(35),
            i = n(18),
            o = n(50).f;
        t.exports = function (t) {
            return function (e) {
                for (
                    var n, a = i(e), c = s(a), l = c.length, u = 0, h = [];
                    l > u;

                )
                    (n = c[u++]),
                        (r && !o.call(a, n)) || h.push(t ? [n, a[n]] : a[n]);
                return h;
            };
        };
    },
    function (t, e) {
        var n = (t.exports = { version: "2.6.11" });
        "number" == typeof __e && (__e = n);
    },
    function (t, e) {
        t.exports = function (t) {
            try {
                return !!t();
            } catch (t) {
                return !0;
            }
        };
    },
    function (t, e) {
        var n;
        n = (function () {
            return this;
        })();
        try {
            n = n || new Function("return this")();
        } catch (t) {
            "object" == typeof window && (n = window);
        }
        t.exports = n;
    },
    function (t, e, n) {
        "use strict";
        t.exports = function (t, e) {
            return function () {
                for (
                    var n = new Array(arguments.length), r = 0;
                    r < n.length;
                    r++
                )
                    n[r] = arguments[r];
                return t.apply(e, n);
            };
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(15);
        function s(t) {
            return encodeURIComponent(t)
                .replace(/%3A/gi, ":")
                .replace(/%24/g, "$")
                .replace(/%2C/gi, ",")
                .replace(/%20/g, "+")
                .replace(/%5B/gi, "[")
                .replace(/%5D/gi, "]");
        }
        t.exports = function (t, e, n) {
            if (!e) return t;
            var i;
            if (n) i = n(e);
            else if (r.isURLSearchParams(e)) i = e.toString();
            else {
                var o = [];
                r.forEach(e, function (t, e) {
                    null != t &&
                        (r.isArray(t) ? (e += "[]") : (t = [t]),
                        r.forEach(t, function (t) {
                            r.isDate(t)
                                ? (t = t.toISOString())
                                : r.isObject(t) && (t = JSON.stringify(t)),
                                o.push(s(e) + "=" + s(t));
                        }));
                }),
                    (i = o.join("&"));
            }
            if (i) {
                var a = t.indexOf("#");
                -1 !== a && (t = t.slice(0, a)),
                    (t += (-1 === t.indexOf("?") ? "?" : "&") + i);
            }
            return t;
        };
    },
    function (t, e, n) {
        "use strict";
        t.exports = function (t) {
            return !(!t || !t.__CANCEL__);
        };
    },
    function (t, e, n) {
        "use strict";
        (function (e) {
            var r = n(15),
                s = n(365),
                i = { "Content-Type": "application/x-www-form-urlencoded" };
            function o(t, e) {
                !r.isUndefined(t) &&
                    r.isUndefined(t["Content-Type"]) &&
                    (t["Content-Type"] = e);
            }
            var a,
                c = {
                    adapter:
                        (("undefined" != typeof XMLHttpRequest ||
                            (void 0 !== e &&
                                "[object process]" ===
                                    Object.prototype.toString.call(e))) &&
                            (a = n(131)),
                        a),
                    transformRequest: [
                        function (t, e) {
                            return (
                                s(e, "Accept"),
                                s(e, "Content-Type"),
                                r.isFormData(t) ||
                                r.isArrayBuffer(t) ||
                                r.isBuffer(t) ||
                                r.isStream(t) ||
                                r.isFile(t) ||
                                r.isBlob(t)
                                    ? t
                                    : r.isArrayBufferView(t)
                                    ? t.buffer
                                    : r.isURLSearchParams(t)
                                    ? (o(
                                          e,
                                          "application/x-www-form-urlencoded;charset=utf-8"
                                      ),
                                      t.toString())
                                    : r.isObject(t)
                                    ? (o(e, "application/json;charset=utf-8"),
                                      JSON.stringify(t))
                                    : t
                            );
                        },
                    ],
                    transformResponse: [
                        function (t) {
                            if ("string" == typeof t)
                                try {
                                    t = JSON.parse(t);
                                } catch (t) {}
                            return t;
                        },
                    ],
                    timeout: 0,
                    xsrfCookieName: "XSRF-TOKEN",
                    xsrfHeaderName: "X-XSRF-TOKEN",
                    maxContentLength: -1,
                    maxBodyLength: -1,
                    validateStatus: function (t) {
                        return t >= 200 && t < 300;
                    },
                };
            (c.headers = {
                common: { Accept: "application/json, text/plain, */*" },
            }),
                r.forEach(["delete", "get", "head"], function (t) {
                    c.headers[t] = {};
                }),
                r.forEach(["post", "put", "patch"], function (t) {
                    c.headers[t] = r.merge(i);
                }),
                (t.exports = c);
        }.call(this, n(364)));
    },
    function (t, e, n) {
        "use strict";
        var r = n(15),
            s = n(366),
            i = n(368),
            o = n(128),
            a = n(369),
            c = n(372),
            l = n(373),
            u = n(132);
        t.exports = function (t) {
            return new Promise(function (e, n) {
                var h = t.data,
                    p = t.headers;
                r.isFormData(h) && delete p["Content-Type"],
                    (r.isBlob(h) || r.isFile(h)) &&
                        h.type &&
                        delete p["Content-Type"];
                var d = new XMLHttpRequest();
                if (t.auth) {
                    var f = t.auth.username || "",
                        m = unescape(encodeURIComponent(t.auth.password)) || "";
                    p.Authorization = "Basic " + btoa(f + ":" + m);
                }
                var y = a(t.baseURL, t.url);
                if (
                    (d.open(
                        t.method.toUpperCase(),
                        o(y, t.params, t.paramsSerializer),
                        !0
                    ),
                    (d.timeout = t.timeout),
                    (d.onreadystatechange = function () {
                        if (
                            d &&
                            4 === d.readyState &&
                            (0 !== d.status ||
                                (d.responseURL &&
                                    0 === d.responseURL.indexOf("file:")))
                        ) {
                            var r =
                                    "getAllResponseHeaders" in d
                                        ? c(d.getAllResponseHeaders())
                                        : null,
                                i = {
                                    data:
                                        t.responseType &&
                                        "text" !== t.responseType
                                            ? d.response
                                            : d.responseText,
                                    status: d.status,
                                    statusText: d.statusText,
                                    headers: r,
                                    config: t,
                                    request: d,
                                };
                            s(e, n, i), (d = null);
                        }
                    }),
                    (d.onabort = function () {
                        d &&
                            (n(u("Request aborted", t, "ECONNABORTED", d)),
                            (d = null));
                    }),
                    (d.onerror = function () {
                        n(u("Network Error", t, null, d)), (d = null);
                    }),
                    (d.ontimeout = function () {
                        var e = "timeout of " + t.timeout + "ms exceeded";
                        t.timeoutErrorMessage && (e = t.timeoutErrorMessage),
                            n(u(e, t, "ECONNABORTED", d)),
                            (d = null);
                    }),
                    r.isStandardBrowserEnv())
                ) {
                    var g =
                        (t.withCredentials || l(y)) && t.xsrfCookieName
                            ? i.read(t.xsrfCookieName)
                            : void 0;
                    g && (p[t.xsrfHeaderName] = g);
                }
                if (
                    ("setRequestHeader" in d &&
                        r.forEach(p, function (t, e) {
                            void 0 === h && "content-type" === e.toLowerCase()
                                ? delete p[e]
                                : d.setRequestHeader(e, t);
                        }),
                    r.isUndefined(t.withCredentials) ||
                        (d.withCredentials = !!t.withCredentials),
                    t.responseType)
                )
                    try {
                        d.responseType = t.responseType;
                    } catch (e) {
                        if ("json" !== t.responseType) throw e;
                    }
                "function" == typeof t.onDownloadProgress &&
                    d.addEventListener("progress", t.onDownloadProgress),
                    "function" == typeof t.onUploadProgress &&
                        d.upload &&
                        d.upload.addEventListener(
                            "progress",
                            t.onUploadProgress
                        ),
                    t.cancelToken &&
                        t.cancelToken.promise.then(function (t) {
                            d && (d.abort(), n(t), (d = null));
                        }),
                    h || (h = null),
                    d.send(h);
            });
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(367);
        t.exports = function (t, e, n, s, i) {
            var o = new Error(t);
            return r(o, e, n, s, i);
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(15);
        t.exports = function (t, e) {
            e = e || {};
            var n = {},
                s = ["url", "method", "data"],
                i = ["headers", "auth", "proxy", "params"],
                o = [
                    "baseURL",
                    "transformRequest",
                    "transformResponse",
                    "paramsSerializer",
                    "timeout",
                    "timeoutMessage",
                    "withCredentials",
                    "adapter",
                    "responseType",
                    "xsrfCookieName",
                    "xsrfHeaderName",
                    "onUploadProgress",
                    "onDownloadProgress",
                    "decompress",
                    "maxContentLength",
                    "maxBodyLength",
                    "maxRedirects",
                    "transport",
                    "httpAgent",
                    "httpsAgent",
                    "cancelToken",
                    "socketPath",
                    "responseEncoding",
                ],
                a = ["validateStatus"];
            function c(t, e) {
                return r.isPlainObject(t) && r.isPlainObject(e)
                    ? r.merge(t, e)
                    : r.isPlainObject(e)
                    ? r.merge({}, e)
                    : r.isArray(e)
                    ? e.slice()
                    : e;
            }
            function l(s) {
                r.isUndefined(e[s])
                    ? r.isUndefined(t[s]) || (n[s] = c(void 0, t[s]))
                    : (n[s] = c(t[s], e[s]));
            }
            r.forEach(s, function (t) {
                r.isUndefined(e[t]) || (n[t] = c(void 0, e[t]));
            }),
                r.forEach(i, l),
                r.forEach(o, function (s) {
                    r.isUndefined(e[s])
                        ? r.isUndefined(t[s]) || (n[s] = c(void 0, t[s]))
                        : (n[s] = c(void 0, e[s]));
                }),
                r.forEach(a, function (r) {
                    r in e
                        ? (n[r] = c(t[r], e[r]))
                        : r in t && (n[r] = c(void 0, t[r]));
                });
            var u = s.concat(i).concat(o).concat(a),
                h = Object.keys(t)
                    .concat(Object.keys(e))
                    .filter(function (t) {
                        return -1 === u.indexOf(t);
                    });
            return r.forEach(h, l), n;
        };
    },
    function (t, e, n) {
        "use strict";
        function r(t) {
            this.message = t;
        }
        (r.prototype.toString = function () {
            return "Cancel" + (this.message ? ": " + this.message : "");
        }),
            (r.prototype.__CANCEL__ = !0),
            (t.exports = r);
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512">\n    <path fill="currentColor" d="M320 448v40c0 13.255-10.745 24-24 24H24c-13.255 0-24-10.745-24-24V120c0-13.255 10.745-24 24-24h72v296c0 30.879 25.121 56 56 56h168zm0-344V0H152c-13.255 0-24 10.745-24 24v368c0 13.255 10.745 24 24 24h272c13.255 0 24-10.745 24-24V128H344c-13.2 0-24-10.8-24-24zm120.971-31.029L375.029 7.029A24 24 0 0 0 358.059 0H352v96h96v-6.059a24 24 0 0 0-7.029-16.97z"></path>\n</svg>\n');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 58 58">\n    <g transform="translate(-52.620776,-4.6795985)">\n        <path id="path32-3-6" style="stroke-width:6.44606" d="m 206.29492,30.601562 a 7.4774536,7.4774536 0 0 0 -7.41211,7.607422 V 216.37891 a 7.5419142,7.5419142 0 0 0 7.54102,7.60547 h 204.08398 a 7.5419142,7.5419142 0 0 0 7.54102,-7.60547 V 69.988281 a 7.4129926,7.4129926 0 0 0 -7.66992,-7.15625 H 295.57422 V 38.208984 a 7.4774536,7.4774536 0 0 0 -7.41406,-7.607422 z m 98.5957,63.732422 h 7.1504 a 7.1502569,7.1502569 0 0 1 7.15039,7.150396 v 28.5996 h 28.59961 a 7.1502569,7.1502569 0 0 1 7.15039,7.1504 v 7.15039 a 7.1502569,7.1502569 0 0 1 -7.15039,7.15039 h -28.59961 v 28.60156 a 7.1502569,7.1502569 0 0 1 -7.15039,7.15039 h -7.1504 a 7.1502569,7.1502569 0 0 1 -7.15039,-7.15039 v -28.60156 h -28.60156 a 7.1502569,7.1502569 0 0 1 -7.15039,-7.15039 v -7.15039 a 7.1502569,7.1502569 0 0 1 7.15039,-7.1504 h 28.60156 v -28.5996 a 7.1502569,7.1502569 0 0 1 7.15039,-7.150396 z" transform="scale(0.26458333)" />\n    </g>\n</svg>\n');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 346.8 427">\n\n    <path d="M700,246V434.34a10.2,10.2,0,0,0,8.52,10.2A10,10,0,0,0,720,434.65v-189a10,10,0,0,0-11.48-9.89A10.2,10.2,0,0,0,700,246Z" transform="translate(-477.6 -81)"/>\n    <path d="M582,246V434.34a10.2,10.2,0,0,0,8.52,10.2A10,10,0,0,0,602,434.65v-189a10,10,0,0,0-11.48-9.89A10.2,10.2,0,0,0,582,246Z" transform="translate(-477.6 -81)"/>\n    <path d="M506,208.12V454.5c0,14.56,5.34,28.24,14.67,38.05A49.23,49.23,0,0,0,556.4,508H745.6a49.21,49.21,0,0,0,35.73-15.45c9.33-9.81,14.67-23.49,14.67-38.05V208.12A38.2,38.2,0,0,0,786.2,133H735V120.5A39.28,39.28,0,0,0,695.4,81H606.6A39.28,39.28,0,0,0,567,120.5V133H515.8a38.2,38.2,0,0,0-9.8,75.12ZM745.6,488H556.4c-17.1,0-30.4-14.69-30.4-33.5V209H776V454.5C776,473.31,762.7,488,745.6,488ZM587,120.5A19.28,19.28,0,0,1,606.6,101h88.8A19.28,19.28,0,0,1,715,120.5V133H587ZM516.08,153h270a18.27,18.27,0,0,1,18.34,16.37A18,18,0,0,1,786.48,189h-270a18.27,18.27,0,0,1-18.34-16.37A18,18,0,0,1,516.08,153Z" transform="translate(-477.6 -81)"/>\n    <path d="M641,246V434.34a10.2,10.2,0,0,0,8.52,10.2A10,10,0,0,0,661,434.65v-189a10,10,0,0,0-11.48-9.89A10.2,10.2,0,0,0,641,246Z" transform="translate(-477.6 -81)"/>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">\n    <path fill="currentColor" d="M224 136V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zm76.45 211.36l-96.42 95.7c-6.65 6.61-17.39 6.61-24.04 0l-96.42-95.7C73.42 337.29 80.54 320 94.82 320H160v-80c0-8.84 7.16-16 16-16h32c8.84 0 16 7.16 16 16v80h65.18c14.28 0 21.4 17.29 11.27 27.36zM377 105L279.1 7c-4.5-4.5-10.6-7-17-7H256v128h128v-6.1c0-6.3-2.5-12.4-7-16.9z"></path>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 58 58">\n\n    <g transform="translate(-124.71147,-8.6196288)">\n        <path style="stroke-width:1.70552" d="m 126.67289,12.036694 a 1.9784096,1.9784096 0 0 0 -1.96112,2.012797 v 47.140792 a 1.9954648,1.9954648 0 0 0 1.99522,2.01228 h 53.99671 a 1.9954648,1.9954648 0 0 0 1.99574,-2.01228 v -38.73252 a 1.9613543,1.9613543 0 0 0 -2.02985,-1.893424 h -30.37541 v -6.514848 a 1.9784096,1.9784096 0 0 0 -1.96112,-2.012797 z m 26.86657,18.857247 h 5.3e-4 c 0.14084,-0.0037 0.286,0.04471 0.42272,0.156062 l 12.26437,10.166305 c 0.57391,0.485423 0.58078,1.702043 -0.006,2.187464 h -5.3e-4 l -12.25869,10.169405 c -0.53457,0.44241 -1.22886,-0.113601 -1.22886,-1.00149 v -4.325834 h -10.30118 c -0.86946,0 -1.68103,-1.038868 -1.68103,-2.292366 v -7.283794 c 0,-1.253498 0.81157,-2.405539 1.68103,-2.405539 H 152.733 v -4.212661 c 0,-0.665927 0.38361,-1.147101 0.80615,-1.157552 z" />\n    </g>\n</svg>\n');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 55 56.97">\n\n    <path d="M461.26,278.93l-13.55-14.1A23,23,0,1,0,430.1,273a22.74,22.74,0,0,0,13.18-4.16l13.66,14.21a3,3,0,0,0,4.32-4.16ZM430.1,233a17,17,0,1,1-17,17A17,17,0,0,1,430.1,233Z" transform="translate(-407.1 -227.04)"/>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg version="1.1" \r\n    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 395 395">\r\n    <g>\r\n        <path d="M 360.7 198.7 c 1.4 -6.8 2.1 -13.8 2.1 -21 c 0 -58.1 -47.1 -105.2 -105.2 -105.2 c -43.1 0 -80.1 25.9 -96.3 63 c -12.5 -8.1 -27.4 -12.9 -43.4 -12.9 c -42.1 0 -76.5 32.7 -79.4 74.1 C 15.8 207.2 0 230 0 256.6 c 0 36.4 29.5 65.9 65.9 65.9 c 0 0 71.4 0 95.2 0 c 4.7 0 4.9 -5.2 4.9 -5.2 v -42.3 c 0 -3.6 -3 -6.6 -6.6 -6.6 h -18 c -3.6 0 -4.8 -2.4 -2.7 -5.3 l 54.9 -74.1 c 2.1 -2.9 5.7 -2.9 7.8 0 l 54.9 74.1 c 2.1 2.9 1 5.3 -2.7 5.3 h -18 c -3.6 0 -6.6 3 -6.6 6.6 v 42.4 c 0 0 0.3 5.1 5.1 5.1 c 23.7 0 95 0 95 0 c 36.4 0 65.9 -29.5 65.9 -65.9 C 395.1 231.6 381.2 209.9 360.7 198.7 z"/>\r\n    </g>\r\n</svg>\r\n');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 31.11 31.11">\n\n    <polygon points="31.11 1.41 29.7 0 15.56 14.14 1.41 0 0 1.41 14.14 15.56 0 29.7 1.41 31.11 15.56 16.97 29.7 31.11 31.11 29.7 16.97 15.56 31.11 1.41"/>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg xmlns:dc="http://purl.org/dc/elements/1.1/" \n    xmlns:cc="http://creativecommons.org/ns#" \n    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" \n    xmlns:svg="http://www.w3.org/2000/svg" \n    xmlns="http://www.w3.org/2000/svg" height="31" width="31" xml:space="preserve" viewBox="0 0 31 31" y="0px" x="0px" version="1.1">\n    <g transform="matrix(0.56363636,0,0,0.56363636,-11.554545,-11.554545)">\n        <path d="m 60.5,55.5 h 5 v -20 c 0,-2.8 -2.2,-5 -5,-5 h -20 v 5 h 20 z m -25,5 v -40 h -5 v 10 h -10 v 5 h 10 v 25 c 0,2.8 2.2,5 5,5 h 25 v 10 h 5 v -10 h 10 v -5 z" class="st0" />\n    </g>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" \n    xmlns:xlink="http://www.w3.org/1999/xlink" style="margin:auto;background:#fff;display:block;" width="207px" height="207px" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid">\n    <g transform="translate(50 50)">\n        <g transform="translate(-17 -17) scale(0.5)">\n            <g>\n                <animateTransform attributeName="transform" type="rotate" values="0;30" keyTimes="0;1" dur="0.3367003367003367s" begin="0s" repeatCount="indefinite"></animateTransform>\n                <path d="M39 -6 L46 -6 L46 6 L39 6 A40 40 0 0 1 37 14 L37 14 L43 18 L37 28 L31 24 A40 40 0 0 1 24 31 L24 31 L28 37 L18 43 L14 37 A40 40 0 0 1 5 39 L5 39 L5 46 L-5 46 L-5 39 A40 40 0 0 1 -14 37 L-14 37 L-18 43 L-28 37 L-24 31 A40 40 0 0 1 -31 24 L-31 24 L-37 28 L-43 18 L-37 14 A40 40 0 0 1 -39 6 L-39 6 L-46 6 L-46 -5 L-39 -5 A40 40 0 0 1 -37 -14 L-37 -14 L-43 -18 L-37 -28 L-31 -24 A40 40 0 0 1 -24 -31 L-24 -31 L-28 -37 L-18 -43 L-14 -37 A40 40 0 0 1 -6 -39 L-6 -39 L-6 -46 L6 -46 L6 -39 A40 40 0 0 1 14 -37 L14 -37 L18 -43 L28 -37 L24 -31 A40 40 0 0 1 31 -24 L31 -24 L37 -28 L43 -18 L37 -14 A40 40 0 0 1 39 -6 M0 -23A23 23 0 1 0 0 23 A23 23 0 1 0 0 -23" fill="#93dbe9"></path>\n            </g>\n        </g>\n        <g transform="translate(0 22) scale(0.4)">\n            <g>\n                <animateTransform attributeName="transform" type="rotate" values="30;0" keyTimes="0;1" dur="0.3367003367003367s" begin="-0.16835016835016836s" repeatCount="indefinite"></animateTransform>\n                <path d="M39 -6 L46 -6 L46 6 L39 6 A40 40 0 0 1 37 14 L37 14 L43 18 L37 28 L31 24 A40 40 0 0 1 24 31 L24 31 L28 37 L18 43 L14 37 A40 40 0 0 1 5 39 L5 39 L5 46 L-5 46 L-5 39 A40 40 0 0 1 -14 37 L-14 37 L-18 43 L-28 37 L-24 31 A40 40 0 0 1 -31 24 L-31 24 L-37 28 L-43 18 L-37 14 A40 40 0 0 1 -39 6 L-39 6 L-46 6 L-46 -5 L-39 -5 A40 40 0 0 1 -37 -14 L-37 -14 L-43 -18 L-37 -28 L-31 -24 A40 40 0 0 1 -24 -31 L-24 -31 L-28 -37 L-18 -43 L-14 -37 A40 40 0 0 1 -6 -39 L-6 -39 L-6 -46 L6 -46 L6 -39 A40 40 0 0 1 14 -37 L14 -37 L18 -43 L28 -37 L24 -31 A40 40 0 0 1 31 -24 L31 -24 L37 -28 L43 -18 L37 -14 A40 40 0 0 1 39 -6 M0 -23A23 23 0 1 0 0 23 A23 23 0 1 0 0 -23" fill="#689cc5"></path>\n            </g>\n        </g>\n        <g transform="translate(28 4) scale(0.3)">\n            <g>\n                <animateTransform attributeName="transform" type="rotate" values="0;30" keyTimes="0;1" dur="0.3367003367003367s" begin="-0.16835016835016836s" repeatCount="indefinite"></animateTransform>\n                <path d="M39 -6 L46 -6 L46 6 L39 6 A40 40 0 0 1 37 14 L37 14 L43 18 L37 28 L31 24 A40 40 0 0 1 24 31 L24 31 L28 37 L18 43 L14 37 A40 40 0 0 1 5 39 L5 39 L5 46 L-5 46 L-5 39 A40 40 0 0 1 -14 37 L-14 37 L-18 43 L-28 37 L-24 31 A40 40 0 0 1 -31 24 L-31 24 L-37 28 L-43 18 L-37 14 A40 40 0 0 1 -39 6 L-39 6 L-46 6 L-46 -5 L-39 -5 A40 40 0 0 1 -37 -14 L-37 -14 L-43 -18 L-37 -28 L-31 -24 A40 40 0 0 1 -24 -31 L-24 -31 L-28 -37 L-18 -43 L-14 -37 A40 40 0 0 1 -6 -39 L-6 -39 L-6 -46 L6 -46 L6 -39 A40 40 0 0 1 14 -37 L14 -37 L18 -43 L28 -37 L24 -31 A40 40 0 0 1 31 -24 L31 -24 L37 -28 L43 -18 L37 -14 A40 40 0 0 1 39 -6 M0 -23A23 23 0 1 0 0 23 A23 23 0 1 0 0 -23" fill="#5e6fa3"></path>\n            </g>\n        </g>\n    </g>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 17 17">\n    <g transform="translate(-1193 -113)">\n        <g transform="translate(1193 113)" fill="#fff" stroke="#bdc0c6" stroke-width="1">\n            <rect width="8" height="8" stroke="none"/>\n            <rect x="0.5" y="0.5" width="7" height="7" fill="none"/>\n        </g>\n        <g transform="translate(1202 113)" fill="#fff" stroke="#bdc0c6" stroke-width="1">\n            <rect width="8" height="8" stroke="none"/>\n            <rect x="0.5" y="0.5" width="7" height="7" fill="none"/>\n        </g>\n        <g transform="translate(1193 122)" fill="#fff" stroke="#bdc0c6" stroke-width="1">\n            <rect width="8" height="8" stroke="none"/>\n            <rect x="0.5" y="0.5" width="7" height="7" fill="none"/>\n        </g>\n        <g transform="translate(1202 122)" fill="#fff" stroke="#bdc0c6" stroke-width="1">\n            <rect width="8" height="8" stroke="none"/>\n            <rect x="0.5" y="0.5" width="7" height="7" fill="none"/>\n        </g>\n    </g>\n</svg>\n');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.33 476.24">\n\n    <path d="M928,167V272.79c0,10.42-7.8,19.45-18.19,20.37A20,20,0,0,1,888,273.24V167a40,40,0,0,0-40-40H496a40,40,0,0,0-40,40V466.45A20.55,20.55,0,0,0,476.55,487H641.29a10.45,10.45,0,0,1,7.87,3.53c14.89,17,3.15,36.47-13.16,36.47H496a80,80,0,0,1-80-80V167a80,80,0,0,1,80-80H848A80,80,0,0,1,928,167ZM500.26,412.93a20,20,0,0,0,28-3.84l28.41-37.43,52.77,66.74a20,20,0,0,0,15.69,7.6h0a20,20,0,0,0,15.7-7.63L794.73,242.88l31.2,37.84a20,20,0,1,0,30.86-25.44l-47-57a20,20,0,0,0-31.15.35L625.11,393.71l-53.06-67.12a20,20,0,0,0-31.62.32l-44,58A20,20,0,0,0,500.26,412.93Zm-3.9-193.69a60,60,0,1,1,60,60A60.07,60.07,0,0,1,496.36,219.24Zm40,0a20,20,0,1,0,20-20A20,20,0,0,0,536.36,219.24ZM910.79,340.81a60.07,60.07,0,0,1,0,84.85L801.22,535a20,20,0,0,1-8.79,5.12L711.7,562.51a20,20,0,0,1-24.47-25.09l23.91-78.72a20.1,20.1,0,0,1,5-8.35L826,340.79A60.08,60.08,0,0,1,910.79,340.81Zm-60.46,88.68L822,401.2,748,475.13l-11.88,39.13L776.68,503ZM882.5,369.1a20,20,0,0,0-28.28,0L850.36,373l28.28,28.28,3.88-3.86A20,20,0,0,0,882.5,369.1Z" transform="translate(-416 -87)"/>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28">\n\n    <path d="M445,270a1,1,0,0,0-1,1v7a1,1,0,1,0,2,0v-7a1,1,0,0,0-1-1Z" transform="translate(-431 -258.33)"/>\n    <circle cx="14" cy="8" r="1"/>\n    <path d="M445,258.33a14,14,0,1,0,14,14A14,14,0,0,0,445,258.33Zm0,2a12,12,0,1,1-12,12A12,12,0,0,1,445,260.33Z" transform="translate(-431 -258.33)"/>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" width="18.388" height="13.459" viewBox="0 0 18.388 13.459">\n    <g transform="translate(-1166 -114.22)">\n        <line x2="18.388" transform="translate(1166 114.97)" fill="none" stroke="#bdc0c6" stroke-width="1.5"/>\n        <line x2="18.388" transform="translate(1166 120.95)" fill="none" stroke="#bdc0c6" stroke-width="1.5"/>\n        <line x2="18.388" transform="translate(1166 126.93)" fill="none" stroke="#bdc0c6" stroke-width="1.5"/>\n    </g>\n</svg>\n');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg viewBox="-13 0 512 512" \n    xmlns="http://www.w3.org/2000/svg">\n    <path d="m242.5 0c-8.28125 0-15 6.714844-15 15v482c0 8.285156 6.71875 15 15 15 8.285156 0 15.003906-6.714844 15.003906-15v-482c0-8.285156-6.71875-15-15.003906-15zm0 0"/>\n    <path d="m191.699219 244.152344-167.503907-130c-4.523437-3.511719-10.648437-4.140625-15.792968-1.625-5.144532 2.519531-8.402344 7.746094-8.402344 13.472656v260.003906c0 5.726563 3.261719 10.953125 8.402344 13.472656 2.09375 1.023438 4.351562 1.527344 6.597656 1.527344 3.269531 0 6.515625-1.070312 9.195312-3.152344l167.503907-130c3.660156-2.839843 5.800781-7.214843 5.800781-11.847656 0-4.636718-2.140625-9.011718-5.800781-11.851562zm-161.699219 111.222656v-198.742188l128.035156 99.371094zm0 0"/>\n    <path d="m476.601562 112.527344c-5.144531-2.515625-11.269531-1.890625-15.796874 1.625l-167.5 130c-3.660157 2.839844-5.800782 7.214844-5.800782 11.851562 0 4.632813 2.140625 9.007813 5.800782 11.847656l167.5 130c2.683593 2.082032 5.929687 3.152344 9.199218 3.152344 2.246094 0 4.503906-.503906 6.597656-1.527344 5.144532-2.519531 8.402344-7.746093 8.402344-13.472656v-260.003906c0-5.726562-3.261718-10.953125-8.402344-13.472656zm-21.597656 242.847656-128.035156-99.371094 128.035156-99.371094zm0 0"/>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns:dc="http://purl.org/dc/elements/1.1/" \n    xmlns:cc="http://creativecommons.org/ns#" \n    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" \n    xmlns:svg="http://www.w3.org/2000/svg" \n    xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512.12362 512.0624" y="0px" x="0px" version="1.1">\n    <g transform="translate(0.01179993,-0.01880585)">\n        <path d="M 8.8451859,459.31659 35.370711,350.503 l 108.813599,26.52553 -7.57873,31.0896 -56.427625,-13.75538 c 30.771065,39.57766 74.057655,67.54615 122.783535,79.33658 120.23154,29.36242 241.50088,-44.3015 270.8633,-164.53308 C 503.1872,188.93468 429.52426,67.665581 309.2927,38.303175 189.06116,8.9407586 67.791824,82.60468 38.429642,202.83526 c -8.770859,35.91247 -8.519973,73.43752 0.729166,109.23036 L 8.1921063,320.12901 C -27.181584,183.24179 55.112712,43.596018 192.00088,8.222554 328.88904,-27.150903 468.53457,55.14437 503.90803,192.03253 c 35.37346,136.88817 -46.92182,276.53374 -183.80998,311.9072 -40.86562,10.56002 -83.70856,10.8516 -124.71529,0.8492 C 138.76519,491.10766 88.593989,458.3288 53.322598,411.97555 l -13.387815,54.91977 z" />\n    </g>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg viewBox="0 0 512 512" \n    xmlns="http://www.w3.org/2000/svg">\n    <path d="m145.96875 423.246094h-36.707031l84.6875-84.375-21.171875-21.253906-84.476563 84.164062v-36.203125h-30v87.667969h87.667969zm0 0"/>\n    <path d="m366.03125 423.246094v30h87.667969v-87.667969h-30v36.203125l-84.476563-84.164062-21.171875 21.253906 84.6875 84.375zm0 0"/>\n    <path d="m88.300781 110.21875 84.476563 84.164062 21.171875-21.253906-84.6875-84.375h36.707031v-30h-87.667969v87.667969h30zm0 0"/>\n    <path d="m339.222656 194.382812 84.476563-84.164062v36.203125h30v-87.667969h-87.667969v30h36.707031l-84.6875 84.375zm0 0"/>\n    <path d="m0 0v512h512v-512zm482 482h-452v-452h452zm0 0"/>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"\r\n\t viewBox="0 0 512 512">\r\n\r\n\t\t<path d="M511.563,434.259c-1.728-142.329-124.42-258.242-277.087-263.419V95.999c0-17.645-14.342-31.999-31.974-31.999\r\n\t\t\tc-7.931,0-15.591,3.042-21.524,8.562c0,0-134.828,124.829-173.609,163.755C2.623,241.109,0,248.088,0,255.994\r\n\t\t\tc0,7.906,2.623,14.885,7.369,19.687c38.781,38.915,173.609,163.745,173.609,163.745c5.933,5.521,13.593,8.562,21.524,8.562\r\n\t\t\tc17.631,0,31.974-14.354,31.974-31.999v-74.591c153.479,2.156,255.792,50.603,255.792,95.924c0,5.896,4.767,10.666,10.658,10.666\r\n\t\t\tc0.167,0.021,0.333,0.01,0.416,0c5.891,0,10.658-4.771,10.658-10.666C512,436.259,511.854,435.228,511.563,434.259z"/>\r\n\r\n\r\n</svg>\r\n');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg version="1.1" id="Capa_1" \r\n    xmlns="http://www.w3.org/2000/svg" \r\n    xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 477.867 477.867" style="enable-background:new 0 0 477.867 477.867;" xml:space="preserve">\r\n\r\n    <path d="M409.6,0c-9.426,0-17.067,7.641-17.067,17.067v62.344C304.667-5.656,164.478-3.386,79.411,84.479\r\n\t\t\tc-40.09,41.409-62.455,96.818-62.344,154.454c0,9.426,7.641,17.067,17.067,17.067S51.2,248.359,51.2,238.933\r\n\t\t\tc0.021-103.682,84.088-187.717,187.771-187.696c52.657,0.01,102.888,22.135,138.442,60.976l-75.605,25.207\r\n\t\t\tc-8.954,2.979-13.799,12.652-10.82,21.606s12.652,13.799,21.606,10.82l102.4-34.133c6.99-2.328,11.697-8.88,11.674-16.247v-102.4\r\n\t\t\tC426.667,7.641,419.026,0,409.6,0z"/>\r\n\r\n    <path d="M443.733,221.867c-9.426,0-17.067,7.641-17.067,17.067c-0.021,103.682-84.088,187.717-187.771,187.696\r\n\t\t\tc-52.657-0.01-102.888-22.135-138.442-60.976l75.605-25.207c8.954-2.979,13.799-12.652,10.82-21.606\r\n\t\t\tc-2.979-8.954-12.652-13.799-21.606-10.82l-102.4,34.133c-6.99,2.328-11.697,8.88-11.674,16.247v102.4\r\n\t\t\tc0,9.426,7.641,17.067,17.067,17.067s17.067-7.641,17.067-17.067v-62.345c87.866,85.067,228.056,82.798,313.122-5.068\r\n\t\t\tc40.09-41.409,62.455-96.818,62.344-154.454C460.8,229.508,453.159,221.867,443.733,221.867z"/>\r\n\r\n\r\n</svg>\r\n');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">\n    <path fill="currentColor" d="M377 105L279.1 7c-4.5-4.5-10.6-7-17-7H256v128h128v-6.1c0-6.3-2.5-12.4-7-16.9zM128.4 336c-17.9 0-32.4 12.1-32.4 27 0 15 14.6 27 32.5 27s32.4-12.1 32.4-27-14.6-27-32.5-27zM224 136V0h-63.6v32h-32V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zM95.9 32h32v32h-32zm32.3 384c-33.2 0-58-30.4-51.4-62.9L96.4 256v-32h32v-32h-32v-32h32v-32h-32V96h32V64h32v32h-32v32h32v32h-32v32h32v32h-32v32h22.1c5.7 0 10.7 4.1 11.8 9.7l17.3 87.7c6.4 32.4-18.4 62.6-51.4 62.6z"></path>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">\n    <path fill="currentColor" d="M224 136V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zm-64 268c0 10.7-12.9 16-20.5 8.5L104 376H76c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h28l35.5-36.5c7.6-7.6 20.5-2.2 20.5 8.5v136zm33.2-47.6c9.1-9.3 9.1-24.1 0-33.4-22.1-22.8 12.2-56.2 34.4-33.5 27.2 27.9 27.2 72.4 0 100.4-21.8 22.3-56.9-10.4-34.4-33.5zm86-117.1c54.4 55.9 54.4 144.8 0 200.8-21.8 22.4-57-10.3-34.4-33.5 36.2-37.2 36.3-96.5 0-133.8-22.1-22.8 12.3-56.3 34.4-33.5zM384 121.9v6.1H256V0h6.1c6.4 0 12.5 2.5 17 7l97.9 98c4.5 4.5 7 10.6 7 16.9z"></path>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">\n    <path fill="currentColor" d="M384 121.941V128H256V0h6.059c6.365 0 12.47 2.529 16.971 7.029l97.941 97.941A24.005 24.005 0 0 1 384 121.941zM248 160c-13.2 0-24-10.8-24-24V0H24C10.745 0 0 10.745 0 24v464c0 13.255 10.745 24 24 24h336c13.255 0 24-10.745 24-24V160H248zM123.206 400.505a5.4 5.4 0 0 1-7.633.246l-64.866-60.812a5.4 5.4 0 0 1 0-7.879l64.866-60.812a5.4 5.4 0 0 1 7.633.246l19.579 20.885a5.4 5.4 0 0 1-.372 7.747L101.65 336l40.763 35.874a5.4 5.4 0 0 1 .372 7.747l-19.579 20.884zm51.295 50.479l-27.453-7.97a5.402 5.402 0 0 1-3.681-6.692l61.44-211.626a5.402 5.402 0 0 1 6.692-3.681l27.452 7.97a5.4 5.4 0 0 1 3.68 6.692l-61.44 211.626a5.397 5.397 0 0 1-6.69 3.681zm160.792-111.045l-64.866 60.812a5.4 5.4 0 0 1-7.633-.246l-19.58-20.885a5.4 5.4 0 0 1 .372-7.747L284.35 336l-40.763-35.874a5.4 5.4 0 0 1-.372-7.747l19.58-20.885a5.4 5.4 0 0 1 7.633-.246l64.866 60.812a5.4 5.4 0 0 1-.001 7.879z"></path>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">\n    <path fill="currentColor" d="M224 136V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zm-96 144c0 4.42-3.58 8-8 8h-8c-8.84 0-16 7.16-16 16v32c0 8.84 7.16 16 16 16h8c4.42 0 8 3.58 8 8v16c0 4.42-3.58 8-8 8h-8c-26.51 0-48-21.49-48-48v-32c0-26.51 21.49-48 48-48h8c4.42 0 8 3.58 8 8v16zm44.27 104H160c-4.42 0-8-3.58-8-8v-16c0-4.42 3.58-8 8-8h12.27c5.95 0 10.41-3.5 10.41-6.62 0-1.3-.75-2.66-2.12-3.84l-21.89-18.77c-8.47-7.22-13.33-17.48-13.33-28.14 0-21.3 19.02-38.62 42.41-38.62H200c4.42 0 8 3.58 8 8v16c0 4.42-3.58 8-8 8h-12.27c-5.95 0-10.41 3.5-10.41 6.62 0 1.3.75 2.66 2.12 3.84l21.89 18.77c8.47 7.22 13.33 17.48 13.33 28.14.01 21.29-19 38.62-42.39 38.62zM256 264v20.8c0 20.27 5.7 40.17 16 56.88 10.3-16.7 16-36.61 16-56.88V264c0-4.42 3.58-8 8-8h16c4.42 0 8 3.58 8 8v20.8c0 35.48-12.88 68.89-36.28 94.09-3.02 3.25-7.27 5.11-11.72 5.11s-8.7-1.86-11.72-5.11c-23.4-25.2-36.28-58.61-36.28-94.09V264c0-4.42 3.58-8 8-8h16c4.42 0 8 3.58 8 8zm121-159L279.1 7c-4.5-4.5-10.6-7-17-7H256v128h128v-6.1c0-6.3-2.5-12.4-7-16.9z"></path>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">\n    <path fill="currentColor" d="M224 136V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zm60.1 106.5L224 336l60.1 93.5c5.1 8-.6 18.5-10.1 18.5h-34.9c-4.4 0-8.5-2.4-10.6-6.3C208.9 405.5 192 373 192 373c-6.4 14.8-10 20-36.6 68.8-2.1 3.9-6.1 6.3-10.5 6.3H110c-9.5 0-15.2-10.5-10.1-18.5l60.3-93.5-60.3-93.5c-5.2-8 .6-18.5 10.1-18.5h34.8c4.4 0 8.5 2.4 10.6 6.3 26.1 48.8 20 33.6 36.6 68.5 0 0 6.1-11.7 36.6-68.5 2.1-3.9 6.2-6.3 10.6-6.3H274c9.5-.1 15.2 10.4 10.1 18.4zM384 121.9v6.1H256V0h6.1c6.4 0 12.5 2.5 17 7l97.9 98c4.5 4.5 7 10.6 7 16.9z"></path>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">\n    <path fill="currentColor" d="M224 136V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zm64 236c0 6.6-5.4 12-12 12H108c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12v8zm0-64c0 6.6-5.4 12-12 12H108c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12v8zm0-72v8c0 6.6-5.4 12-12 12H108c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12zm96-114.1v6.1H256V0h6.1c6.4 0 12.5 2.5 17 7l97.9 98c4.5 4.5 7 10.6 7 16.9z"></path>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 34 30">\n    <path d="M511,172.11v22.71a1.17,1.17,0,0,1-1.17,1.18H478.17a1.17,1.17,0,0,1-1.17-1.18V167.18a1.16,1.16,0,0,1,1.15-1.18h12.7a1.16,1.16,0,0,1,1.15,1.18V171h17.81A1.15,1.15,0,0,1,511,172.11Z" transform="translate(-477 -166)"/>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">\n    <path fill="currentColor" d="M384 121.941V128H256V0h6.059a24 24 0 0 1 16.97 7.029l97.941 97.941a24.002 24.002 0 0 1 7.03 16.971zM248 160c-13.2 0-24-10.8-24-24V0H24C10.745 0 0 10.745 0 24v464c0 13.255 10.745 24 24 24h336c13.255 0 24-10.745 24-24V160H248zm-135.455 16c26.51 0 48 21.49 48 48s-21.49 48-48 48-48-21.49-48-48 21.491-48 48-48zm208 240h-256l.485-48.485L104.545 328c4.686-4.686 11.799-4.201 16.485.485L160.545 368 264.06 264.485c4.686-4.686 12.284-4.686 16.971 0L320.545 304v112z"></path>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">\n    <path fill="currentColor" d="M181.9 256.1c-5-16-4.9-46.9-2-46.9 8.4 0 7.6 36.9 2 46.9zm-1.7 47.2c-7.7 20.2-17.3 43.3-28.4 62.7 18.3-7 39-17.2 62.9-21.9-12.7-9.6-24.9-23.4-34.5-40.8zM86.1 428.1c0 .8 13.2-5.4 34.9-40.2-6.7 6.3-29.1 24.5-34.9 40.2zM248 160h136v328c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V24C0 10.7 10.7 0 24 0h200v136c0 13.2 10.8 24 24 24zm-8 171.8c-20-12.2-33.3-29-42.7-53.8 4.5-18.5 11.6-46.6 6.2-64.2-4.7-29.4-42.4-26.5-47.8-6.8-5 18.3-.4 44.1 8.1 77-11.6 27.6-28.7 64.6-40.8 85.8-.1 0-.1.1-.2.1-27.1 13.9-73.6 44.5-54.5 68 5.6 6.9 16 10 21.5 10 17.9 0 35.7-18 61.1-61.8 25.8-8.5 54.1-19.1 79-23.2 21.7 11.8 47.1 19.5 64 19.5 29.2 0 31.2-32 19.7-43.4-13.9-13.6-54.3-9.7-73.6-7.2zM377 105L279 7c-4.5-4.5-10.6-7-17-7h-6v128h128v-6.1c0-6.3-2.5-12.4-7-16.9zm-74.1 255.3c4.1-2.7-2.5-11.9-42.8-9 37.1 15.8 42.8 9 42.8 9z"></path>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">\n    <path fill="currentColor" d="M384 121.941V128H256V0h6.059c6.365 0 12.47 2.529 16.971 7.029l97.941 97.941A24.005 24.005 0 0 1 384 121.941zM224 136V0H24C10.745 0 0 10.745 0 24v464c0 13.255 10.745 24 24 24h336c13.255 0 24-10.745 24-24V160H248c-13.2 0-24-10.8-24-24zm96 144.016v111.963c0 21.445-25.943 31.998-40.971 16.971L224 353.941V392c0 13.255-10.745 24-24 24H88c-13.255 0-24-10.745-24-24V280c0-13.255 10.745-24 24-24h112c13.255 0 24 10.745 24 24v38.059l55.029-55.013c15.011-15.01 40.971-4.491 40.971 16.97z"></path>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            (e.default =
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">\n    <path fill="currentColor" d="M224 136V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zm57.1 120H305c7.7 0 13.4 7.1 11.7 14.7l-38 168c-1.2 5.5-6.1 9.3-11.7 9.3h-38c-5.5 0-10.3-3.8-11.6-9.1-25.8-103.5-20.8-81.2-25.6-110.5h-.5c-1.1 14.3-2.4 17.4-25.6 110.5-1.3 5.3-6.1 9.1-11.6 9.1H117c-5.6 0-10.5-3.9-11.7-9.4l-37.8-168c-1.7-7.5 4-14.6 11.7-14.6h24.5c5.7 0 10.7 4 11.8 9.7 15.6 78 20.1 109.5 21 122.2 1.6-10.2 7.3-32.7 29.4-122.7 1.3-5.4 6.1-9.1 11.7-9.1h29.1c5.6 0 10.4 3.8 11.7 9.2 24 100.4 28.8 124 29.6 129.4-.2-11.2-2.6-17.8 21.6-129.2 1-5.6 5.9-9.5 11.5-9.5zM384 121.9v6.1H256V0h6.1c6.4 0 12.5 2.5 17 7l97.9 98c4.5 4.5 7 10.6 7 16.9z"></path>\n</svg>');
    },
    function (t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
        const r = !0,
            s = !0,
            i = !0,
            o = !0;
        class a {
            constructor(t, e = {}) {
                (this.label = t),
                    (this.keyword = e.keyword),
                    (this.beforeExpr = !!e.beforeExpr),
                    (this.startsExpr = !!e.startsExpr),
                    (this.rightAssociative = !!e.rightAssociative),
                    (this.isLoop = !!e.isLoop),
                    (this.isAssign = !!e.isAssign),
                    (this.prefix = !!e.prefix),
                    (this.postfix = !!e.postfix),
                    (this.binop = null != e.binop ? e.binop : null),
                    (this.updateContext = null);
            }
        }
        const c = new Map();
        function l(t, e = {}) {
            e.keyword = t;
            const n = new a(t, e);
            return c.set(t, n), n;
        }
        function u(t, e) {
            return new a(t, { beforeExpr: r, binop: e });
        }
        const h = {
                num: new a("num", { startsExpr: s }),
                bigint: new a("bigint", { startsExpr: s }),
                decimal: new a("decimal", { startsExpr: s }),
                regexp: new a("regexp", { startsExpr: s }),
                string: new a("string", { startsExpr: s }),
                name: new a("name", { startsExpr: s }),
                eof: new a("eof"),
                bracketL: new a("[", { beforeExpr: r, startsExpr: s }),
                bracketHashL: new a("#[", { beforeExpr: r, startsExpr: s }),
                bracketBarL: new a("[|", { beforeExpr: r, startsExpr: s }),
                bracketR: new a("]"),
                bracketBarR: new a("|]"),
                braceL: new a("{", { beforeExpr: r, startsExpr: s }),
                braceBarL: new a("{|", { beforeExpr: r, startsExpr: s }),
                braceHashL: new a("#{", { beforeExpr: r, startsExpr: s }),
                braceR: new a("}"),
                braceBarR: new a("|}"),
                parenL: new a("(", { beforeExpr: r, startsExpr: s }),
                parenR: new a(")"),
                comma: new a(",", { beforeExpr: r }),
                semi: new a(";", { beforeExpr: r }),
                colon: new a(":", { beforeExpr: r }),
                doubleColon: new a("::", { beforeExpr: r }),
                dot: new a("."),
                question: new a("?", { beforeExpr: r }),
                questionDot: new a("?."),
                arrow: new a("=>", { beforeExpr: r }),
                template: new a("template"),
                ellipsis: new a("...", { beforeExpr: r }),
                backQuote: new a("`", { startsExpr: s }),
                dollarBraceL: new a("${", { beforeExpr: r, startsExpr: s }),
                at: new a("@"),
                hash: new a("#", { startsExpr: s }),
                interpreterDirective: new a("#!..."),
                eq: new a("=", { beforeExpr: r, isAssign: true }),
                assign: new a("_=", { beforeExpr: r, isAssign: true }),
                incDec: new a("++/--", {
                    prefix: o,
                    postfix: !0,
                    startsExpr: s,
                }),
                bang: new a("!", { beforeExpr: r, prefix: o, startsExpr: s }),
                tilde: new a("~", { beforeExpr: r, prefix: o, startsExpr: s }),
                pipeline: u("|>", 0),
                nullishCoalescing: u("??", 1),
                logicalOR: u("||", 1),
                logicalAND: u("&&", 2),
                bitwiseOR: u("|", 3),
                bitwiseXOR: u("^", 4),
                bitwiseAND: u("&", 5),
                equality: u("==/!=/===/!==", 6),
                relational: u("</>/<=/>=", 7),
                bitShift: u("<</>>/>>>", 8),
                plusMin: new a("+/-", {
                    beforeExpr: r,
                    binop: 9,
                    prefix: o,
                    startsExpr: s,
                }),
                modulo: new a("%", { beforeExpr: r, binop: 10, startsExpr: s }),
                star: new a("*", { binop: 10 }),
                slash: u("/", 10),
                exponent: new a("**", {
                    beforeExpr: r,
                    binop: 11,
                    rightAssociative: !0,
                }),
                _break: l("break"),
                _case: l("case", { beforeExpr: r }),
                _catch: l("catch"),
                _continue: l("continue"),
                _debugger: l("debugger"),
                _default: l("default", { beforeExpr: r }),
                _do: l("do", { isLoop: i, beforeExpr: r }),
                _else: l("else", { beforeExpr: r }),
                _finally: l("finally"),
                _for: l("for", { isLoop: i }),
                _function: l("function", { startsExpr: s }),
                _if: l("if"),
                _return: l("return", { beforeExpr: r }),
                _switch: l("switch"),
                _throw: l("throw", { beforeExpr: r, prefix: o, startsExpr: s }),
                _try: l("try"),
                _var: l("var"),
                _const: l("const"),
                _while: l("while", { isLoop: i }),
                _with: l("with"),
                _new: l("new", { beforeExpr: r, startsExpr: s }),
                _this: l("this", { startsExpr: s }),
                _super: l("super", { startsExpr: s }),
                _class: l("class", { startsExpr: s }),
                _extends: l("extends", { beforeExpr: r }),
                _export: l("export"),
                _import: l("import", { startsExpr: s }),
                _null: l("null", { startsExpr: s }),
                _true: l("true", { startsExpr: s }),
                _false: l("false", { startsExpr: s }),
                _in: l("in", { beforeExpr: r, binop: 7 }),
                _instanceof: l("instanceof", { beforeExpr: r, binop: 7 }),
                _typeof: l("typeof", {
                    beforeExpr: r,
                    prefix: o,
                    startsExpr: s,
                }),
                _void: l("void", { beforeExpr: r, prefix: o, startsExpr: s }),
                _delete: l("delete", {
                    beforeExpr: r,
                    prefix: o,
                    startsExpr: s,
                }),
            },
            p = 128,
            d = 128,
            f = 1024,
            m = 64,
            y = /\r\n?|[\n\u2028\u2029]/,
            g = new RegExp(y.source, "g");
        function v(t) {
            switch (t) {
                case 10:
                case 13:
                case 8232:
                case 8233:
                    return !0;
                default:
                    return !1;
            }
        }
        const b = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
        function x(t) {
            switch (t) {
                case 9:
                case 11:
                case 12:
                case 32:
                case 160:
                case 5760:
                case 8192:
                case 8193:
                case 8194:
                case 8195:
                case 8196:
                case 8197:
                case 8198:
                case 8199:
                case 8200:
                case 8201:
                case 8202:
                case 8239:
                case 8287:
                case 12288:
                case 65279:
                    return !0;
                default:
                    return !1;
            }
        }
        class w {
            constructor(t, e) {
                (this.line = t), (this.column = e);
            }
        }
        class P {
            constructor(t, e) {
                (this.start = t), (this.end = e);
            }
        }
        function A(t) {
            return t[t.length - 1];
        }
        const E = Object.freeze({
            AccessorIsGenerator: "A %0ter cannot be a generator",
            ArgumentsDisallowedInInitializer:
                "'arguments' is not allowed in class field initializer",
            AsyncFunctionInSingleStatementContext:
                "Async functions can only be declared at the top level or inside a block",
            AwaitBindingIdentifier:
                "Can not use 'await' as identifier inside an async function",
            AwaitExpressionFormalParameter:
                "await is not allowed in async function parameters",
            AwaitNotInAsyncFunction:
                "Can not use keyword 'await' outside an async function",
            BadGetterArity: "getter must not have any formal parameters",
            BadSetterArity: "setter must have exactly one formal parameter",
            BadSetterRestParameter:
                "setter function argument must not be a rest parameter",
            ConstructorClassField:
                "Classes may not have a field named 'constructor'",
            ConstructorClassPrivateField:
                "Classes may not have a private field named '#constructor'",
            ConstructorIsAccessor: "Class constructor may not be an accessor",
            ConstructorIsAsync: "Constructor can't be an async function",
            ConstructorIsGenerator: "Constructor can't be a generator",
            DeclarationMissingInitializer: "%0 require an initialization value",
            DecoratorBeforeExport:
                "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax",
            DecoratorConstructor:
                "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
            DecoratorExportClass:
                "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
            DecoratorSemicolon:
                "Decorators must not be followed by a semicolon",
            DeletePrivateField: "Deleting a private field is not allowed",
            DestructureNamedImport:
                "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
            DuplicateConstructor: "Duplicate constructor in the same class",
            DuplicateDefaultExport:
                "Only one default export allowed per module.",
            DuplicateExport:
                "`%0` has already been exported. Exported identifiers must be unique.",
            DuplicateProto: "Redefinition of __proto__ property",
            DuplicateRegExpFlags: "Duplicate regular expression flag",
            ElementAfterRest: "Rest element must be last element",
            EscapedCharNotAnIdentifier: "Invalid Unicode escape",
            ExportDefaultFromAsIdentifier:
                "'from' is not allowed as an identifier after 'export default'",
            ForInOfLoopInitializer:
                "%0 loop variable declaration may not have an initializer",
            GeneratorInSingleStatementContext:
                "Generators can only be declared at the top level or inside a block",
            IllegalBreakContinue: "Unsyntactic %0",
            IllegalLanguageModeDirective:
                "Illegal 'use strict' directive in function with non-simple parameter list",
            IllegalReturn: "'return' outside of function",
            ImportCallArgumentTrailingComma:
                "Trailing comma is disallowed inside import(...) arguments",
            ImportCallArity: "import() requires exactly %0",
            ImportCallNotNewExpression: "Cannot use new with import(...)",
            ImportCallSpreadArgument: "... is not allowed in import()",
            ImportMetaOutsideModule:
                "import.meta may appear only with 'sourceType: \"module\"'",
            ImportOutsideModule:
                "'import' and 'export' may appear only with 'sourceType: \"module\"'",
            InvalidBigIntLiteral: "Invalid BigIntLiteral",
            InvalidCodePoint: "Code point out of bounds",
            InvalidDecimal: "Invalid decimal",
            InvalidDigit: "Expected number in radix %0",
            InvalidEscapeSequence: "Bad character escape sequence",
            InvalidEscapeSequenceTemplate:
                "Invalid escape sequence in template",
            InvalidEscapedReservedWord: "Escape sequence in keyword %0",
            InvalidIdentifier: "Invalid identifier %0",
            InvalidLhs: "Invalid left-hand side in %0",
            InvalidLhsBinding: "Binding invalid left-hand side in %0",
            InvalidNumber: "Invalid number",
            InvalidOrUnexpectedToken: "Unexpected character '%0'",
            InvalidParenthesizedAssignment:
                "Invalid parenthesized assignment pattern",
            InvalidPrivateFieldResolution: "Private name #%0 is not defined",
            InvalidPropertyBindingPattern: "Binding member expression",
            InvalidRecordProperty:
                "Only properties and spread elements are allowed in record definitions",
            InvalidRestAssignmentPattern: "Invalid rest operator's argument",
            LabelRedeclaration: "Label '%0' is already declared",
            LetInLexicalBinding:
                "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
            LineTerminatorBeforeArrow: "No line break is allowed before '=>'",
            MalformedRegExpFlags: "Invalid regular expression flag",
            MissingClassName: "A class name is required",
            MissingEqInAssignment:
                "Only '=' operator can be used for specifying default value.",
            MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX",
            MixingCoalesceWithLogical:
                "Nullish coalescing operator(??) requires parens when mixing with logical operators",
            ModuleAttributeDifferentFromType:
                "The only accepted module attribute is `type`",
            ModuleAttributeInvalidValue:
                "Only string literals are allowed as module attribute values",
            ModuleAttributesWithDuplicateKeys:
                'Duplicate key "%0" is not allowed in module attributes',
            ModuleExportUndefined: "Export '%0' is not defined",
            MultipleDefaultsInSwitch: "Multiple default clauses",
            NewlineAfterThrow: "Illegal newline after throw",
            NoCatchOrFinally: "Missing catch or finally clause",
            NumberIdentifier: "Identifier directly after number",
            NumericSeparatorInEscapeSequence:
                "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences",
            ObsoleteAwaitStar:
                "await* has been removed from the async functions proposal. Use Promise.all() instead.",
            OptionalChainingNoNew:
                "constructors in/after an Optional Chain are not allowed",
            OptionalChainingNoTemplate:
                "Tagged Template Literals are not allowed in optionalChain",
            ParamDupe: "Argument name clash",
            PatternHasAccessor: "Object pattern can't contain getter or setter",
            PatternHasMethod: "Object pattern can't contain methods",
            PipelineBodyNoArrow:
                'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized',
            PipelineBodySequenceExpression:
                "Pipeline body may not be a comma-separated sequence expression",
            PipelineHeadSequenceExpression:
                "Pipeline head should not be a comma-separated sequence expression",
            PipelineTopicUnused:
                "Pipeline is in topic style but does not use topic reference",
            PrimaryTopicNotAllowed:
                "Topic reference was used in a lexical context without topic binding",
            PrimaryTopicRequiresSmartPipeline:
                "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.",
            PrivateInExpectedIn:
                "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`)",
            PrivateNameRedeclaration: "Duplicate private name #%0",
            RecordExpressionBarIncorrectEndSyntaxType:
                "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
            RecordExpressionBarIncorrectStartSyntaxType:
                "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
            RecordExpressionHashIncorrectStartSyntaxType:
                "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
            RecordNoProto: "'__proto__' is not allowed in Record expressions",
            RestTrailingComma: "Unexpected trailing comma after rest element",
            SloppyFunction:
                "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement",
            StaticPrototype:
                "Classes may not have static property named prototype",
            StrictDelete: "Deleting local variable in strict mode",
            StrictEvalArguments: "Assigning to '%0' in strict mode",
            StrictEvalArgumentsBinding: "Binding '%0' in strict mode",
            StrictFunction:
                "In strict mode code, functions can only be declared at top level or inside a block",
            StrictNumericEscape:
                "The only valid numeric escape in strict mode is '\\0'",
            StrictOctalLiteral:
                "Legacy octal literals are not allowed in strict mode",
            StrictWith: "'with' in strict mode",
            SuperNotAllowed:
                "super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
            SuperPrivateField: "Private fields can't be accessed on super",
            TrailingDecorator: "Decorators must be attached to a class element",
            TupleExpressionBarIncorrectEndSyntaxType:
                "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
            TupleExpressionBarIncorrectStartSyntaxType:
                "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
            TupleExpressionHashIncorrectStartSyntaxType:
                "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
            UnexpectedArgumentPlaceholder: "Unexpected argument placeholder",
            UnexpectedAwaitAfterPipelineBody:
                'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal',
            UnexpectedDigitAfterHash: "Unexpected digit after hash token",
            UnexpectedImportExport:
                "'import' and 'export' may only appear at the top level",
            UnexpectedKeyword: "Unexpected keyword '%0'",
            UnexpectedLeadingDecorator:
                "Leading decorators must be attached to a class declaration",
            UnexpectedLexicalDeclaration:
                "Lexical declaration cannot appear in a single-statement context",
            UnexpectedNewTarget: "new.target can only be used in functions",
            UnexpectedNumericSeparator:
                "A numeric separator is only allowed between two digits",
            UnexpectedPrivateField:
                "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).",
            UnexpectedReservedWord: "Unexpected reserved word '%0'",
            UnexpectedSuper:
                "super is only allowed in object methods and classes",
            UnexpectedToken: "Unexpected token '%0'",
            UnexpectedTokenUnaryExponentiation:
                "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
            UnsupportedBind: "Binding should be performed on object property.",
            UnsupportedDecoratorExport:
                "A decorated export must export a class declaration",
            UnsupportedDefaultExport:
                "Only expressions, functions or classes are allowed as the `default` export.",
            UnsupportedImport:
                "import can only be used in import() or import.meta",
            UnsupportedMetaProperty:
                "The only valid meta property for %0 is %0.%1",
            UnsupportedParameterDecorator:
                "Decorators cannot be used to decorate parameters",
            UnsupportedPropertyDecorator:
                "Decorators cannot be used to decorate object literal properties",
            UnsupportedSuper:
                "super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])",
            UnterminatedComment: "Unterminated comment",
            UnterminatedRegExp: "Unterminated regular expression",
            UnterminatedString: "Unterminated string constant",
            UnterminatedTemplate: "Unterminated template",
            VarRedeclaration: "Identifier '%0' has already been declared",
            YieldBindingIdentifier:
                "Can not use 'yield' as identifier inside a generator",
            YieldInParameter: "yield is not allowed in generator parameters",
            ZeroDigitNumericSeparator:
                "Numeric separator can not be used after leading 0",
        });
        function T(t) {
            return (
                null != t &&
                "Property" === t.type &&
                "init" === t.kind &&
                !1 === t.method
            );
        }
        class S {
            constructor(t, e, n, r) {
                (this.token = t),
                    (this.isExpr = !!e),
                    (this.preserveSpace = !!n),
                    (this.override = r);
            }
        }
        const C = {
            braceStatement: new S("{", !1),
            braceExpression: new S("{", !0),
            recordExpression: new S("#{", !0),
            templateQuasi: new S("${", !1),
            parenStatement: new S("(", !1),
            parenExpression: new S("(", !0),
            template: new S("`", !0, !0, (t) => t.readTmplToken()),
            functionExpression: new S("function", !0),
            functionStatement: new S("function", !1),
        };
        (h.parenR.updateContext = h.braceR.updateContext =
            function () {
                if (1 === this.state.context.length)
                    return void (this.state.exprAllowed = !0);
                let t = this.state.context.pop();
                t === C.braceStatement &&
                    "function" === this.curContext().token &&
                    (t = this.state.context.pop()),
                    (this.state.exprAllowed = !t.isExpr);
            }),
            (h.name.updateContext = function (t) {
                let e = !1;
                t !== h.dot &&
                    (("of" === this.state.value &&
                        !this.state.exprAllowed &&
                        t !== h._function &&
                        t !== h._class) ||
                        ("yield" === this.state.value &&
                            this.prodParam.hasYield)) &&
                    (e = !0),
                    (this.state.exprAllowed = e),
                    this.state.isIterator && (this.state.isIterator = !1);
            }),
            (h.braceL.updateContext = function (t) {
                this.state.context.push(
                    this.braceIsBlock(t) ? C.braceStatement : C.braceExpression
                ),
                    (this.state.exprAllowed = !0);
            }),
            (h.dollarBraceL.updateContext = function () {
                this.state.context.push(C.templateQuasi),
                    (this.state.exprAllowed = !0);
            }),
            (h.parenL.updateContext = function (t) {
                const e =
                    t === h._if ||
                    t === h._for ||
                    t === h._with ||
                    t === h._while;
                this.state.context.push(
                    e ? C.parenStatement : C.parenExpression
                ),
                    (this.state.exprAllowed = !0);
            }),
            (h.incDec.updateContext = function () {}),
            (h._function.updateContext = h._class.updateContext =
                function (t) {
                    !t.beforeExpr ||
                    t === h.semi ||
                    t === h._else ||
                    (t === h._return && this.hasPrecedingLineBreak()) ||
                    ((t === h.colon || t === h.braceL) &&
                        this.curContext() === C.b_stat)
                        ? this.state.context.push(C.functionStatement)
                        : this.state.context.push(C.functionExpression),
                        (this.state.exprAllowed = !1);
                }),
            (h.backQuote.updateContext = function () {
                this.curContext() === C.template
                    ? this.state.context.pop()
                    : this.state.context.push(C.template),
                    (this.state.exprAllowed = !1);
            }),
            (h.braceHashL.updateContext = function () {
                this.state.context.push(C.recordExpression),
                    (this.state.exprAllowed = !0);
            });
        let O =
                "---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",
            k =
                "----------------------------------------------------------------------------------------------------------------------------------------------------";
        const _ = new RegExp("[" + O + "]"),
            N = new RegExp("[" + O + k + "]");
        O = k = null;
        const I = [
                0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268,
                28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43,
                157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153,
                5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1,
                11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28,
                4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72,
                56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21,
                107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9,
                34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2,
                0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2,
                4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2,
                0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230,
                43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7,
                3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0,
                35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22,
                0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103,
                110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29,
                19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12,
                65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3,
                9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3,
                0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2,
                27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24,
                2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6,
                17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1,
                2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2,
                2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3,
                2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421,
                42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507,
                4938,
            ],
            j = [
                509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5,
                0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9,
                16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2,
                49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1,
                2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5,
                0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9,
                9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1,
                13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47,
                15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2,
                6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135,
                4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1,
                5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5,
                49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4,
                262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719,
                239,
            ];
        function L(t, e) {
            let n = 65536;
            for (let r = 0, s = e.length; r < s; r += 2) {
                if (((n += e[r]), n > t)) return !1;
                if (((n += e[r + 1]), n >= t)) return !0;
            }
            return !1;
        }
        function M(t) {
            return t < 65
                ? 36 === t
                : t <= 90 ||
                      (t < 97
                          ? 95 === t
                          : t <= 122 ||
                            (t <= 65535
                                ? t >= 170 && _.test(String.fromCharCode(t))
                                : L(t, I)));
        }
        function R(t) {
            return t < 48
                ? 36 === t
                : t < 58 ||
                      (!(t < 65) &&
                          (t <= 90 ||
                              (t < 97
                                  ? 95 === t
                                  : t <= 122 ||
                                    (t <= 65535
                                        ? t >= 170 &&
                                          N.test(String.fromCharCode(t))
                                        : L(t, I) || L(t, j)))));
        }
        const D = [
                "implements",
                "interface",
                "let",
                "package",
                "private",
                "protected",
                "public",
                "static",
                "yield",
            ],
            F = ["eval", "arguments"],
            B = new Set([
                "break",
                "case",
                "catch",
                "continue",
                "debugger",
                "default",
                "do",
                "else",
                "finally",
                "for",
                "function",
                "if",
                "return",
                "switch",
                "throw",
                "try",
                "var",
                "const",
                "while",
                "with",
                "new",
                "this",
                "super",
                "class",
                "extends",
                "export",
                "import",
                "null",
                "true",
                "false",
                "in",
                "instanceof",
                "typeof",
                "void",
                "delete",
            ]),
            U = new Set(D),
            V = new Set(F);
        function q(t, e) {
            return (e && "await" === t) || "enum" === t;
        }
        function $(t, e) {
            return q(t, e) || U.has(t);
        }
        function z(t) {
            return V.has(t);
        }
        function H(t, e) {
            return $(t, e) || z(t);
        }
        const W = /^in(stanceof)?$/;
        const G = new Set([
                "_",
                "any",
                "bool",
                "boolean",
                "empty",
                "extends",
                "false",
                "interface",
                "mixed",
                "null",
                "number",
                "static",
                "string",
                "true",
                "typeof",
                "void",
            ]),
            K = Object.freeze({
                AmbiguousConditionalArrow:
                    "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
                AmbiguousDeclareModuleKind:
                    "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module",
                AssignReservedType: "Cannot overwrite reserved type %0",
                DeclareClassElement:
                    "The `declare` modifier can only appear on class fields.",
                DeclareClassFieldInitializer:
                    "Initializers are not allowed in fields with the `declare` modifier.",
                DuplicateDeclareModuleExports:
                    "Duplicate `declare module.exports` statement",
                EnumBooleanMemberNotInitialized:
                    "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
                EnumDuplicateMemberName:
                    "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
                EnumInconsistentMemberValues:
                    "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
                EnumInvalidExplicitType:
                    "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
                EnumInvalidExplicitTypeUnknownSupplied:
                    "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
                EnumInvalidMemberInitializerPrimaryType:
                    "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
                EnumInvalidMemberInitializerSymbolType:
                    "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
                EnumInvalidMemberInitializerUnknownType:
                    "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
                EnumInvalidMemberName:
                    "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
                EnumNumberMemberNotInitialized:
                    "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
                EnumStringMemberInconsistentlyInitailized:
                    "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
                ImportTypeShorthandOnlyInPureImport:
                    "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements",
                InexactInsideExact:
                    "Explicit inexact syntax cannot appear inside an explicit exact object type",
                InexactInsideNonObject:
                    "Explicit inexact syntax cannot appear in class or interface definitions",
                InexactVariance: "Explicit inexact syntax cannot have variance",
                InvalidNonTypeImportInDeclareModule:
                    "Imports within a `declare module` body must always be `import type` or `import typeof`",
                MissingTypeParamDefault:
                    "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
                NestedDeclareModule:
                    "`declare module` cannot be used inside another `declare module`",
                NestedFlowComment:
                    "Cannot have a flow comment inside another flow comment",
                OptionalBindingPattern:
                    "A binding pattern parameter cannot be optional in an implementation signature.",
                SpreadVariance: "Spread properties cannot have variance",
                TypeBeforeInitializer:
                    "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
                TypeCastInPattern:
                    "The type cast expression is expected to be wrapped with parenthesis",
                UnexpectedExplicitInexactInObject:
                    "Explicit inexact syntax must appear at the end of an inexact object",
                UnexpectedReservedType: "Unexpected reserved type %0",
                UnexpectedReservedUnderscore:
                    "`_` is only allowed as a type argument to call or new",
                UnexpectedSpaceBetweenModuloChecks:
                    "Spaces between `%` and `checks` are not allowed here.",
                UnexpectedSpreadType:
                    "Spread operator cannot appear in class or interface definitions",
                UnexpectedSubtractionOperand:
                    'Unexpected token, expected "number" or "bigint"',
                UnexpectedTokenAfterTypeParameter:
                    "Expected an arrow function after this type parameter declaration",
                UnexpectedTypeParameterBeforeAsyncArrowFunction:
                    "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`",
                UnsupportedDeclareExportKind:
                    "`declare export %0` is not supported. Use `%1` instead",
                UnsupportedStatementInDeclareModule:
                    "Only declares and type imports are allowed inside declare module",
                UnterminatedFlowComment: "Unterminated flow-comment",
            });
        function J(t) {
            return "type" === t.importKind || "typeof" === t.importKind;
        }
        function X(t) {
            return (
                (t.type === h.name || !!t.type.keyword) && "from" !== t.value
            );
        }
        const Y = {
            const: "declare export var",
            let: "declare export var",
            type: "export type",
            interface: "export interface",
        };
        const Q = /\*?\s*@((?:no)?flow)\b/;
        const Z = {
                quot: '"',
                amp: "&",
                apos: "'",
                lt: "<",
                gt: ">",
                nbsp: "",
                iexcl: "",
                cent: "",
                pound: "",
                curren: "",
                yen: "",
                brvbar: "",
                sect: "",
                uml: "",
                copy: "",
                ordf: "",
                laquo: "",
                not: "",
                shy: "",
                reg: "",
                macr: "",
                deg: "",
                plusmn: "",
                sup2: "",
                sup3: "",
                acute: "",
                micro: "",
                para: "",
                middot: "",
                cedil: "",
                sup1: "",
                ordm: "",
                raquo: "",
                frac14: "",
                frac12: "",
                frac34: "",
                iquest: "",
                Agrave: "",
                Aacute: "",
                Acirc: "",
                Atilde: "",
                Auml: "",
                Aring: "",
                AElig: "",
                Ccedil: "",
                Egrave: "",
                Eacute: "",
                Ecirc: "",
                Euml: "",
                Igrave: "",
                Iacute: "",
                Icirc: "",
                Iuml: "",
                ETH: "",
                Ntilde: "",
                Ograve: "",
                Oacute: "",
                Ocirc: "",
                Otilde: "",
                Ouml: "",
                times: "",
                Oslash: "",
                Ugrave: "",
                Uacute: "",
                Ucirc: "",
                Uuml: "",
                Yacute: "",
                THORN: "",
                szlig: "",
                agrave: "",
                aacute: "",
                acirc: "",
                atilde: "",
                auml: "",
                aring: "",
                aelig: "",
                ccedil: "",
                egrave: "",
                eacute: "",
                ecirc: "",
                euml: "",
                igrave: "",
                iacute: "",
                icirc: "",
                iuml: "",
                eth: "",
                ntilde: "",
                ograve: "",
                oacute: "",
                ocirc: "",
                otilde: "",
                ouml: "",
                divide: "",
                oslash: "",
                ugrave: "",
                uacute: "",
                ucirc: "",
                uuml: "",
                yacute: "",
                thorn: "",
                yuml: "",
                OElig: "",
                oelig: "",
                Scaron: "",
                scaron: "",
                Yuml: "",
                fnof: "",
                circ: "",
                tilde: "",
                Alpha: "",
                Beta: "",
                Gamma: "",
                Delta: "",
                Epsilon: "",
                Zeta: "",
                Eta: "",
                Theta: "",
                Iota: "",
                Kappa: "",
                Lambda: "",
                Mu: "",
                Nu: "",
                Xi: "",
                Omicron: "",
                Pi: "",
                Rho: "",
                Sigma: "",
                Tau: "",
                Upsilon: "",
                Phi: "",
                Chi: "",
                Psi: "",
                Omega: "",
                alpha: "",
                beta: "",
                gamma: "",
                delta: "",
                epsilon: "",
                zeta: "",
                eta: "",
                theta: "",
                iota: "",
                kappa: "",
                lambda: "",
                mu: "",
                nu: "",
                xi: "",
                omicron: "",
                pi: "",
                rho: "",
                sigmaf: "",
                sigma: "",
                tau: "",
                upsilon: "",
                phi: "",
                chi: "",
                psi: "",
                omega: "",
                thetasym: "",
                upsih: "",
                piv: "",
                ensp: "",
                emsp: "",
                thinsp: "",
                zwnj: "",
                zwj: "",
                lrm: "",
                rlm: "",
                ndash: "",
                mdash: "",
                lsquo: "",
                rsquo: "",
                sbquo: "",
                ldquo: "",
                rdquo: "",
                bdquo: "",
                dagger: "",
                Dagger: "",
                bull: "",
                hellip: "",
                permil: "",
                prime: "",
                Prime: "",
                lsaquo: "",
                rsaquo: "",
                oline: "",
                frasl: "",
                euro: "",
                image: "",
                weierp: "",
                real: "",
                trade: "",
                alefsym: "",
                larr: "",
                uarr: "",
                rarr: "",
                darr: "",
                harr: "",
                crarr: "",
                lArr: "",
                uArr: "",
                rArr: "",
                dArr: "",
                hArr: "",
                forall: "",
                part: "",
                exist: "",
                empty: "",
                nabla: "",
                isin: "",
                notin: "",
                ni: "",
                prod: "",
                sum: "",
                minus: "",
                lowast: "",
                radic: "",
                prop: "",
                infin: "",
                ang: "",
                and: "",
                or: "",
                cap: "",
                cup: "",
                int: "",
                there4: "",
                sim: "",
                cong: "",
                asymp: "",
                ne: "",
                equiv: "",
                le: "",
                ge: "",
                sub: "",
                sup: "",
                nsub: "",
                sube: "",
                supe: "",
                oplus: "",
                otimes: "",
                perp: "",
                sdot: "",
                lceil: "",
                rceil: "",
                lfloor: "",
                rfloor: "",
                lang: "",
                rang: "",
                loz: "",
                spades: "",
                clubs: "",
                hearts: "",
                diams: "",
            },
            tt = /^[\da-fA-F]+$/,
            et = /^\d+$/,
            nt = Object.freeze({
                AttributeIsEmpty:
                    "JSX attributes must only be assigned a non-empty expression",
                MissingClosingTagFragment:
                    "Expected corresponding JSX closing tag for <>",
                MissingClosingTagElement:
                    "Expected corresponding JSX closing tag for <%0>",
                UnsupportedJsxValue:
                    "JSX value should be either an expression or a quoted JSX text",
                UnterminatedJsxContent: "Unterminated JSX contents",
                UnwrappedAdjacentJSXElements:
                    "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?",
            });
        function rt(t) {
            return (
                !!t &&
                ("JSXOpeningFragment" === t.type ||
                    "JSXClosingFragment" === t.type)
            );
        }
        function st(t) {
            if ("JSXIdentifier" === t.type) return t.name;
            if ("JSXNamespacedName" === t.type)
                return t.namespace.name + ":" + t.name.name;
            if ("JSXMemberExpression" === t.type)
                return st(t.object) + "." + st(t.property);
            throw new Error("Node had unexpected type: " + t.type);
        }
        (C.j_oTag = new S("<tag", !1)),
            (C.j_cTag = new S("</tag", !1)),
            (C.j_expr = new S("<tag>...</tag>", !0, !0)),
            (h.jsxName = new a("jsxName")),
            (h.jsxText = new a("jsxText", { beforeExpr: !0 })),
            (h.jsxTagStart = new a("jsxTagStart", { startsExpr: !0 })),
            (h.jsxTagEnd = new a("jsxTagEnd")),
            (h.jsxTagStart.updateContext = function () {
                this.state.context.push(C.j_expr),
                    this.state.context.push(C.j_oTag),
                    (this.state.exprAllowed = !1);
            }),
            (h.jsxTagEnd.updateContext = function (t) {
                const e = this.state.context.pop();
                (e === C.j_oTag && t === h.slash) || e === C.j_cTag
                    ? (this.state.context.pop(),
                      (this.state.exprAllowed = this.curContext() === C.j_expr))
                    : (this.state.exprAllowed = !0);
            });
        class it {
            constructor(t) {
                (this.var = []),
                    (this.lexical = []),
                    (this.functions = []),
                    (this.flags = t);
            }
        }
        class ot {
            constructor(t, e) {
                (this.scopeStack = []),
                    (this.undefinedExports = new Map()),
                    (this.undefinedPrivateNames = new Map()),
                    (this.raise = t),
                    (this.inModule = e);
            }
            get inFunction() {
                return (2 & this.currentVarScope().flags) > 0;
            }
            get allowSuper() {
                return (16 & this.currentThisScope().flags) > 0;
            }
            get allowDirectSuper() {
                return (32 & this.currentThisScope().flags) > 0;
            }
            get inClass() {
                return (64 & this.currentThisScope().flags) > 0;
            }
            get inNonArrowFunction() {
                return (2 & this.currentThisScope().flags) > 0;
            }
            get treatFunctionsAsVar() {
                return this.treatFunctionsAsVarInScope(this.currentScope());
            }
            createScope(t) {
                return new it(t);
            }
            enter(t) {
                this.scopeStack.push(this.createScope(t));
            }
            exit() {
                this.scopeStack.pop();
            }
            treatFunctionsAsVarInScope(t) {
                return !!(2 & t.flags || (!this.inModule && 1 & t.flags));
            }
            declareName(t, e, n) {
                let r = this.currentScope();
                if (8 & e || 16 & e)
                    this.checkRedeclarationInScope(r, t, e, n),
                        16 & e ? r.functions.push(t) : r.lexical.push(t),
                        8 & e && this.maybeExportDefined(r, t);
                else if (4 & e)
                    for (
                        let s = this.scopeStack.length - 1;
                        s >= 0 &&
                        ((r = this.scopeStack[s]),
                        this.checkRedeclarationInScope(r, t, e, n),
                        r.var.push(t),
                        this.maybeExportDefined(r, t),
                        !(131 & r.flags));
                        --s
                    );
                this.inModule && 1 & r.flags && this.undefinedExports.delete(t);
            }
            maybeExportDefined(t, e) {
                this.inModule && 1 & t.flags && this.undefinedExports.delete(e);
            }
            checkRedeclarationInScope(t, e, n, r) {
                this.isRedeclaredInScope(t, e, n) &&
                    this.raise(r, E.VarRedeclaration, e);
            }
            isRedeclaredInScope(t, e, n) {
                return (
                    !!(1 & n) &&
                    (8 & n
                        ? t.lexical.indexOf(e) > -1 ||
                          t.functions.indexOf(e) > -1 ||
                          t.var.indexOf(e) > -1
                        : 16 & n
                        ? t.lexical.indexOf(e) > -1 ||
                          (!this.treatFunctionsAsVarInScope(t) &&
                              t.var.indexOf(e) > -1)
                        : (t.lexical.indexOf(e) > -1 &&
                              !(8 & t.flags && t.lexical[0] === e)) ||
                          (!this.treatFunctionsAsVarInScope(t) &&
                              t.functions.indexOf(e) > -1))
                );
            }
            checkLocalExport(t) {
                -1 === this.scopeStack[0].lexical.indexOf(t.name) &&
                    -1 === this.scopeStack[0].var.indexOf(t.name) &&
                    -1 === this.scopeStack[0].functions.indexOf(t.name) &&
                    this.undefinedExports.set(t.name, t.start);
            }
            currentScope() {
                return this.scopeStack[this.scopeStack.length - 1];
            }
            currentVarScope() {
                for (let t = this.scopeStack.length - 1; ; t--) {
                    const e = this.scopeStack[t];
                    if (131 & e.flags) return e;
                }
            }
            currentThisScope() {
                for (let t = this.scopeStack.length - 1; ; t--) {
                    const e = this.scopeStack[t];
                    if ((131 & e.flags || 64 & e.flags) && !(4 & e.flags))
                        return e;
                }
            }
        }
        class at extends it {
            constructor(...t) {
                super(...t),
                    (this.types = []),
                    (this.enums = []),
                    (this.constEnums = []),
                    (this.classes = []),
                    (this.exportOnlyBindings = []);
            }
        }
        class ct extends ot {
            createScope(t) {
                return new at(t);
            }
            declareName(t, e, n) {
                const r = this.currentScope();
                if (e & f)
                    return (
                        this.maybeExportDefined(r, t),
                        void r.exportOnlyBindings.push(t)
                    );
                super.declareName(...arguments),
                    2 & e &&
                        (1 & e ||
                            (this.checkRedeclarationInScope(r, t, e, n),
                            this.maybeExportDefined(r, t)),
                        r.types.push(t)),
                    256 & e && r.enums.push(t),
                    512 & e && r.constEnums.push(t),
                    e & d && r.classes.push(t);
            }
            isRedeclaredInScope(t, e, n) {
                if (t.enums.indexOf(e) > -1) {
                    if (256 & n) {
                        return !!(512 & n) !== t.constEnums.indexOf(e) > -1;
                    }
                    return !0;
                }
                return n & d && t.classes.indexOf(e) > -1
                    ? t.lexical.indexOf(e) > -1 && !!(1 & n)
                    : !!(2 & n && t.types.indexOf(e) > -1) ||
                          super.isRedeclaredInScope(...arguments);
            }
            checkLocalExport(t) {
                -1 === this.scopeStack[0].types.indexOf(t.name) &&
                    -1 ===
                        this.scopeStack[0].exportOnlyBindings.indexOf(t.name) &&
                    super.checkLocalExport(t);
            }
        }
        class lt {
            constructor() {
                this.stacks = [];
            }
            enter(t) {
                this.stacks.push(t);
            }
            exit() {
                this.stacks.pop();
            }
            currentFlags() {
                return this.stacks[this.stacks.length - 1];
            }
            get hasAwait() {
                return (2 & this.currentFlags()) > 0;
            }
            get hasYield() {
                return (1 & this.currentFlags()) > 0;
            }
            get hasReturn() {
                return (4 & this.currentFlags()) > 0;
            }
            get hasIn() {
                return (8 & this.currentFlags()) > 0;
            }
        }
        function ut(t, e) {
            return (t ? 2 : 0) | (e ? 1 : 0);
        }
        function ht(t) {
            if (null == t) throw new Error(`Unexpected ${t} value.`);
            return t;
        }
        function pt(t) {
            if (!t) throw new Error("Assert fail");
        }
        const dt = Object.freeze({
            ClassMethodHasDeclare:
                "Class methods cannot have the 'declare' modifier",
            ClassMethodHasReadonly:
                "Class methods cannot have the 'readonly' modifier",
            DeclareClassFieldHasInitializer:
                "'declare' class fields cannot have an initializer",
            DuplicateModifier: "Duplicate modifier: '%0'",
            EmptyHeritageClauseType: "'%0' list cannot be empty.",
            IndexSignatureHasAbstract:
                "Index signatures cannot have the 'abstract' modifier",
            IndexSignatureHasAccessibility:
                "Index signatures cannot have an accessibility modifier ('%0')",
            IndexSignatureHasStatic:
                "Index signatures cannot have the 'static' modifier",
            InvalidTupleMemberLabel:
                "Tuple members must be labeled with a simple identifier.",
            MixedLabeledAndUnlabeledElements:
                "Tuple members must all have names or all not have names.",
            OptionalTypeBeforeRequired:
                "A required element cannot follow an optional element.",
            PatternIsOptional:
                "A binding pattern parameter cannot be optional in an implementation signature.",
            PrivateElementHasAbstract:
                "Private elements cannot have the 'abstract' modifier.",
            PrivateElementHasAccessibility:
                "Private elements cannot have an accessibility modifier ('%0')",
            TemplateTypeHasSubstitution:
                "Template literal types cannot have any substitution",
            TypeAnnotationAfterAssign:
                "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
            UnexpectedReadonly:
                "'readonly' type modifier is only permitted on array and tuple literal types.",
            UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
            UnexpectedTypeCastInParameter:
                "Unexpected type cast in parameter position.",
            UnsupportedImportTypeArgument:
                "Argument in a type import must be a string literal",
            UnsupportedParameterPropertyKind:
                "A parameter property may not be declared using a binding pattern.",
            UnsupportedSignatureParameterKind:
                "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0",
        });
        h.placeholder = new a("%%", { startsExpr: !0 });
        function ft(t, e) {
            return t.some((t) => (Array.isArray(t) ? t[0] === e : t === e));
        }
        function mt(t, e, n) {
            const r = t.find((t) => (Array.isArray(t) ? t[0] === e : t === e));
            return r && Array.isArray(r) ? r[1][n] : null;
        }
        const yt = ["minimal", "smart", "fsharp"],
            gt = ["hash", "bar"];
        const vt = {
                estree: (t) =>
                    class extends t {
                        estreeParseRegExpLiteral({ pattern: t, flags: e }) {
                            let n = null;
                            try {
                                n = new RegExp(t, e);
                            } catch (t) {}
                            const r = this.estreeParseLiteral(n);
                            return (r.regex = { pattern: t, flags: e }), r;
                        }
                        estreeParseBigIntLiteral(t) {
                            const e =
                                    "undefined" != typeof BigInt
                                        ? BigInt(t)
                                        : null,
                                n = this.estreeParseLiteral(e);
                            return (n.bigint = String(n.value || t)), n;
                        }
                        estreeParseDecimalLiteral(t) {
                            const e = this.estreeParseLiteral(null);
                            return (e.decimal = String(e.value || t)), e;
                        }
                        estreeParseLiteral(t) {
                            return this.parseLiteral(t, "Literal");
                        }
                        directiveToStmt(t) {
                            const e = t.value,
                                n = this.startNodeAt(t.start, t.loc.start),
                                r = this.startNodeAt(e.start, e.loc.start);
                            return (
                                (r.value = e.value),
                                (r.raw = e.extra.raw),
                                (n.expression = this.finishNodeAt(
                                    r,
                                    "Literal",
                                    e.end,
                                    e.loc.end
                                )),
                                (n.directive = e.extra.raw.slice(1, -1)),
                                this.finishNodeAt(
                                    n,
                                    "ExpressionStatement",
                                    t.end,
                                    t.loc.end
                                )
                            );
                        }
                        initFunction(t, e) {
                            super.initFunction(t, e), (t.expression = !1);
                        }
                        checkDeclaration(t) {
                            T(t)
                                ? this.checkDeclaration(t.value)
                                : super.checkDeclaration(t);
                        }
                        checkGetterSetterParams(t) {
                            const e = t,
                                n = "get" === e.kind ? 0 : 1,
                                r = e.start;
                            e.value.params.length !== n
                                ? "get" === t.kind
                                    ? this.raise(r, E.BadGetterArity)
                                    : this.raise(r, E.BadSetterArity)
                                : "set" === e.kind &&
                                  "RestElement" === e.value.params[0].type &&
                                  this.raise(r, E.BadSetterRestParameter);
                        }
                        checkLVal(t, e = 64, n, r, s) {
                            switch (t.type) {
                                case "ObjectPattern":
                                    t.properties.forEach((t) => {
                                        this.checkLVal(
                                            "Property" === t.type ? t.value : t,
                                            e,
                                            n,
                                            "object destructuring pattern",
                                            s
                                        );
                                    });
                                    break;
                                default:
                                    super.checkLVal(t, e, n, r, s);
                            }
                        }
                        checkProto(t, e, n, r) {
                            t.method || super.checkProto(t, e, n, r);
                        }
                        isValidDirective(t) {
                            var e;
                            return (
                                "ExpressionStatement" === t.type &&
                                "Literal" === t.expression.type &&
                                "string" == typeof t.expression.value &&
                                !(null == (e = t.expression.extra)
                                    ? void 0
                                    : e.parenthesized)
                            );
                        }
                        stmtToDirective(t) {
                            const e = super.stmtToDirective(t),
                                n = t.expression.value;
                            return (e.value.value = n), e;
                        }
                        parseBlockBody(t, e, n, r) {
                            super.parseBlockBody(t, e, n, r);
                            const s = t.directives.map((t) =>
                                this.directiveToStmt(t)
                            );
                            (t.body = s.concat(t.body)), delete t.directives;
                        }
                        pushClassMethod(t, e, n, r, s, i) {
                            this.parseMethod(e, n, r, s, i, "ClassMethod", !0),
                                e.typeParameters &&
                                    ((e.value.typeParameters =
                                        e.typeParameters),
                                    delete e.typeParameters),
                                t.body.push(e);
                        }
                        parseExprAtom(t) {
                            switch (this.state.type) {
                                case h.num:
                                case h.string:
                                    return this.estreeParseLiteral(
                                        this.state.value
                                    );
                                case h.regexp:
                                    return this.estreeParseRegExpLiteral(
                                        this.state.value
                                    );
                                case h.bigint:
                                    return this.estreeParseBigIntLiteral(
                                        this.state.value
                                    );
                                case h.decimal:
                                    return this.estreeParseDecimalLiteral(
                                        this.state.value
                                    );
                                case h._null:
                                    return this.estreeParseLiteral(null);
                                case h._true:
                                    return this.estreeParseLiteral(!0);
                                case h._false:
                                    return this.estreeParseLiteral(!1);
                                default:
                                    return super.parseExprAtom(t);
                            }
                        }
                        parseLiteral(t, e, n, r) {
                            const s = super.parseLiteral(t, e, n, r);
                            return (s.raw = s.extra.raw), delete s.extra, s;
                        }
                        parseFunctionBody(t, e, n = !1) {
                            super.parseFunctionBody(t, e, n),
                                (t.expression =
                                    "BlockStatement" !== t.body.type);
                        }
                        parseMethod(t, e, n, r, s, i, o = !1) {
                            let a = this.startNode();
                            return (
                                (a.kind = t.kind),
                                (a = super.parseMethod(a, e, n, r, s, i, o)),
                                (a.type = "FunctionExpression"),
                                delete a.kind,
                                (t.value = a),
                                (i =
                                    "ClassMethod" === i
                                        ? "MethodDefinition"
                                        : i),
                                this.finishNode(t, i)
                            );
                        }
                        parseObjectMethod(t, e, n, r, s) {
                            const i = super.parseObjectMethod(t, e, n, r, s);
                            return (
                                i &&
                                    ((i.type = "Property"),
                                    "method" === i.kind && (i.kind = "init"),
                                    (i.shorthand = !1)),
                                i
                            );
                        }
                        parseObjectProperty(t, e, n, r, s) {
                            const i = super.parseObjectProperty(t, e, n, r, s);
                            return (
                                i && ((i.kind = "init"), (i.type = "Property")),
                                i
                            );
                        }
                        toAssignable(t) {
                            return T(t)
                                ? (this.toAssignable(t.value), t)
                                : super.toAssignable(t);
                        }
                        toAssignableObjectExpressionProp(t, e) {
                            if ("get" === t.kind || "set" === t.kind)
                                throw this.raise(
                                    t.key.start,
                                    E.PatternHasAccessor
                                );
                            if (t.method)
                                throw this.raise(
                                    t.key.start,
                                    E.PatternHasMethod
                                );
                            super.toAssignableObjectExpressionProp(t, e);
                        }
                        finishCallExpression(t, e) {
                            return (
                                super.finishCallExpression(t, e),
                                "Import" === t.callee.type &&
                                    ((t.type = "ImportExpression"),
                                    (t.source = t.arguments[0]),
                                    delete t.arguments,
                                    delete t.callee),
                                t
                            );
                        }
                        toReferencedListDeep(t, e) {
                            t && super.toReferencedListDeep(t, e);
                        }
                        parseExport(t) {
                            switch ((super.parseExport(t), t.type)) {
                                case "ExportAllDeclaration":
                                    t.exported = null;
                                    break;
                                case "ExportNamedDeclaration":
                                    1 === t.specifiers.length &&
                                        "ExportNamespaceSpecifier" ===
                                            t.specifiers[0].type &&
                                        ((t.type = "ExportAllDeclaration"),
                                        (t.exported = t.specifiers[0].exported),
                                        delete t.specifiers);
                            }
                            return t;
                        }
                        parseSubscript(t, e, n, r, s) {
                            const i = super.parseSubscript(t, e, n, r, s);
                            if (s.optionalChainMember) {
                                if (
                                    (("OptionalMemberExpression" !== i.type &&
                                        "OptionalCallExpression" !== i.type) ||
                                        (i.type = i.type.substring(8)),
                                    s.stop)
                                ) {
                                    const t = this.startNodeAtNode(i);
                                    return (
                                        (t.expression = i),
                                        this.finishNode(t, "ChainExpression")
                                    );
                                }
                            } else
                                ("MemberExpression" !== i.type &&
                                    "CallExpression" !== i.type) ||
                                    (i.optional = !1);
                            return i;
                        }
                    },
                jsx: (t) =>
                    class extends t {
                        jsxReadToken() {
                            let t = "",
                                e = this.state.pos;
                            for (;;) {
                                if (this.state.pos >= this.length)
                                    throw this.raise(
                                        this.state.start,
                                        nt.UnterminatedJsxContent
                                    );
                                const n = this.input.charCodeAt(this.state.pos);
                                switch (n) {
                                    case 60:
                                    case 123:
                                        return this.state.pos ===
                                            this.state.start
                                            ? 60 === n && this.state.exprAllowed
                                                ? (++this.state.pos,
                                                  this.finishToken(
                                                      h.jsxTagStart
                                                  ))
                                                : super.getTokenFromCode(n)
                                            : ((t += this.input.slice(
                                                  e,
                                                  this.state.pos
                                              )),
                                              this.finishToken(h.jsxText, t));
                                    case 38:
                                        (t += this.input.slice(
                                            e,
                                            this.state.pos
                                        )),
                                            (t += this.jsxReadEntity()),
                                            (e = this.state.pos);
                                        break;
                                    default:
                                        v(n)
                                            ? ((t += this.input.slice(
                                                  e,
                                                  this.state.pos
                                              )),
                                              (t += this.jsxReadNewLine(!0)),
                                              (e = this.state.pos))
                                            : ++this.state.pos;
                                }
                            }
                        }
                        jsxReadNewLine(t) {
                            const e = this.input.charCodeAt(this.state.pos);
                            let n;
                            return (
                                ++this.state.pos,
                                13 === e &&
                                10 === this.input.charCodeAt(this.state.pos)
                                    ? (++this.state.pos,
                                      (n = t ? "\n" : "\r\n"))
                                    : (n = String.fromCharCode(e)),
                                ++this.state.curLine,
                                (this.state.lineStart = this.state.pos),
                                n
                            );
                        }
                        jsxReadString(t) {
                            let e = "",
                                n = ++this.state.pos;
                            for (;;) {
                                if (this.state.pos >= this.length)
                                    throw this.raise(
                                        this.state.start,
                                        E.UnterminatedString
                                    );
                                const r = this.input.charCodeAt(this.state.pos);
                                if (r === t) break;
                                38 === r
                                    ? ((e += this.input.slice(
                                          n,
                                          this.state.pos
                                      )),
                                      (e += this.jsxReadEntity()),
                                      (n = this.state.pos))
                                    : v(r)
                                    ? ((e += this.input.slice(
                                          n,
                                          this.state.pos
                                      )),
                                      (e += this.jsxReadNewLine(!1)),
                                      (n = this.state.pos))
                                    : ++this.state.pos;
                            }
                            return (
                                (e += this.input.slice(n, this.state.pos++)),
                                this.finishToken(h.string, e)
                            );
                        }
                        jsxReadEntity() {
                            let t,
                                e = "",
                                n = 0,
                                r = this.input[this.state.pos];
                            const s = ++this.state.pos;
                            for (; this.state.pos < this.length && n++ < 10; ) {
                                if (
                                    ((r = this.input[this.state.pos++]),
                                    ";" === r)
                                ) {
                                    "#" === e[0]
                                        ? "x" === e[1]
                                            ? ((e = e.substr(2)),
                                              tt.test(e) &&
                                                  (t = String.fromCodePoint(
                                                      parseInt(e, 16)
                                                  )))
                                            : ((e = e.substr(1)),
                                              et.test(e) &&
                                                  (t = String.fromCodePoint(
                                                      parseInt(e, 10)
                                                  )))
                                        : (t = Z[e]);
                                    break;
                                }
                                e += r;
                            }
                            return t || ((this.state.pos = s), "&");
                        }
                        jsxReadWord() {
                            let t;
                            const e = this.state.pos;
                            do {
                                t = this.input.charCodeAt(++this.state.pos);
                            } while (R(t) || 45 === t);
                            return this.finishToken(
                                h.jsxName,
                                this.input.slice(e, this.state.pos)
                            );
                        }
                        jsxParseIdentifier() {
                            const t = this.startNode();
                            return (
                                this.match(h.jsxName)
                                    ? (t.name = this.state.value)
                                    : this.state.type.keyword
                                    ? (t.name = this.state.type.keyword)
                                    : this.unexpected(),
                                this.next(),
                                this.finishNode(t, "JSXIdentifier")
                            );
                        }
                        jsxParseNamespacedName() {
                            const t = this.state.start,
                                e = this.state.startLoc,
                                n = this.jsxParseIdentifier();
                            if (!this.eat(h.colon)) return n;
                            const r = this.startNodeAt(t, e);
                            return (
                                (r.namespace = n),
                                (r.name = this.jsxParseIdentifier()),
                                this.finishNode(r, "JSXNamespacedName")
                            );
                        }
                        jsxParseElementName() {
                            const t = this.state.start,
                                e = this.state.startLoc;
                            let n = this.jsxParseNamespacedName();
                            if ("JSXNamespacedName" === n.type) return n;
                            for (; this.eat(h.dot); ) {
                                const r = this.startNodeAt(t, e);
                                (r.object = n),
                                    (r.property = this.jsxParseIdentifier()),
                                    (n = this.finishNode(
                                        r,
                                        "JSXMemberExpression"
                                    ));
                            }
                            return n;
                        }
                        jsxParseAttributeValue() {
                            let t;
                            switch (this.state.type) {
                                case h.braceL:
                                    return (
                                        (t = this.startNode()),
                                        this.next(),
                                        (t =
                                            this.jsxParseExpressionContainer(
                                                t
                                            )),
                                        "JSXEmptyExpression" ===
                                            t.expression.type &&
                                            this.raise(
                                                t.start,
                                                nt.AttributeIsEmpty
                                            ),
                                        t
                                    );
                                case h.jsxTagStart:
                                case h.string:
                                    return this.parseExprAtom();
                                default:
                                    throw this.raise(
                                        this.state.start,
                                        nt.UnsupportedJsxValue
                                    );
                            }
                        }
                        jsxParseEmptyExpression() {
                            const t = this.startNodeAt(
                                this.state.lastTokEnd,
                                this.state.lastTokEndLoc
                            );
                            return this.finishNodeAt(
                                t,
                                "JSXEmptyExpression",
                                this.state.start,
                                this.state.startLoc
                            );
                        }
                        jsxParseSpreadChild(t) {
                            return (
                                this.next(),
                                (t.expression = this.parseExpression()),
                                this.expect(h.braceR),
                                this.finishNode(t, "JSXSpreadChild")
                            );
                        }
                        jsxParseExpressionContainer(t) {
                            return (
                                this.match(h.braceR)
                                    ? (t.expression =
                                          this.jsxParseEmptyExpression())
                                    : (t.expression = this.parseExpression()),
                                this.expect(h.braceR),
                                this.finishNode(t, "JSXExpressionContainer")
                            );
                        }
                        jsxParseAttribute() {
                            const t = this.startNode();
                            return this.eat(h.braceL)
                                ? (this.expect(h.ellipsis),
                                  (t.argument = this.parseMaybeAssignAllowIn()),
                                  this.expect(h.braceR),
                                  this.finishNode(t, "JSXSpreadAttribute"))
                                : ((t.name = this.jsxParseNamespacedName()),
                                  (t.value = this.eat(h.eq)
                                      ? this.jsxParseAttributeValue()
                                      : null),
                                  this.finishNode(t, "JSXAttribute"));
                        }
                        jsxParseOpeningElementAt(t, e) {
                            const n = this.startNodeAt(t, e);
                            return this.match(h.jsxTagEnd)
                                ? (this.expect(h.jsxTagEnd),
                                  this.finishNode(n, "JSXOpeningFragment"))
                                : ((n.name = this.jsxParseElementName()),
                                  this.jsxParseOpeningElementAfterName(n));
                        }
                        jsxParseOpeningElementAfterName(t) {
                            const e = [];
                            for (
                                ;
                                !this.match(h.slash) &&
                                !this.match(h.jsxTagEnd);

                            )
                                e.push(this.jsxParseAttribute());
                            return (
                                (t.attributes = e),
                                (t.selfClosing = this.eat(h.slash)),
                                this.expect(h.jsxTagEnd),
                                this.finishNode(t, "JSXOpeningElement")
                            );
                        }
                        jsxParseClosingElementAt(t, e) {
                            const n = this.startNodeAt(t, e);
                            return this.match(h.jsxTagEnd)
                                ? (this.expect(h.jsxTagEnd),
                                  this.finishNode(n, "JSXClosingFragment"))
                                : ((n.name = this.jsxParseElementName()),
                                  this.expect(h.jsxTagEnd),
                                  this.finishNode(n, "JSXClosingElement"));
                        }
                        jsxParseElementAt(t, e) {
                            const n = this.startNodeAt(t, e),
                                r = [],
                                s = this.jsxParseOpeningElementAt(t, e);
                            let i = null;
                            if (!s.selfClosing) {
                                t: for (;;)
                                    switch (this.state.type) {
                                        case h.jsxTagStart:
                                            if (
                                                ((t = this.state.start),
                                                (e = this.state.startLoc),
                                                this.next(),
                                                this.eat(h.slash))
                                            ) {
                                                i =
                                                    this.jsxParseClosingElementAt(
                                                        t,
                                                        e
                                                    );
                                                break t;
                                            }
                                            r.push(
                                                this.jsxParseElementAt(t, e)
                                            );
                                            break;
                                        case h.jsxText:
                                            r.push(this.parseExprAtom());
                                            break;
                                        case h.braceL: {
                                            const t = this.startNode();
                                            this.next(),
                                                this.match(h.ellipsis)
                                                    ? r.push(
                                                          this.jsxParseSpreadChild(
                                                              t
                                                          )
                                                      )
                                                    : r.push(
                                                          this.jsxParseExpressionContainer(
                                                              t
                                                          )
                                                      );
                                            break;
                                        }
                                        default:
                                            throw this.unexpected();
                                    }
                                rt(s) && !rt(i)
                                    ? this.raise(
                                          i.start,
                                          nt.MissingClosingTagFragment
                                      )
                                    : !rt(s) && rt(i)
                                    ? this.raise(
                                          i.start,
                                          nt.MissingClosingTagElement,
                                          st(s.name)
                                      )
                                    : rt(s) ||
                                      rt(i) ||
                                      (st(i.name) !== st(s.name) &&
                                          this.raise(
                                              i.start,
                                              nt.MissingClosingTagElement,
                                              st(s.name)
                                          ));
                            }
                            if (
                                (rt(s)
                                    ? ((n.openingFragment = s),
                                      (n.closingFragment = i))
                                    : ((n.openingElement = s),
                                      (n.closingElement = i)),
                                (n.children = r),
                                this.isRelational("<"))
                            )
                                throw this.raise(
                                    this.state.start,
                                    nt.UnwrappedAdjacentJSXElements
                                );
                            return rt(s)
                                ? this.finishNode(n, "JSXFragment")
                                : this.finishNode(n, "JSXElement");
                        }
                        jsxParseElement() {
                            const t = this.state.start,
                                e = this.state.startLoc;
                            return this.next(), this.jsxParseElementAt(t, e);
                        }
                        parseExprAtom(t) {
                            return this.match(h.jsxText)
                                ? this.parseLiteral(this.state.value, "JSXText")
                                : this.match(h.jsxTagStart)
                                ? this.jsxParseElement()
                                : this.isRelational("<") &&
                                  33 !== this.input.charCodeAt(this.state.pos)
                                ? (this.finishToken(h.jsxTagStart),
                                  this.jsxParseElement())
                                : super.parseExprAtom(t);
                        }
                        getTokenFromCode(t) {
                            if (this.state.inPropertyName)
                                return super.getTokenFromCode(t);
                            const e = this.curContext();
                            if (e === C.j_expr) return this.jsxReadToken();
                            if (e === C.j_oTag || e === C.j_cTag) {
                                if (M(t)) return this.jsxReadWord();
                                if (62 === t)
                                    return (
                                        ++this.state.pos,
                                        this.finishToken(h.jsxTagEnd)
                                    );
                                if ((34 === t || 39 === t) && e === C.j_oTag)
                                    return this.jsxReadString(t);
                            }
                            return 60 === t &&
                                this.state.exprAllowed &&
                                33 !== this.input.charCodeAt(this.state.pos + 1)
                                ? (++this.state.pos,
                                  this.finishToken(h.jsxTagStart))
                                : super.getTokenFromCode(t);
                        }
                        updateContext(t) {
                            if (this.match(h.braceL)) {
                                const e = this.curContext();
                                e === C.j_oTag
                                    ? this.state.context.push(C.braceExpression)
                                    : e === C.j_expr
                                    ? this.state.context.push(C.templateQuasi)
                                    : super.updateContext(t),
                                    (this.state.exprAllowed = !0);
                            } else {
                                if (!this.match(h.slash) || t !== h.jsxTagStart)
                                    return super.updateContext(t);
                                (this.state.context.length -= 2),
                                    this.state.context.push(C.j_cTag),
                                    (this.state.exprAllowed = !1);
                            }
                        }
                    },
                flow: (t) =>
                    class extends t {
                        constructor(t, e) {
                            super(t, e), (this.flowPragma = void 0);
                        }
                        shouldParseTypes() {
                            return (
                                this.getPluginOption("flow", "all") ||
                                "flow" === this.flowPragma
                            );
                        }
                        shouldParseEnums() {
                            return !!this.getPluginOption("flow", "enums");
                        }
                        finishToken(t, e) {
                            return (
                                t !== h.string &&
                                    t !== h.semi &&
                                    t !== h.interpreterDirective &&
                                    void 0 === this.flowPragma &&
                                    (this.flowPragma = null),
                                super.finishToken(t, e)
                            );
                        }
                        addComment(t) {
                            if (void 0 === this.flowPragma) {
                                const e = Q.exec(t.value);
                                if (e)
                                    if ("flow" === e[1])
                                        this.flowPragma = "flow";
                                    else {
                                        if ("noflow" !== e[1])
                                            throw new Error(
                                                "Unexpected flow pragma"
                                            );
                                        this.flowPragma = "noflow";
                                    }
                                else;
                            }
                            return super.addComment(t);
                        }
                        flowParseTypeInitialiser(t) {
                            const e = this.state.inType;
                            (this.state.inType = !0), this.expect(t || h.colon);
                            const n = this.flowParseType();
                            return (this.state.inType = e), n;
                        }
                        flowParsePredicate() {
                            const t = this.startNode(),
                                e = this.state.startLoc,
                                n = this.state.start;
                            this.expect(h.modulo);
                            const r = this.state.startLoc;
                            return (
                                this.expectContextual("checks"),
                                (e.line === r.line &&
                                    e.column === r.column - 1) ||
                                    this.raise(
                                        n,
                                        K.UnexpectedSpaceBetweenModuloChecks
                                    ),
                                this.eat(h.parenL)
                                    ? ((t.value = this.parseExpression()),
                                      this.expect(h.parenR),
                                      this.finishNode(t, "DeclaredPredicate"))
                                    : this.finishNode(t, "InferredPredicate")
                            );
                        }
                        flowParseTypeAndPredicateInitialiser() {
                            const t = this.state.inType;
                            (this.state.inType = !0), this.expect(h.colon);
                            let e = null,
                                n = null;
                            return (
                                this.match(h.modulo)
                                    ? ((this.state.inType = t),
                                      (n = this.flowParsePredicate()))
                                    : ((e = this.flowParseType()),
                                      (this.state.inType = t),
                                      this.match(h.modulo) &&
                                          (n = this.flowParsePredicate())),
                                [e, n]
                            );
                        }
                        flowParseDeclareClass(t) {
                            return (
                                this.next(),
                                this.flowParseInterfaceish(t, !0),
                                this.finishNode(t, "DeclareClass")
                            );
                        }
                        flowParseDeclareFunction(t) {
                            this.next();
                            const e = (t.id = this.parseIdentifier()),
                                n = this.startNode(),
                                r = this.startNode();
                            this.isRelational("<")
                                ? (n.typeParameters =
                                      this.flowParseTypeParameterDeclaration())
                                : (n.typeParameters = null),
                                this.expect(h.parenL);
                            const s = this.flowParseFunctionTypeParams();
                            return (
                                (n.params = s.params),
                                (n.rest = s.rest),
                                this.expect(h.parenR),
                                ([n.returnType, t.predicate] =
                                    this.flowParseTypeAndPredicateInitialiser()),
                                (r.typeAnnotation = this.finishNode(
                                    n,
                                    "FunctionTypeAnnotation"
                                )),
                                (e.typeAnnotation = this.finishNode(
                                    r,
                                    "TypeAnnotation"
                                )),
                                this.resetEndLocation(e),
                                this.semicolon(),
                                this.finishNode(t, "DeclareFunction")
                            );
                        }
                        flowParseDeclare(t, e) {
                            if (this.match(h._class))
                                return this.flowParseDeclareClass(t);
                            if (this.match(h._function))
                                return this.flowParseDeclareFunction(t);
                            if (this.match(h._var))
                                return this.flowParseDeclareVariable(t);
                            if (this.eatContextual("module"))
                                return this.match(h.dot)
                                    ? this.flowParseDeclareModuleExports(t)
                                    : (e &&
                                          this.raise(
                                              this.state.lastTokStart,
                                              K.NestedDeclareModule
                                          ),
                                      this.flowParseDeclareModule(t));
                            if (this.isContextual("type"))
                                return this.flowParseDeclareTypeAlias(t);
                            if (this.isContextual("opaque"))
                                return this.flowParseDeclareOpaqueType(t);
                            if (this.isContextual("interface"))
                                return this.flowParseDeclareInterface(t);
                            if (this.match(h._export))
                                return this.flowParseDeclareExportDeclaration(
                                    t,
                                    e
                                );
                            throw this.unexpected();
                        }
                        flowParseDeclareVariable(t) {
                            return (
                                this.next(),
                                (t.id = this.flowParseTypeAnnotatableIdentifier(
                                    !0
                                )),
                                this.scope.declareName(
                                    t.id.name,
                                    5,
                                    t.id.start
                                ),
                                this.semicolon(),
                                this.finishNode(t, "DeclareVariable")
                            );
                        }
                        flowParseDeclareModule(t) {
                            this.scope.enter(0),
                                this.match(h.string)
                                    ? (t.id = this.parseExprAtom())
                                    : (t.id = this.parseIdentifier());
                            const e = (t.body = this.startNode()),
                                n = (e.body = []);
                            for (
                                this.expect(h.braceL);
                                !this.match(h.braceR);

                            ) {
                                let t = this.startNode();
                                this.match(h._import)
                                    ? (this.next(),
                                      this.isContextual("type") ||
                                          this.match(h._typeof) ||
                                          this.raise(
                                              this.state.lastTokStart,
                                              K.InvalidNonTypeImportInDeclareModule
                                          ),
                                      this.parseImport(t))
                                    : (this.expectContextual(
                                          "declare",
                                          K.UnsupportedStatementInDeclareModule
                                      ),
                                      (t = this.flowParseDeclare(t, !0))),
                                    n.push(t);
                            }
                            this.scope.exit(),
                                this.expect(h.braceR),
                                this.finishNode(e, "BlockStatement");
                            let r = null,
                                s = !1;
                            return (
                                n.forEach((t) => {
                                    !(function (t) {
                                        return (
                                            "DeclareExportAllDeclaration" ===
                                                t.type ||
                                            ("DeclareExportDeclaration" ===
                                                t.type &&
                                                (!t.declaration ||
                                                    ("TypeAlias" !==
                                                        t.declaration.type &&
                                                        "InterfaceDeclaration" !==
                                                            t.declaration
                                                                .type)))
                                        );
                                    })(t)
                                        ? "DeclareModuleExports" === t.type &&
                                          (s &&
                                              this.raise(
                                                  t.start,
                                                  K.DuplicateDeclareModuleExports
                                              ),
                                          "ES" === r &&
                                              this.raise(
                                                  t.start,
                                                  K.AmbiguousDeclareModuleKind
                                              ),
                                          (r = "CommonJS"),
                                          (s = !0))
                                        : ("CommonJS" === r &&
                                              this.raise(
                                                  t.start,
                                                  K.AmbiguousDeclareModuleKind
                                              ),
                                          (r = "ES"));
                                }),
                                (t.kind = r || "CommonJS"),
                                this.finishNode(t, "DeclareModule")
                            );
                        }
                        flowParseDeclareExportDeclaration(t, e) {
                            if ((this.expect(h._export), this.eat(h._default)))
                                return (
                                    this.match(h._function) ||
                                    this.match(h._class)
                                        ? (t.declaration =
                                              this.flowParseDeclare(
                                                  this.startNode()
                                              ))
                                        : ((t.declaration =
                                              this.flowParseType()),
                                          this.semicolon()),
                                    (t.default = !0),
                                    this.finishNode(
                                        t,
                                        "DeclareExportDeclaration"
                                    )
                                );
                            if (
                                this.match(h._const) ||
                                this.isLet() ||
                                ((this.isContextual("type") ||
                                    this.isContextual("interface")) &&
                                    !e)
                            ) {
                                const t = this.state.value,
                                    e = Y[t];
                                throw this.raise(
                                    this.state.start,
                                    K.UnsupportedDeclareExportKind,
                                    t,
                                    e
                                );
                            }
                            if (
                                this.match(h._var) ||
                                this.match(h._function) ||
                                this.match(h._class) ||
                                this.isContextual("opaque")
                            )
                                return (
                                    (t.declaration = this.flowParseDeclare(
                                        this.startNode()
                                    )),
                                    (t.default = !1),
                                    this.finishNode(
                                        t,
                                        "DeclareExportDeclaration"
                                    )
                                );
                            if (
                                this.match(h.star) ||
                                this.match(h.braceL) ||
                                this.isContextual("interface") ||
                                this.isContextual("type") ||
                                this.isContextual("opaque")
                            )
                                return (
                                    "ExportNamedDeclaration" ===
                                        (t = this.parseExport(t)).type &&
                                        ((t.type = "ExportDeclaration"),
                                        (t.default = !1),
                                        delete t.exportKind),
                                    (t.type = "Declare" + t.type),
                                    t
                                );
                            throw this.unexpected();
                        }
                        flowParseDeclareModuleExports(t) {
                            return (
                                this.next(),
                                this.expectContextual("exports"),
                                (t.typeAnnotation =
                                    this.flowParseTypeAnnotation()),
                                this.semicolon(),
                                this.finishNode(t, "DeclareModuleExports")
                            );
                        }
                        flowParseDeclareTypeAlias(t) {
                            return (
                                this.next(),
                                this.flowParseTypeAlias(t),
                                (t.type = "DeclareTypeAlias"),
                                t
                            );
                        }
                        flowParseDeclareOpaqueType(t) {
                            return (
                                this.next(),
                                this.flowParseOpaqueType(t, !0),
                                (t.type = "DeclareOpaqueType"),
                                t
                            );
                        }
                        flowParseDeclareInterface(t) {
                            return (
                                this.next(),
                                this.flowParseInterfaceish(t),
                                this.finishNode(t, "DeclareInterface")
                            );
                        }
                        flowParseInterfaceish(t, e = !1) {
                            if (
                                ((t.id = this.flowParseRestrictedIdentifier(
                                    !e,
                                    !0
                                )),
                                this.scope.declareName(
                                    t.id.name,
                                    e ? 17 : 9,
                                    t.id.start
                                ),
                                this.isRelational("<")
                                    ? (t.typeParameters =
                                          this.flowParseTypeParameterDeclaration())
                                    : (t.typeParameters = null),
                                (t.extends = []),
                                (t.implements = []),
                                (t.mixins = []),
                                this.eat(h._extends))
                            )
                                do {
                                    t.extends.push(
                                        this.flowParseInterfaceExtends()
                                    );
                                } while (!e && this.eat(h.comma));
                            if (this.isContextual("mixins")) {
                                this.next();
                                do {
                                    t.mixins.push(
                                        this.flowParseInterfaceExtends()
                                    );
                                } while (this.eat(h.comma));
                            }
                            if (this.isContextual("implements")) {
                                this.next();
                                do {
                                    t.implements.push(
                                        this.flowParseInterfaceExtends()
                                    );
                                } while (this.eat(h.comma));
                            }
                            t.body = this.flowParseObjectType({
                                allowStatic: e,
                                allowExact: !1,
                                allowSpread: !1,
                                allowProto: e,
                                allowInexact: !1,
                            });
                        }
                        flowParseInterfaceExtends() {
                            const t = this.startNode();
                            return (
                                (t.id =
                                    this.flowParseQualifiedTypeIdentifier()),
                                this.isRelational("<")
                                    ? (t.typeParameters =
                                          this.flowParseTypeParameterInstantiation())
                                    : (t.typeParameters = null),
                                this.finishNode(t, "InterfaceExtends")
                            );
                        }
                        flowParseInterface(t) {
                            return (
                                this.flowParseInterfaceish(t),
                                this.finishNode(t, "InterfaceDeclaration")
                            );
                        }
                        checkNotUnderscore(t) {
                            "_" === t &&
                                this.raise(
                                    this.state.start,
                                    K.UnexpectedReservedUnderscore
                                );
                        }
                        checkReservedType(t, e, n) {
                            G.has(t) &&
                                this.raise(
                                    e,
                                    n
                                        ? K.AssignReservedType
                                        : K.UnexpectedReservedType,
                                    t
                                );
                        }
                        flowParseRestrictedIdentifier(t, e) {
                            return (
                                this.checkReservedType(
                                    this.state.value,
                                    this.state.start,
                                    e
                                ),
                                this.parseIdentifier(t)
                            );
                        }
                        flowParseTypeAlias(t) {
                            return (
                                (t.id = this.flowParseRestrictedIdentifier(
                                    !1,
                                    !0
                                )),
                                this.scope.declareName(
                                    t.id.name,
                                    9,
                                    t.id.start
                                ),
                                this.isRelational("<")
                                    ? (t.typeParameters =
                                          this.flowParseTypeParameterDeclaration())
                                    : (t.typeParameters = null),
                                (t.right = this.flowParseTypeInitialiser(h.eq)),
                                this.semicolon(),
                                this.finishNode(t, "TypeAlias")
                            );
                        }
                        flowParseOpaqueType(t, e) {
                            return (
                                this.expectContextual("type"),
                                (t.id = this.flowParseRestrictedIdentifier(
                                    !0,
                                    !0
                                )),
                                this.scope.declareName(
                                    t.id.name,
                                    9,
                                    t.id.start
                                ),
                                this.isRelational("<")
                                    ? (t.typeParameters =
                                          this.flowParseTypeParameterDeclaration())
                                    : (t.typeParameters = null),
                                (t.supertype = null),
                                this.match(h.colon) &&
                                    (t.supertype =
                                        this.flowParseTypeInitialiser(h.colon)),
                                (t.impltype = null),
                                e ||
                                    (t.impltype = this.flowParseTypeInitialiser(
                                        h.eq
                                    )),
                                this.semicolon(),
                                this.finishNode(t, "OpaqueType")
                            );
                        }
                        flowParseTypeParameter(t = !1) {
                            const e = this.state.start,
                                n = this.startNode(),
                                r = this.flowParseVariance(),
                                s = this.flowParseTypeAnnotatableIdentifier();
                            return (
                                (n.name = s.name),
                                (n.variance = r),
                                (n.bound = s.typeAnnotation),
                                this.match(h.eq)
                                    ? (this.eat(h.eq),
                                      (n.default = this.flowParseType()))
                                    : t &&
                                      this.raise(e, K.MissingTypeParamDefault),
                                this.finishNode(n, "TypeParameter")
                            );
                        }
                        flowParseTypeParameterDeclaration() {
                            const t = this.state.inType,
                                e = this.startNode();
                            (e.params = []),
                                (this.state.inType = !0),
                                this.isRelational("<") ||
                                this.match(h.jsxTagStart)
                                    ? this.next()
                                    : this.unexpected();
                            let n = !1;
                            do {
                                const t = this.flowParseTypeParameter(n);
                                e.params.push(t),
                                    t.default && (n = !0),
                                    this.isRelational(">") ||
                                        this.expect(h.comma);
                            } while (!this.isRelational(">"));
                            return (
                                this.expectRelational(">"),
                                (this.state.inType = t),
                                this.finishNode(e, "TypeParameterDeclaration")
                            );
                        }
                        flowParseTypeParameterInstantiation() {
                            const t = this.startNode(),
                                e = this.state.inType;
                            (t.params = []),
                                (this.state.inType = !0),
                                this.expectRelational("<");
                            const n = this.state.noAnonFunctionType;
                            for (
                                this.state.noAnonFunctionType = !1;
                                !this.isRelational(">");

                            )
                                t.params.push(this.flowParseType()),
                                    this.isRelational(">") ||
                                        this.expect(h.comma);
                            return (
                                (this.state.noAnonFunctionType = n),
                                this.expectRelational(">"),
                                (this.state.inType = e),
                                this.finishNode(t, "TypeParameterInstantiation")
                            );
                        }
                        flowParseTypeParameterInstantiationCallOrNew() {
                            const t = this.startNode(),
                                e = this.state.inType;
                            for (
                                t.params = [],
                                    this.state.inType = !0,
                                    this.expectRelational("<");
                                !this.isRelational(">");

                            )
                                t.params.push(
                                    this.flowParseTypeOrImplicitInstantiation()
                                ),
                                    this.isRelational(">") ||
                                        this.expect(h.comma);
                            return (
                                this.expectRelational(">"),
                                (this.state.inType = e),
                                this.finishNode(t, "TypeParameterInstantiation")
                            );
                        }
                        flowParseInterfaceType() {
                            const t = this.startNode();
                            if (
                                (this.expectContextual("interface"),
                                (t.extends = []),
                                this.eat(h._extends))
                            )
                                do {
                                    t.extends.push(
                                        this.flowParseInterfaceExtends()
                                    );
                                } while (this.eat(h.comma));
                            return (
                                (t.body = this.flowParseObjectType({
                                    allowStatic: !1,
                                    allowExact: !1,
                                    allowSpread: !1,
                                    allowProto: !1,
                                    allowInexact: !1,
                                })),
                                this.finishNode(t, "InterfaceTypeAnnotation")
                            );
                        }
                        flowParseObjectPropertyKey() {
                            return this.match(h.num) || this.match(h.string)
                                ? this.parseExprAtom()
                                : this.parseIdentifier(!0);
                        }
                        flowParseObjectTypeIndexer(t, e, n) {
                            return (
                                (t.static = e),
                                this.lookahead().type === h.colon
                                    ? ((t.id =
                                          this.flowParseObjectPropertyKey()),
                                      (t.key = this.flowParseTypeInitialiser()))
                                    : ((t.id = null),
                                      (t.key = this.flowParseType())),
                                this.expect(h.bracketR),
                                (t.value = this.flowParseTypeInitialiser()),
                                (t.variance = n),
                                this.finishNode(t, "ObjectTypeIndexer")
                            );
                        }
                        flowParseObjectTypeInternalSlot(t, e) {
                            return (
                                (t.static = e),
                                (t.id = this.flowParseObjectPropertyKey()),
                                this.expect(h.bracketR),
                                this.expect(h.bracketR),
                                this.isRelational("<") || this.match(h.parenL)
                                    ? ((t.method = !0),
                                      (t.optional = !1),
                                      (t.value =
                                          this.flowParseObjectTypeMethodish(
                                              this.startNodeAt(
                                                  t.start,
                                                  t.loc.start
                                              )
                                          )))
                                    : ((t.method = !1),
                                      this.eat(h.question) && (t.optional = !0),
                                      (t.value =
                                          this.flowParseTypeInitialiser())),
                                this.finishNode(t, "ObjectTypeInternalSlot")
                            );
                        }
                        flowParseObjectTypeMethodish(t) {
                            for (
                                t.params = [],
                                    t.rest = null,
                                    t.typeParameters = null,
                                    this.isRelational("<") &&
                                        (t.typeParameters =
                                            this.flowParseTypeParameterDeclaration()),
                                    this.expect(h.parenL);
                                !this.match(h.parenR) &&
                                !this.match(h.ellipsis);

                            )
                                t.params.push(
                                    this.flowParseFunctionTypeParam()
                                ),
                                    this.match(h.parenR) ||
                                        this.expect(h.comma);
                            return (
                                this.eat(h.ellipsis) &&
                                    (t.rest =
                                        this.flowParseFunctionTypeParam()),
                                this.expect(h.parenR),
                                (t.returnType =
                                    this.flowParseTypeInitialiser()),
                                this.finishNode(t, "FunctionTypeAnnotation")
                            );
                        }
                        flowParseObjectTypeCallProperty(t, e) {
                            const n = this.startNode();
                            return (
                                (t.static = e),
                                (t.value =
                                    this.flowParseObjectTypeMethodish(n)),
                                this.finishNode(t, "ObjectTypeCallProperty")
                            );
                        }
                        flowParseObjectType({
                            allowStatic: t,
                            allowExact: e,
                            allowSpread: n,
                            allowProto: r,
                            allowInexact: s,
                        }) {
                            const i = this.state.inType;
                            this.state.inType = !0;
                            const o = this.startNode();
                            let a, c;
                            (o.callProperties = []),
                                (o.properties = []),
                                (o.indexers = []),
                                (o.internalSlots = []);
                            let l = !1;
                            for (
                                e && this.match(h.braceBarL)
                                    ? (this.expect(h.braceBarL),
                                      (a = h.braceBarR),
                                      (c = !0))
                                    : (this.expect(h.braceL),
                                      (a = h.braceR),
                                      (c = !1)),
                                    o.exact = c;
                                !this.match(a);

                            ) {
                                let e = !1,
                                    i = null,
                                    a = null;
                                const u = this.startNode();
                                if (r && this.isContextual("proto")) {
                                    const e = this.lookahead();
                                    e.type !== h.colon &&
                                        e.type !== h.question &&
                                        (this.next(),
                                        (i = this.state.start),
                                        (t = !1));
                                }
                                if (t && this.isContextual("static")) {
                                    const t = this.lookahead();
                                    t.type !== h.colon &&
                                        t.type !== h.question &&
                                        (this.next(), (e = !0));
                                }
                                const p = this.flowParseVariance();
                                if (this.eat(h.bracketL))
                                    null != i && this.unexpected(i),
                                        this.eat(h.bracketL)
                                            ? (p && this.unexpected(p.start),
                                              o.internalSlots.push(
                                                  this.flowParseObjectTypeInternalSlot(
                                                      u,
                                                      e
                                                  )
                                              ))
                                            : o.indexers.push(
                                                  this.flowParseObjectTypeIndexer(
                                                      u,
                                                      e,
                                                      p
                                                  )
                                              );
                                else if (
                                    this.match(h.parenL) ||
                                    this.isRelational("<")
                                )
                                    null != i && this.unexpected(i),
                                        p && this.unexpected(p.start),
                                        o.callProperties.push(
                                            this.flowParseObjectTypeCallProperty(
                                                u,
                                                e
                                            )
                                        );
                                else {
                                    let t = "init";
                                    if (
                                        this.isContextual("get") ||
                                        this.isContextual("set")
                                    ) {
                                        const e = this.lookahead();
                                        (e.type !== h.name &&
                                            e.type !== h.string &&
                                            e.type !== h.num) ||
                                            ((t = this.state.value),
                                            this.next());
                                    }
                                    const r = this.flowParseObjectTypeProperty(
                                        u,
                                        e,
                                        i,
                                        p,
                                        t,
                                        n,
                                        null != s ? s : !c
                                    );
                                    null === r
                                        ? ((l = !0),
                                          (a = this.state.lastTokStart))
                                        : o.properties.push(r);
                                }
                                this.flowObjectTypeSemicolon(),
                                    !a ||
                                        this.match(h.braceR) ||
                                        this.match(h.braceBarR) ||
                                        this.raise(
                                            a,
                                            K.UnexpectedExplicitInexactInObject
                                        );
                            }
                            this.expect(a), n && (o.inexact = l);
                            const u = this.finishNode(
                                o,
                                "ObjectTypeAnnotation"
                            );
                            return (this.state.inType = i), u;
                        }
                        flowParseObjectTypeProperty(t, e, n, r, s, i, o) {
                            if (this.eat(h.ellipsis)) {
                                return this.match(h.comma) ||
                                    this.match(h.semi) ||
                                    this.match(h.braceR) ||
                                    this.match(h.braceBarR)
                                    ? (i
                                          ? o ||
                                            this.raise(
                                                this.state.lastTokStart,
                                                K.InexactInsideExact
                                            )
                                          : this.raise(
                                                this.state.lastTokStart,
                                                K.InexactInsideNonObject
                                            ),
                                      r &&
                                          this.raise(
                                              r.start,
                                              K.InexactVariance
                                          ),
                                      null)
                                    : (i ||
                                          this.raise(
                                              this.state.lastTokStart,
                                              K.UnexpectedSpreadType
                                          ),
                                      null != n && this.unexpected(n),
                                      r &&
                                          this.raise(r.start, K.SpreadVariance),
                                      (t.argument = this.flowParseType()),
                                      this.finishNode(
                                          t,
                                          "ObjectTypeSpreadProperty"
                                      ));
                            }
                            {
                                (t.key = this.flowParseObjectPropertyKey()),
                                    (t.static = e),
                                    (t.proto = null != n),
                                    (t.kind = s);
                                let i = !1;
                                return (
                                    this.isRelational("<") ||
                                    this.match(h.parenL)
                                        ? ((t.method = !0),
                                          null != n && this.unexpected(n),
                                          r && this.unexpected(r.start),
                                          (t.value =
                                              this.flowParseObjectTypeMethodish(
                                                  this.startNodeAt(
                                                      t.start,
                                                      t.loc.start
                                                  )
                                              )),
                                          ("get" !== s && "set" !== s) ||
                                              this.flowCheckGetterSetterParams(
                                                  t
                                              ))
                                        : ("init" !== s && this.unexpected(),
                                          (t.method = !1),
                                          this.eat(h.question) && (i = !0),
                                          (t.value =
                                              this.flowParseTypeInitialiser()),
                                          (t.variance = r)),
                                    (t.optional = i),
                                    this.finishNode(t, "ObjectTypeProperty")
                                );
                            }
                        }
                        flowCheckGetterSetterParams(t) {
                            const e = "get" === t.kind ? 0 : 1,
                                n = t.start;
                            t.value.params.length + (t.value.rest ? 1 : 0) !==
                                e &&
                                ("get" === t.kind
                                    ? this.raise(n, E.BadGetterArity)
                                    : this.raise(n, E.BadSetterArity)),
                                "set" === t.kind &&
                                    t.value.rest &&
                                    this.raise(n, E.BadSetterRestParameter);
                        }
                        flowObjectTypeSemicolon() {
                            this.eat(h.semi) ||
                                this.eat(h.comma) ||
                                this.match(h.braceR) ||
                                this.match(h.braceBarR) ||
                                this.unexpected();
                        }
                        flowParseQualifiedTypeIdentifier(t, e, n) {
                            (t = t || this.state.start),
                                (e = e || this.state.startLoc);
                            let r = n || this.flowParseRestrictedIdentifier(!0);
                            for (; this.eat(h.dot); ) {
                                const n = this.startNodeAt(t, e);
                                (n.qualification = r),
                                    (n.id = this.flowParseRestrictedIdentifier(
                                        !0
                                    )),
                                    (r = this.finishNode(
                                        n,
                                        "QualifiedTypeIdentifier"
                                    ));
                            }
                            return r;
                        }
                        flowParseGenericType(t, e, n) {
                            const r = this.startNodeAt(t, e);
                            return (
                                (r.typeParameters = null),
                                (r.id = this.flowParseQualifiedTypeIdentifier(
                                    t,
                                    e,
                                    n
                                )),
                                this.isRelational("<") &&
                                    (r.typeParameters =
                                        this.flowParseTypeParameterInstantiation()),
                                this.finishNode(r, "GenericTypeAnnotation")
                            );
                        }
                        flowParseTypeofType() {
                            const t = this.startNode();
                            return (
                                this.expect(h._typeof),
                                (t.argument = this.flowParsePrimaryType()),
                                this.finishNode(t, "TypeofTypeAnnotation")
                            );
                        }
                        flowParseTupleType() {
                            const t = this.startNode();
                            for (
                                t.types = [], this.expect(h.bracketL);
                                this.state.pos < this.length &&
                                !this.match(h.bracketR) &&
                                (t.types.push(this.flowParseType()),
                                !this.match(h.bracketR));

                            )
                                this.expect(h.comma);
                            return (
                                this.expect(h.bracketR),
                                this.finishNode(t, "TupleTypeAnnotation")
                            );
                        }
                        flowParseFunctionTypeParam() {
                            let t = null,
                                e = !1,
                                n = null;
                            const r = this.startNode(),
                                s = this.lookahead();
                            return (
                                s.type === h.colon || s.type === h.question
                                    ? ((t = this.parseIdentifier()),
                                      this.eat(h.question) && (e = !0),
                                      (n = this.flowParseTypeInitialiser()))
                                    : (n = this.flowParseType()),
                                (r.name = t),
                                (r.optional = e),
                                (r.typeAnnotation = n),
                                this.finishNode(r, "FunctionTypeParam")
                            );
                        }
                        reinterpretTypeAsFunctionTypeParam(t) {
                            const e = this.startNodeAt(t.start, t.loc.start);
                            return (
                                (e.name = null),
                                (e.optional = !1),
                                (e.typeAnnotation = t),
                                this.finishNode(e, "FunctionTypeParam")
                            );
                        }
                        flowParseFunctionTypeParams(t = []) {
                            let e = null;
                            for (
                                ;
                                !this.match(h.parenR) &&
                                !this.match(h.ellipsis);

                            )
                                t.push(this.flowParseFunctionTypeParam()),
                                    this.match(h.parenR) ||
                                        this.expect(h.comma);
                            return (
                                this.eat(h.ellipsis) &&
                                    (e = this.flowParseFunctionTypeParam()),
                                { params: t, rest: e }
                            );
                        }
                        flowIdentToTypeAnnotation(t, e, n, r) {
                            switch (r.name) {
                                case "any":
                                    return this.finishNode(
                                        n,
                                        "AnyTypeAnnotation"
                                    );
                                case "bool":
                                case "boolean":
                                    return this.finishNode(
                                        n,
                                        "BooleanTypeAnnotation"
                                    );
                                case "mixed":
                                    return this.finishNode(
                                        n,
                                        "MixedTypeAnnotation"
                                    );
                                case "empty":
                                    return this.finishNode(
                                        n,
                                        "EmptyTypeAnnotation"
                                    );
                                case "number":
                                    return this.finishNode(
                                        n,
                                        "NumberTypeAnnotation"
                                    );
                                case "string":
                                    return this.finishNode(
                                        n,
                                        "StringTypeAnnotation"
                                    );
                                case "symbol":
                                    return this.finishNode(
                                        n,
                                        "SymbolTypeAnnotation"
                                    );
                                default:
                                    return (
                                        this.checkNotUnderscore(r.name),
                                        this.flowParseGenericType(t, e, r)
                                    );
                            }
                        }
                        flowParsePrimaryType() {
                            const t = this.state.start,
                                e = this.state.startLoc,
                                n = this.startNode();
                            let r,
                                s,
                                i = !1;
                            const o = this.state.noAnonFunctionType;
                            switch (this.state.type) {
                                case h.name:
                                    return this.isContextual("interface")
                                        ? this.flowParseInterfaceType()
                                        : this.flowIdentToTypeAnnotation(
                                              t,
                                              e,
                                              n,
                                              this.parseIdentifier()
                                          );
                                case h.braceL:
                                    return this.flowParseObjectType({
                                        allowStatic: !1,
                                        allowExact: !1,
                                        allowSpread: !0,
                                        allowProto: !1,
                                        allowInexact: !0,
                                    });
                                case h.braceBarL:
                                    return this.flowParseObjectType({
                                        allowStatic: !1,
                                        allowExact: !0,
                                        allowSpread: !0,
                                        allowProto: !1,
                                        allowInexact: !1,
                                    });
                                case h.bracketL:
                                    return (
                                        (this.state.noAnonFunctionType = !1),
                                        (s = this.flowParseTupleType()),
                                        (this.state.noAnonFunctionType = o),
                                        s
                                    );
                                case h.relational:
                                    if ("<" === this.state.value)
                                        return (
                                            (n.typeParameters =
                                                this.flowParseTypeParameterDeclaration()),
                                            this.expect(h.parenL),
                                            (r =
                                                this.flowParseFunctionTypeParams()),
                                            (n.params = r.params),
                                            (n.rest = r.rest),
                                            this.expect(h.parenR),
                                            this.expect(h.arrow),
                                            (n.returnType =
                                                this.flowParseType()),
                                            this.finishNode(
                                                n,
                                                "FunctionTypeAnnotation"
                                            )
                                        );
                                    break;
                                case h.parenL:
                                    if (
                                        (this.next(),
                                        !this.match(h.parenR) &&
                                            !this.match(h.ellipsis))
                                    )
                                        if (this.match(h.name)) {
                                            const t = this.lookahead().type;
                                            i =
                                                t !== h.question &&
                                                t !== h.colon;
                                        } else i = !0;
                                    if (i) {
                                        if (
                                            ((this.state.noAnonFunctionType =
                                                !1),
                                            (s = this.flowParseType()),
                                            (this.state.noAnonFunctionType = o),
                                            this.state.noAnonFunctionType ||
                                                !(
                                                    this.match(h.comma) ||
                                                    (this.match(h.parenR) &&
                                                        this.lookahead()
                                                            .type === h.arrow)
                                                ))
                                        )
                                            return this.expect(h.parenR), s;
                                        this.eat(h.comma);
                                    }
                                    return (
                                        (r = s
                                            ? this.flowParseFunctionTypeParams([
                                                  this.reinterpretTypeAsFunctionTypeParam(
                                                      s
                                                  ),
                                              ])
                                            : this.flowParseFunctionTypeParams()),
                                        (n.params = r.params),
                                        (n.rest = r.rest),
                                        this.expect(h.parenR),
                                        this.expect(h.arrow),
                                        (n.returnType = this.flowParseType()),
                                        (n.typeParameters = null),
                                        this.finishNode(
                                            n,
                                            "FunctionTypeAnnotation"
                                        )
                                    );
                                case h.string:
                                    return this.parseLiteral(
                                        this.state.value,
                                        "StringLiteralTypeAnnotation"
                                    );
                                case h._true:
                                case h._false:
                                    return (
                                        (n.value = this.match(h._true)),
                                        this.next(),
                                        this.finishNode(
                                            n,
                                            "BooleanLiteralTypeAnnotation"
                                        )
                                    );
                                case h.plusMin:
                                    if ("-" === this.state.value) {
                                        if ((this.next(), this.match(h.num)))
                                            return this.parseLiteral(
                                                -this.state.value,
                                                "NumberLiteralTypeAnnotation",
                                                n.start,
                                                n.loc.start
                                            );
                                        if (this.match(h.bigint))
                                            return this.parseLiteral(
                                                -this.state.value,
                                                "BigIntLiteralTypeAnnotation",
                                                n.start,
                                                n.loc.start
                                            );
                                        throw this.raise(
                                            this.state.start,
                                            K.UnexpectedSubtractionOperand
                                        );
                                    }
                                    throw this.unexpected();
                                case h.num:
                                    return this.parseLiteral(
                                        this.state.value,
                                        "NumberLiteralTypeAnnotation"
                                    );
                                case h.bigint:
                                    return this.parseLiteral(
                                        this.state.value,
                                        "BigIntLiteralTypeAnnotation"
                                    );
                                case h._void:
                                    return (
                                        this.next(),
                                        this.finishNode(n, "VoidTypeAnnotation")
                                    );
                                case h._null:
                                    return (
                                        this.next(),
                                        this.finishNode(
                                            n,
                                            "NullLiteralTypeAnnotation"
                                        )
                                    );
                                case h._this:
                                    return (
                                        this.next(),
                                        this.finishNode(n, "ThisTypeAnnotation")
                                    );
                                case h.star:
                                    return (
                                        this.next(),
                                        this.finishNode(
                                            n,
                                            "ExistsTypeAnnotation"
                                        )
                                    );
                                default:
                                    if ("typeof" === this.state.type.keyword)
                                        return this.flowParseTypeofType();
                                    if (this.state.type.keyword) {
                                        const t = this.state.type.label;
                                        return (
                                            this.next(),
                                            super.createIdentifier(n, t)
                                        );
                                    }
                            }
                            throw this.unexpected();
                        }
                        flowParsePostfixType() {
                            const t = this.state.start,
                                e = this.state.startLoc;
                            let n = this.flowParsePrimaryType();
                            for (
                                ;
                                this.match(h.bracketL) &&
                                !this.canInsertSemicolon();

                            ) {
                                const r = this.startNodeAt(t, e);
                                (r.elementType = n),
                                    this.expect(h.bracketL),
                                    this.expect(h.bracketR),
                                    (n = this.finishNode(
                                        r,
                                        "ArrayTypeAnnotation"
                                    ));
                            }
                            return n;
                        }
                        flowParsePrefixType() {
                            const t = this.startNode();
                            return this.eat(h.question)
                                ? ((t.typeAnnotation =
                                      this.flowParsePrefixType()),
                                  this.finishNode(t, "NullableTypeAnnotation"))
                                : this.flowParsePostfixType();
                        }
                        flowParseAnonFunctionWithoutParens() {
                            const t = this.flowParsePrefixType();
                            if (
                                !this.state.noAnonFunctionType &&
                                this.eat(h.arrow)
                            ) {
                                const e = this.startNodeAt(
                                    t.start,
                                    t.loc.start
                                );
                                return (
                                    (e.params = [
                                        this.reinterpretTypeAsFunctionTypeParam(
                                            t
                                        ),
                                    ]),
                                    (e.rest = null),
                                    (e.returnType = this.flowParseType()),
                                    (e.typeParameters = null),
                                    this.finishNode(e, "FunctionTypeAnnotation")
                                );
                            }
                            return t;
                        }
                        flowParseIntersectionType() {
                            const t = this.startNode();
                            this.eat(h.bitwiseAND);
                            const e = this.flowParseAnonFunctionWithoutParens();
                            for (t.types = [e]; this.eat(h.bitwiseAND); )
                                t.types.push(
                                    this.flowParseAnonFunctionWithoutParens()
                                );
                            return 1 === t.types.length
                                ? e
                                : this.finishNode(
                                      t,
                                      "IntersectionTypeAnnotation"
                                  );
                        }
                        flowParseUnionType() {
                            const t = this.startNode();
                            this.eat(h.bitwiseOR);
                            const e = this.flowParseIntersectionType();
                            for (t.types = [e]; this.eat(h.bitwiseOR); )
                                t.types.push(this.flowParseIntersectionType());
                            return 1 === t.types.length
                                ? e
                                : this.finishNode(t, "UnionTypeAnnotation");
                        }
                        flowParseType() {
                            const t = this.state.inType;
                            this.state.inType = !0;
                            const e = this.flowParseUnionType();
                            return (
                                (this.state.inType = t),
                                (this.state.exprAllowed =
                                    this.state.exprAllowed ||
                                    this.state.noAnonFunctionType),
                                e
                            );
                        }
                        flowParseTypeOrImplicitInstantiation() {
                            if (
                                this.state.type === h.name &&
                                "_" === this.state.value
                            ) {
                                const t = this.state.start,
                                    e = this.state.startLoc,
                                    n = this.parseIdentifier();
                                return this.flowParseGenericType(t, e, n);
                            }
                            return this.flowParseType();
                        }
                        flowParseTypeAnnotation() {
                            const t = this.startNode();
                            return (
                                (t.typeAnnotation =
                                    this.flowParseTypeInitialiser()),
                                this.finishNode(t, "TypeAnnotation")
                            );
                        }
                        flowParseTypeAnnotatableIdentifier(t) {
                            const e = t
                                ? this.parseIdentifier()
                                : this.flowParseRestrictedIdentifier();
                            return (
                                this.match(h.colon) &&
                                    ((e.typeAnnotation =
                                        this.flowParseTypeAnnotation()),
                                    this.resetEndLocation(e)),
                                e
                            );
                        }
                        typeCastToParameter(t) {
                            return (
                                (t.expression.typeAnnotation =
                                    t.typeAnnotation),
                                this.resetEndLocation(
                                    t.expression,
                                    t.typeAnnotation.end,
                                    t.typeAnnotation.loc.end
                                ),
                                t.expression
                            );
                        }
                        flowParseVariance() {
                            let t = null;
                            return (
                                this.match(h.plusMin) &&
                                    ((t = this.startNode()),
                                    "+" === this.state.value
                                        ? (t.kind = "plus")
                                        : (t.kind = "minus"),
                                    this.next(),
                                    this.finishNode(t, "Variance")),
                                t
                            );
                        }
                        parseFunctionBody(t, e, n = !1) {
                            return e
                                ? this.forwardNoArrowParamsConversionAt(t, () =>
                                      super.parseFunctionBody(t, !0, n)
                                  )
                                : super.parseFunctionBody(t, !1, n);
                        }
                        parseFunctionBodyAndFinish(t, e, n = !1) {
                            if (this.match(h.colon)) {
                                const e = this.startNode();
                                ([e.typeAnnotation, t.predicate] =
                                    this.flowParseTypeAndPredicateInitialiser()),
                                    (t.returnType = e.typeAnnotation
                                        ? this.finishNode(e, "TypeAnnotation")
                                        : null);
                            }
                            super.parseFunctionBodyAndFinish(t, e, n);
                        }
                        parseStatement(t, e) {
                            if (
                                this.state.strict &&
                                this.match(h.name) &&
                                "interface" === this.state.value
                            ) {
                                const t = this.startNode();
                                return this.next(), this.flowParseInterface(t);
                            }
                            if (
                                this.shouldParseEnums() &&
                                this.isContextual("enum")
                            ) {
                                const t = this.startNode();
                                return (
                                    this.next(),
                                    this.flowParseEnumDeclaration(t)
                                );
                            }
                            {
                                const n = super.parseStatement(t, e);
                                return (
                                    void 0 !== this.flowPragma ||
                                        this.isValidDirective(n) ||
                                        (this.flowPragma = null),
                                    n
                                );
                            }
                        }
                        parseExpressionStatement(t, e) {
                            if ("Identifier" === e.type)
                                if ("declare" === e.name) {
                                    if (
                                        this.match(h._class) ||
                                        this.match(h.name) ||
                                        this.match(h._function) ||
                                        this.match(h._var) ||
                                        this.match(h._export)
                                    )
                                        return this.flowParseDeclare(t);
                                } else if (this.match(h.name)) {
                                    if ("interface" === e.name)
                                        return this.flowParseInterface(t);
                                    if ("type" === e.name)
                                        return this.flowParseTypeAlias(t);
                                    if ("opaque" === e.name)
                                        return this.flowParseOpaqueType(t, !1);
                                }
                            return super.parseExpressionStatement(t, e);
                        }
                        shouldParseExportDeclaration() {
                            return (
                                this.isContextual("type") ||
                                this.isContextual("interface") ||
                                this.isContextual("opaque") ||
                                (this.shouldParseEnums() &&
                                    this.isContextual("enum")) ||
                                super.shouldParseExportDeclaration()
                            );
                        }
                        isExportDefaultSpecifier() {
                            return (
                                (!this.match(h.name) ||
                                    !(
                                        "type" === this.state.value ||
                                        "interface" === this.state.value ||
                                        "opaque" === this.state.value ||
                                        (this.shouldParseEnums() &&
                                            "enum" === this.state.value)
                                    )) &&
                                super.isExportDefaultSpecifier()
                            );
                        }
                        parseExportDefaultExpression() {
                            if (
                                this.shouldParseEnums() &&
                                this.isContextual("enum")
                            ) {
                                const t = this.startNode();
                                return (
                                    this.next(),
                                    this.flowParseEnumDeclaration(t)
                                );
                            }
                            return super.parseExportDefaultExpression();
                        }
                        parseConditional(t, e, n, r) {
                            if (!this.match(h.question)) return t;
                            if (r) {
                                const s = this.tryParse(() =>
                                    super.parseConditional(t, e, n)
                                );
                                return s.node
                                    ? (s.error && (this.state = s.failState),
                                      s.node)
                                    : ((r.start =
                                          s.error.pos || this.state.start),
                                      t);
                            }
                            this.expect(h.question);
                            const s = this.state.clone(),
                                i = this.state.noArrowAt,
                                o = this.startNodeAt(e, n);
                            let { consequent: a, failed: c } =
                                    this.tryParseConditionalConsequent(),
                                [l, u] = this.getArrowLikeExpressions(a);
                            if (c || u.length > 0) {
                                const t = [...i];
                                if (u.length > 0) {
                                    (this.state = s),
                                        (this.state.noArrowAt = t);
                                    for (let e = 0; e < u.length; e++)
                                        t.push(u[e].start);
                                    ({ consequent: a, failed: c } =
                                        this.tryParseConditionalConsequent()),
                                        ([l, u] =
                                            this.getArrowLikeExpressions(a));
                                }
                                c &&
                                    l.length > 1 &&
                                    this.raise(
                                        s.start,
                                        K.AmbiguousConditionalArrow
                                    ),
                                    c &&
                                        1 === l.length &&
                                        ((this.state = s),
                                        (this.state.noArrowAt = t.concat(
                                            l[0].start
                                        )),
                                        ({ consequent: a, failed: c } =
                                            this.tryParseConditionalConsequent()));
                            }
                            return (
                                this.getArrowLikeExpressions(a, !0),
                                (this.state.noArrowAt = i),
                                this.expect(h.colon),
                                (o.test = t),
                                (o.consequent = a),
                                (o.alternate =
                                    this.forwardNoArrowParamsConversionAt(
                                        o,
                                        () =>
                                            this.parseMaybeAssign(
                                                void 0,
                                                void 0,
                                                void 0
                                            )
                                    )),
                                this.finishNode(o, "ConditionalExpression")
                            );
                        }
                        tryParseConditionalConsequent() {
                            this.state.noArrowParamsConversionAt.push(
                                this.state.start
                            );
                            const t = this.parseMaybeAssignAllowIn(),
                                e = !this.match(h.colon);
                            return (
                                this.state.noArrowParamsConversionAt.pop(),
                                { consequent: t, failed: e }
                            );
                        }
                        getArrowLikeExpressions(t, e) {
                            const n = [t],
                                r = [];
                            for (; 0 !== n.length; ) {
                                const t = n.pop();
                                "ArrowFunctionExpression" === t.type
                                    ? (t.typeParameters || !t.returnType
                                          ? this.finishArrowValidation(t)
                                          : r.push(t),
                                      n.push(t.body))
                                    : "ConditionalExpression" === t.type &&
                                      (n.push(t.consequent),
                                      n.push(t.alternate));
                            }
                            return e
                                ? (r.forEach((t) =>
                                      this.finishArrowValidation(t)
                                  ),
                                  [r, []])
                                : (function (t, e) {
                                      const n = [],
                                          r = [];
                                      for (let s = 0; s < t.length; s++)
                                          (e(t[s], s, t) ? n : r).push(t[s]);
                                      return [n, r];
                                  })(r, (t) =>
                                      t.params.every((t) =>
                                          this.isAssignable(t, !0)
                                      )
                                  );
                        }
                        finishArrowValidation(t) {
                            var e;
                            this.toAssignableList(
                                t.params,
                                null == (e = t.extra) ? void 0 : e.trailingComma
                            ),
                                this.scope.enter(6),
                                super.checkParams(t, !1, !0),
                                this.scope.exit();
                        }
                        forwardNoArrowParamsConversionAt(t, e) {
                            let n;
                            return (
                                -1 !==
                                this.state.noArrowParamsConversionAt.indexOf(
                                    t.start
                                )
                                    ? (this.state.noArrowParamsConversionAt.push(
                                          this.state.start
                                      ),
                                      (n = e()),
                                      this.state.noArrowParamsConversionAt.pop())
                                    : (n = e()),
                                n
                            );
                        }
                        parseParenItem(t, e, n) {
                            if (
                                ((t = super.parseParenItem(t, e, n)),
                                this.eat(h.question) &&
                                    ((t.optional = !0),
                                    this.resetEndLocation(t)),
                                this.match(h.colon))
                            ) {
                                const r = this.startNodeAt(e, n);
                                return (
                                    (r.expression = t),
                                    (r.typeAnnotation =
                                        this.flowParseTypeAnnotation()),
                                    this.finishNode(r, "TypeCastExpression")
                                );
                            }
                            return t;
                        }
                        assertModuleNodeAllowed(t) {
                            ("ImportDeclaration" === t.type &&
                                ("type" === t.importKind ||
                                    "typeof" === t.importKind)) ||
                                ("ExportNamedDeclaration" === t.type &&
                                    "type" === t.exportKind) ||
                                ("ExportAllDeclaration" === t.type &&
                                    "type" === t.exportKind) ||
                                super.assertModuleNodeAllowed(t);
                        }
                        parseExport(t) {
                            const e = super.parseExport(t);
                            return (
                                ("ExportNamedDeclaration" !== e.type &&
                                    "ExportAllDeclaration" !== e.type) ||
                                    (e.exportKind = e.exportKind || "value"),
                                e
                            );
                        }
                        parseExportDeclaration(t) {
                            if (this.isContextual("type")) {
                                t.exportKind = "type";
                                const e = this.startNode();
                                return (
                                    this.next(),
                                    this.match(h.braceL)
                                        ? ((t.specifiers =
                                              this.parseExportSpecifiers()),
                                          this.parseExportFrom(t),
                                          null)
                                        : this.flowParseTypeAlias(e)
                                );
                            }
                            if (this.isContextual("opaque")) {
                                t.exportKind = "type";
                                const e = this.startNode();
                                return (
                                    this.next(), this.flowParseOpaqueType(e, !1)
                                );
                            }
                            if (this.isContextual("interface")) {
                                t.exportKind = "type";
                                const e = this.startNode();
                                return this.next(), this.flowParseInterface(e);
                            }
                            if (
                                this.shouldParseEnums() &&
                                this.isContextual("enum")
                            ) {
                                t.exportKind = "value";
                                const e = this.startNode();
                                return (
                                    this.next(),
                                    this.flowParseEnumDeclaration(e)
                                );
                            }
                            return super.parseExportDeclaration(t);
                        }
                        eatExportStar(t) {
                            return (
                                !!super.eatExportStar(...arguments) ||
                                (!(
                                    !this.isContextual("type") ||
                                    this.lookahead().type !== h.star
                                ) &&
                                    ((t.exportKind = "type"),
                                    this.next(),
                                    this.next(),
                                    !0))
                            );
                        }
                        maybeParseExportNamespaceSpecifier(t) {
                            const e = this.state.start,
                                n = super.maybeParseExportNamespaceSpecifier(t);
                            return (
                                n &&
                                    "type" === t.exportKind &&
                                    this.unexpected(e),
                                n
                            );
                        }
                        parseClassId(t, e, n) {
                            super.parseClassId(t, e, n),
                                this.isRelational("<") &&
                                    (t.typeParameters =
                                        this.flowParseTypeParameterDeclaration());
                        }
                        parseClassMember(t, e, n, r) {
                            const s = this.state.start;
                            if (this.isContextual("declare")) {
                                if (this.parseClassMemberFromModifier(t, e))
                                    return;
                                e.declare = !0;
                            }
                            super.parseClassMember(t, e, n, r),
                                e.declare &&
                                    ("ClassProperty" !== e.type &&
                                    "ClassPrivateProperty" !== e.type
                                        ? this.raise(s, K.DeclareClassElement)
                                        : e.value &&
                                          this.raise(
                                              e.value.start,
                                              K.DeclareClassFieldInitializer
                                          ));
                        }
                        getTokenFromCode(t) {
                            const e = this.input.charCodeAt(this.state.pos + 1);
                            return 123 === t && 124 === e
                                ? this.finishOp(h.braceBarL, 2)
                                : !this.state.inType || (62 !== t && 60 !== t)
                                ? this.state.inType && 63 === t
                                    ? this.finishOp(h.question, 1)
                                    : (function (t, e) {
                                          return 64 === t && 64 === e;
                                      })(t, e)
                                    ? ((this.state.isIterator = !0),
                                      super.readWord())
                                    : super.getTokenFromCode(t)
                                : this.finishOp(h.relational, 1);
                        }
                        isAssignable(t, e) {
                            switch (t.type) {
                                case "Identifier":
                                case "ObjectPattern":
                                case "ArrayPattern":
                                case "AssignmentPattern":
                                    return !0;
                                case "ObjectExpression": {
                                    const e = t.properties.length - 1;
                                    return t.properties.every(
                                        (t, n) =>
                                            "ObjectMethod" !== t.type &&
                                            (n === e ||
                                                "SpreadElement" === t.type) &&
                                            this.isAssignable(t)
                                    );
                                }
                                case "ObjectProperty":
                                    return this.isAssignable(t.value);
                                case "SpreadElement":
                                    return this.isAssignable(t.argument);
                                case "ArrayExpression":
                                    return t.elements.every((t) =>
                                        this.isAssignable(t)
                                    );
                                case "AssignmentExpression":
                                    return "=" === t.operator;
                                case "ParenthesizedExpression":
                                case "TypeCastExpression":
                                    return this.isAssignable(t.expression);
                                case "MemberExpression":
                                case "OptionalMemberExpression":
                                    return !e;
                                default:
                                    return !1;
                            }
                        }
                        toAssignable(t) {
                            return "TypeCastExpression" === t.type
                                ? super.toAssignable(
                                      this.typeCastToParameter(t)
                                  )
                                : super.toAssignable(t);
                        }
                        toAssignableList(t, e) {
                            for (let e = 0; e < t.length; e++) {
                                const n = t[e];
                                "TypeCastExpression" ===
                                    (null == n ? void 0 : n.type) &&
                                    (t[e] = this.typeCastToParameter(n));
                            }
                            return super.toAssignableList(t, e);
                        }
                        toReferencedList(t, e) {
                            for (let r = 0; r < t.length; r++) {
                                var n;
                                const s = t[r];
                                s &&
                                    "TypeCastExpression" === s.type &&
                                    !(null == (n = s.extra)
                                        ? void 0
                                        : n.parenthesized) &&
                                    (t.length > 1 || !e) &&
                                    this.raise(
                                        s.typeAnnotation.start,
                                        K.TypeCastInPattern
                                    );
                            }
                            return t;
                        }
                        checkLVal(t, e = 64, n, r) {
                            if ("TypeCastExpression" !== t.type)
                                return super.checkLVal(t, e, n, r);
                        }
                        parseClassProperty(t) {
                            return (
                                this.match(h.colon) &&
                                    (t.typeAnnotation =
                                        this.flowParseTypeAnnotation()),
                                super.parseClassProperty(t)
                            );
                        }
                        parseClassPrivateProperty(t) {
                            return (
                                this.match(h.colon) &&
                                    (t.typeAnnotation =
                                        this.flowParseTypeAnnotation()),
                                super.parseClassPrivateProperty(t)
                            );
                        }
                        isClassMethod() {
                            return (
                                this.isRelational("<") || super.isClassMethod()
                            );
                        }
                        isClassProperty() {
                            return (
                                this.match(h.colon) || super.isClassProperty()
                            );
                        }
                        isNonstaticConstructor(t) {
                            return (
                                !this.match(h.colon) &&
                                super.isNonstaticConstructor(t)
                            );
                        }
                        pushClassMethod(t, e, n, r, s, i) {
                            e.variance && this.unexpected(e.variance.start),
                                delete e.variance,
                                this.isRelational("<") &&
                                    (e.typeParameters =
                                        this.flowParseTypeParameterDeclaration()),
                                super.pushClassMethod(t, e, n, r, s, i);
                        }
                        pushClassPrivateMethod(t, e, n, r) {
                            e.variance && this.unexpected(e.variance.start),
                                delete e.variance,
                                this.isRelational("<") &&
                                    (e.typeParameters =
                                        this.flowParseTypeParameterDeclaration()),
                                super.pushClassPrivateMethod(t, e, n, r);
                        }
                        parseClassSuper(t) {
                            if (
                                (super.parseClassSuper(t),
                                t.superClass &&
                                    this.isRelational("<") &&
                                    (t.superTypeParameters =
                                        this.flowParseTypeParameterInstantiation()),
                                this.isContextual("implements"))
                            ) {
                                this.next();
                                const e = (t.implements = []);
                                do {
                                    const t = this.startNode();
                                    (t.id = this.flowParseRestrictedIdentifier(
                                        !0
                                    )),
                                        this.isRelational("<")
                                            ? (t.typeParameters =
                                                  this.flowParseTypeParameterInstantiation())
                                            : (t.typeParameters = null),
                                        e.push(
                                            this.finishNode(
                                                t,
                                                "ClassImplements"
                                            )
                                        );
                                } while (this.eat(h.comma));
                            }
                        }
                        parsePropertyName(t, e) {
                            const n = this.flowParseVariance(),
                                r = super.parsePropertyName(t, e);
                            return (t.variance = n), r;
                        }
                        parseObjPropValue(t, e, n, r, s, i, o, a) {
                            let c;
                            t.variance && this.unexpected(t.variance.start),
                                delete t.variance,
                                this.isRelational("<") &&
                                    !o &&
                                    ((c =
                                        this.flowParseTypeParameterDeclaration()),
                                    this.match(h.parenL) || this.unexpected()),
                                super.parseObjPropValue(t, e, n, r, s, i, o, a),
                                c && ((t.value || t).typeParameters = c);
                        }
                        parseAssignableListItemTypes(t) {
                            return (
                                this.eat(h.question) &&
                                    ("Identifier" !== t.type &&
                                        this.raise(
                                            t.start,
                                            K.OptionalBindingPattern
                                        ),
                                    (t.optional = !0)),
                                this.match(h.colon) &&
                                    (t.typeAnnotation =
                                        this.flowParseTypeAnnotation()),
                                this.resetEndLocation(t),
                                t
                            );
                        }
                        parseMaybeDefault(t, e, n) {
                            const r = super.parseMaybeDefault(t, e, n);
                            return (
                                "AssignmentPattern" === r.type &&
                                    r.typeAnnotation &&
                                    r.right.start < r.typeAnnotation.start &&
                                    this.raise(
                                        r.typeAnnotation.start,
                                        K.TypeBeforeInitializer
                                    ),
                                r
                            );
                        }
                        shouldParseDefaultImport(t) {
                            return J(t)
                                ? X(this.state)
                                : super.shouldParseDefaultImport(t);
                        }
                        parseImportSpecifierLocal(t, e, n, r) {
                            (e.local = J(t)
                                ? this.flowParseRestrictedIdentifier(!0, !0)
                                : this.parseIdentifier()),
                                this.checkLVal(e.local, 9, void 0, r),
                                t.specifiers.push(this.finishNode(e, n));
                        }
                        maybeParseDefaultImportSpecifier(t) {
                            t.importKind = "value";
                            let e = null;
                            if (
                                (this.match(h._typeof)
                                    ? (e = "typeof")
                                    : this.isContextual("type") && (e = "type"),
                                e)
                            ) {
                                const n = this.lookahead();
                                "type" === e &&
                                    n.type === h.star &&
                                    this.unexpected(n.start),
                                    (X(n) ||
                                        n.type === h.braceL ||
                                        n.type === h.star) &&
                                        (this.next(), (t.importKind = e));
                            }
                            return super.maybeParseDefaultImportSpecifier(t);
                        }
                        parseImportSpecifier(t) {
                            const e = this.startNode(),
                                n = this.state.start,
                                r = this.parseIdentifier(!0);
                            let s = null;
                            "type" === r.name
                                ? (s = "type")
                                : "typeof" === r.name && (s = "typeof");
                            let i = !1;
                            if (
                                this.isContextual("as") &&
                                !this.isLookaheadContextual("as")
                            ) {
                                const t = this.parseIdentifier(!0);
                                null === s ||
                                this.match(h.name) ||
                                this.state.type.keyword
                                    ? ((e.imported = r),
                                      (e.importKind = null),
                                      (e.local = this.parseIdentifier()))
                                    : ((e.imported = t),
                                      (e.importKind = s),
                                      (e.local = t.__clone()));
                            } else
                                null !== s &&
                                (this.match(h.name) || this.state.type.keyword)
                                    ? ((e.imported = this.parseIdentifier(!0)),
                                      (e.importKind = s),
                                      this.eatContextual("as")
                                          ? (e.local = this.parseIdentifier())
                                          : ((i = !0),
                                            (e.local = e.imported.__clone())))
                                    : ((i = !0),
                                      (e.imported = r),
                                      (e.importKind = null),
                                      (e.local = e.imported.__clone()));
                            const o = J(t),
                                a = J(e);
                            o &&
                                a &&
                                this.raise(
                                    n,
                                    K.ImportTypeShorthandOnlyInPureImport
                                ),
                                (o || a) &&
                                    this.checkReservedType(
                                        e.local.name,
                                        e.local.start,
                                        !0
                                    ),
                                !i ||
                                    o ||
                                    a ||
                                    this.checkReservedWord(
                                        e.local.name,
                                        e.start,
                                        !0,
                                        !0
                                    ),
                                this.checkLVal(
                                    e.local,
                                    9,
                                    void 0,
                                    "import specifier"
                                ),
                                t.specifiers.push(
                                    this.finishNode(e, "ImportSpecifier")
                                );
                        }
                        parseFunctionParams(t, e) {
                            const n = t.kind;
                            "get" !== n &&
                                "set" !== n &&
                                this.isRelational("<") &&
                                (t.typeParameters =
                                    this.flowParseTypeParameterDeclaration()),
                                super.parseFunctionParams(t, e);
                        }
                        parseVarId(t, e) {
                            super.parseVarId(t, e),
                                this.match(h.colon) &&
                                    ((t.id.typeAnnotation =
                                        this.flowParseTypeAnnotation()),
                                    this.resetEndLocation(t.id));
                        }
                        parseAsyncArrowFromCallExpression(t, e) {
                            if (this.match(h.colon)) {
                                const e = this.state.noAnonFunctionType;
                                (this.state.noAnonFunctionType = !0),
                                    (t.returnType =
                                        this.flowParseTypeAnnotation()),
                                    (this.state.noAnonFunctionType = e);
                            }
                            return super.parseAsyncArrowFromCallExpression(
                                t,
                                e
                            );
                        }
                        shouldParseAsyncArrow() {
                            return (
                                this.match(h.colon) ||
                                super.shouldParseAsyncArrow()
                            );
                        }
                        parseMaybeAssign(t, e, n) {
                            var r;
                            let s,
                                i = null;
                            if (
                                this.hasPlugin("jsx") &&
                                (this.match(h.jsxTagStart) ||
                                    this.isRelational("<"))
                            ) {
                                if (
                                    ((i = this.state.clone()),
                                    (s = this.tryParse(
                                        () => super.parseMaybeAssign(t, e, n),
                                        i
                                    )),
                                    !s.error)
                                )
                                    return s.node;
                                const { context: r } = this.state;
                                r[r.length - 1] === C.j_oTag
                                    ? (r.length -= 2)
                                    : r[r.length - 1] === C.j_expr &&
                                      (r.length -= 1);
                            }
                            if (
                                (null == (r = s) ? void 0 : r.error) ||
                                this.isRelational("<")
                            ) {
                                var o, a;
                                let r;
                                i = i || this.state.clone();
                                const c = this.tryParse((s) => {
                                    var i;
                                    r =
                                        this.flowParseTypeParameterDeclaration();
                                    const o =
                                        this.forwardNoArrowParamsConversionAt(
                                            r,
                                            () => {
                                                const s =
                                                    super.parseMaybeAssign(
                                                        t,
                                                        e,
                                                        n
                                                    );
                                                return (
                                                    this.resetStartLocationFromNode(
                                                        s,
                                                        r
                                                    ),
                                                    s
                                                );
                                            }
                                        );
                                    "ArrowFunctionExpression" !== o.type &&
                                        (null == (i = o.extra)
                                            ? void 0
                                            : i.parenthesized) &&
                                        s();
                                    const a =
                                        this.maybeUnwrapTypeCastExpression(o);
                                    return (
                                        (a.typeParameters = r),
                                        this.resetStartLocationFromNode(a, r),
                                        o
                                    );
                                }, i);
                                let l = null;
                                if (
                                    c.node &&
                                    "ArrowFunctionExpression" ===
                                        this.maybeUnwrapTypeCastExpression(
                                            c.node
                                        ).type
                                ) {
                                    if (!c.error && !c.aborted)
                                        return (
                                            c.node.async &&
                                                this.raise(
                                                    r.start,
                                                    K.UnexpectedTypeParameterBeforeAsyncArrowFunction
                                                ),
                                            c.node
                                        );
                                    l = c.node;
                                }
                                if (null == (o = s) ? void 0 : o.node)
                                    return (this.state = s.failState), s.node;
                                if (l) return (this.state = c.failState), l;
                                if (null == (a = s) ? void 0 : a.thrown)
                                    throw s.error;
                                if (c.thrown) throw c.error;
                                throw this.raise(
                                    r.start,
                                    K.UnexpectedTokenAfterTypeParameter
                                );
                            }
                            return super.parseMaybeAssign(t, e, n);
                        }
                        parseArrow(t) {
                            if (this.match(h.colon)) {
                                const e = this.tryParse(() => {
                                    const e = this.state.noAnonFunctionType;
                                    this.state.noAnonFunctionType = !0;
                                    const n = this.startNode();
                                    return (
                                        ([n.typeAnnotation, t.predicate] =
                                            this.flowParseTypeAndPredicateInitialiser()),
                                        (this.state.noAnonFunctionType = e),
                                        this.canInsertSemicolon() &&
                                            this.unexpected(),
                                        this.match(h.arrow) ||
                                            this.unexpected(),
                                        n
                                    );
                                });
                                if (e.thrown) return null;
                                e.error && (this.state = e.failState),
                                    (t.returnType = e.node.typeAnnotation
                                        ? this.finishNode(
                                              e.node,
                                              "TypeAnnotation"
                                          )
                                        : null);
                            }
                            return super.parseArrow(t);
                        }
                        shouldParseArrow() {
                            return (
                                this.match(h.colon) || super.shouldParseArrow()
                            );
                        }
                        setArrowFunctionParameters(t, e) {
                            -1 !==
                            this.state.noArrowParamsConversionAt.indexOf(
                                t.start
                            )
                                ? (t.params = e)
                                : super.setArrowFunctionParameters(t, e);
                        }
                        checkParams(t, e, n) {
                            if (
                                !n ||
                                -1 ===
                                    this.state.noArrowParamsConversionAt.indexOf(
                                        t.start
                                    )
                            )
                                return super.checkParams(...arguments);
                        }
                        parseParenAndDistinguishExpression(t) {
                            return super.parseParenAndDistinguishExpression(
                                t &&
                                    -1 ===
                                        this.state.noArrowAt.indexOf(
                                            this.state.start
                                        )
                            );
                        }
                        parseSubscripts(t, e, n, r) {
                            if (
                                "Identifier" === t.type &&
                                "async" === t.name &&
                                -1 !== this.state.noArrowAt.indexOf(e)
                            ) {
                                this.next();
                                const r = this.startNodeAt(e, n);
                                (r.callee = t),
                                    (r.arguments =
                                        this.parseCallExpressionArguments(
                                            h.parenR,
                                            !1
                                        )),
                                    (t = this.finishNode(r, "CallExpression"));
                            } else if (
                                "Identifier" === t.type &&
                                "async" === t.name &&
                                this.isRelational("<")
                            ) {
                                const s = this.state.clone(),
                                    i = this.tryParse(
                                        (t) =>
                                            this.parseAsyncArrowWithTypeParameters(
                                                e,
                                                n
                                            ) || t(),
                                        s
                                    );
                                if (!i.error && !i.aborted) return i.node;
                                const o = this.tryParse(
                                    () => super.parseSubscripts(t, e, n, r),
                                    s
                                );
                                if (o.node && !o.error) return o.node;
                                if (i.node)
                                    return (this.state = i.failState), i.node;
                                if (o.node)
                                    return (this.state = o.failState), o.node;
                                throw i.error || o.error;
                            }
                            return super.parseSubscripts(t, e, n, r);
                        }
                        parseSubscript(t, e, n, r, s) {
                            if (
                                this.match(h.questionDot) &&
                                this.isLookaheadToken_lt()
                            ) {
                                if (((s.optionalChainMember = !0), r))
                                    return (s.stop = !0), t;
                                this.next();
                                const i = this.startNodeAt(e, n);
                                return (
                                    (i.callee = t),
                                    (i.typeArguments =
                                        this.flowParseTypeParameterInstantiation()),
                                    this.expect(h.parenL),
                                    (i.arguments =
                                        this.parseCallExpressionArguments(
                                            h.parenR,
                                            !1
                                        )),
                                    (i.optional = !0),
                                    this.finishCallExpression(i, !0)
                                );
                            }
                            if (
                                !r &&
                                this.shouldParseTypes() &&
                                this.isRelational("<")
                            ) {
                                const r = this.startNodeAt(e, n);
                                r.callee = t;
                                const i = this.tryParse(
                                    () => (
                                        (r.typeArguments =
                                            this.flowParseTypeParameterInstantiationCallOrNew()),
                                        this.expect(h.parenL),
                                        (r.arguments =
                                            this.parseCallExpressionArguments(
                                                h.parenR,
                                                !1
                                            )),
                                        s.optionalChainMember &&
                                            (r.optional = !1),
                                        this.finishCallExpression(
                                            r,
                                            s.optionalChainMember
                                        )
                                    )
                                );
                                if (i.node)
                                    return (
                                        i.error && (this.state = i.failState),
                                        i.node
                                    );
                            }
                            return super.parseSubscript(t, e, n, r, s);
                        }
                        parseNewArguments(t) {
                            let e = null;
                            this.shouldParseTypes() &&
                                this.isRelational("<") &&
                                (e = this.tryParse(() =>
                                    this.flowParseTypeParameterInstantiationCallOrNew()
                                ).node),
                                (t.typeArguments = e),
                                super.parseNewArguments(t);
                        }
                        parseAsyncArrowWithTypeParameters(t, e) {
                            const n = this.startNodeAt(t, e);
                            if (
                                (this.parseFunctionParams(n),
                                this.parseArrow(n))
                            )
                                return this.parseArrowExpression(n, void 0, !0);
                        }
                        readToken_mult_modulo(t) {
                            const e = this.input.charCodeAt(this.state.pos + 1);
                            if (
                                42 === t &&
                                47 === e &&
                                this.state.hasFlowComment
                            )
                                return (
                                    (this.state.hasFlowComment = !1),
                                    (this.state.pos += 2),
                                    void this.nextToken()
                                );
                            super.readToken_mult_modulo(t);
                        }
                        readToken_pipe_amp(t) {
                            const e = this.input.charCodeAt(this.state.pos + 1);
                            124 !== t || 125 !== e
                                ? super.readToken_pipe_amp(t)
                                : this.finishOp(h.braceBarR, 2);
                        }
                        parseTopLevel(t, e) {
                            const n = super.parseTopLevel(t, e);
                            return (
                                this.state.hasFlowComment &&
                                    this.raise(
                                        this.state.pos,
                                        K.UnterminatedFlowComment
                                    ),
                                n
                            );
                        }
                        skipBlockComment() {
                            if (
                                this.hasPlugin("flowComments") &&
                                this.skipFlowComment()
                            )
                                return (
                                    this.state.hasFlowComment &&
                                        this.unexpected(
                                            null,
                                            K.NestedFlowComment
                                        ),
                                    this.hasFlowCommentCompletion(),
                                    (this.state.pos += this.skipFlowComment()),
                                    void (this.state.hasFlowComment = !0)
                                );
                            if (this.state.hasFlowComment) {
                                const t = this.input.indexOf(
                                    "*-/",
                                    (this.state.pos += 2)
                                );
                                if (-1 === t)
                                    throw this.raise(
                                        this.state.pos - 2,
                                        E.UnterminatedComment
                                    );
                                this.state.pos = t + 3;
                            } else super.skipBlockComment();
                        }
                        skipFlowComment() {
                            const { pos: t } = this.state;
                            let e = 2;
                            for (
                                ;
                                [32, 9].includes(this.input.charCodeAt(t + e));

                            )
                                e++;
                            const n = this.input.charCodeAt(e + t),
                                r = this.input.charCodeAt(e + t + 1);
                            return 58 === n && 58 === r
                                ? e + 2
                                : "flow-include" ===
                                  this.input.slice(e + t, e + t + 12)
                                ? e + 12
                                : 58 === n && 58 !== r && e;
                        }
                        hasFlowCommentCompletion() {
                            if (-1 === this.input.indexOf("*/", this.state.pos))
                                throw this.raise(
                                    this.state.pos,
                                    E.UnterminatedComment
                                );
                        }
                        flowEnumErrorBooleanMemberNotInitialized(
                            t,
                            { enumName: e, memberName: n }
                        ) {
                            this.raise(
                                t,
                                K.EnumBooleanMemberNotInitialized,
                                n,
                                e
                            );
                        }
                        flowEnumErrorInvalidMemberName(
                            t,
                            { enumName: e, memberName: n }
                        ) {
                            const r = n[0].toUpperCase() + n.slice(1);
                            this.raise(t, K.EnumInvalidMemberName, n, r, e);
                        }
                        flowEnumErrorDuplicateMemberName(
                            t,
                            { enumName: e, memberName: n }
                        ) {
                            this.raise(t, K.EnumDuplicateMemberName, n, e);
                        }
                        flowEnumErrorInconsistentMemberValues(
                            t,
                            { enumName: e }
                        ) {
                            this.raise(t, K.EnumInconsistentMemberValues, e);
                        }
                        flowEnumErrorInvalidExplicitType(
                            t,
                            { enumName: e, suppliedType: n }
                        ) {
                            return this.raise(
                                t,
                                null === n
                                    ? K.EnumInvalidExplicitTypeUnknownSupplied
                                    : K.EnumInvalidExplicitType,
                                e,
                                n
                            );
                        }
                        flowEnumErrorInvalidMemberInitializer(
                            t,
                            { enumName: e, explicitType: n, memberName: r }
                        ) {
                            let s = null;
                            switch (n) {
                                case "boolean":
                                case "number":
                                case "string":
                                    s =
                                        K.EnumInvalidMemberInitializerPrimaryType;
                                    break;
                                case "symbol":
                                    s =
                                        K.EnumInvalidMemberInitializerSymbolType;
                                    break;
                                default:
                                    s =
                                        K.EnumInvalidMemberInitializerUnknownType;
                            }
                            return this.raise(t, s, e, r, n);
                        }
                        flowEnumErrorNumberMemberNotInitialized(
                            t,
                            { enumName: e, memberName: n }
                        ) {
                            this.raise(
                                t,
                                K.EnumNumberMemberNotInitialized,
                                e,
                                n
                            );
                        }
                        flowEnumErrorStringMemberInconsistentlyInitailized(
                            t,
                            { enumName: e }
                        ) {
                            this.raise(
                                t,
                                K.EnumStringMemberInconsistentlyInitailized,
                                e
                            );
                        }
                        flowEnumMemberInit() {
                            const t = this.state.start,
                                e = () =>
                                    this.match(h.comma) || this.match(h.braceR);
                            switch (this.state.type) {
                                case h.num: {
                                    const n = this.parseLiteral(
                                        this.state.value,
                                        "NumericLiteral"
                                    );
                                    return e()
                                        ? {
                                              type: "number",
                                              pos: n.start,
                                              value: n,
                                          }
                                        : { type: "invalid", pos: t };
                                }
                                case h.string: {
                                    const n = this.parseLiteral(
                                        this.state.value,
                                        "StringLiteral"
                                    );
                                    return e()
                                        ? {
                                              type: "string",
                                              pos: n.start,
                                              value: n,
                                          }
                                        : { type: "invalid", pos: t };
                                }
                                case h._true:
                                case h._false: {
                                    const n = this.parseBooleanLiteral();
                                    return e()
                                        ? {
                                              type: "boolean",
                                              pos: n.start,
                                              value: n,
                                          }
                                        : { type: "invalid", pos: t };
                                }
                                default:
                                    return { type: "invalid", pos: t };
                            }
                        }
                        flowEnumMemberRaw() {
                            const t = this.state.start;
                            return {
                                id: this.parseIdentifier(!0),
                                init: this.eat(h.eq)
                                    ? this.flowEnumMemberInit()
                                    : { type: "none", pos: t },
                            };
                        }
                        flowEnumCheckExplicitTypeMismatch(t, e, n) {
                            const { explicitType: r } = e;
                            null !== r &&
                                r !== n &&
                                this.flowEnumErrorInvalidMemberInitializer(
                                    t,
                                    e
                                );
                        }
                        flowEnumMembers({ enumName: t, explicitType: e }) {
                            const n = new Set(),
                                r = {
                                    booleanMembers: [],
                                    numberMembers: [],
                                    stringMembers: [],
                                    defaultedMembers: [],
                                };
                            for (; !this.match(h.braceR); ) {
                                const s = this.startNode(),
                                    { id: i, init: o } =
                                        this.flowEnumMemberRaw(),
                                    a = i.name;
                                if ("" === a) continue;
                                /^[a-z]/.test(a) &&
                                    this.flowEnumErrorInvalidMemberName(
                                        i.start,
                                        { enumName: t, memberName: a }
                                    ),
                                    n.has(a) &&
                                        this.flowEnumErrorDuplicateMemberName(
                                            i.start,
                                            { enumName: t, memberName: a }
                                        ),
                                    n.add(a);
                                const c = {
                                    enumName: t,
                                    explicitType: e,
                                    memberName: a,
                                };
                                switch (((s.id = i), o.type)) {
                                    case "boolean":
                                        this.flowEnumCheckExplicitTypeMismatch(
                                            o.pos,
                                            c,
                                            "boolean"
                                        ),
                                            (s.init = o.value),
                                            r.booleanMembers.push(
                                                this.finishNode(
                                                    s,
                                                    "EnumBooleanMember"
                                                )
                                            );
                                        break;
                                    case "number":
                                        this.flowEnumCheckExplicitTypeMismatch(
                                            o.pos,
                                            c,
                                            "number"
                                        ),
                                            (s.init = o.value),
                                            r.numberMembers.push(
                                                this.finishNode(
                                                    s,
                                                    "EnumNumberMember"
                                                )
                                            );
                                        break;
                                    case "string":
                                        this.flowEnumCheckExplicitTypeMismatch(
                                            o.pos,
                                            c,
                                            "string"
                                        ),
                                            (s.init = o.value),
                                            r.stringMembers.push(
                                                this.finishNode(
                                                    s,
                                                    "EnumStringMember"
                                                )
                                            );
                                        break;
                                    case "invalid":
                                        throw this.flowEnumErrorInvalidMemberInitializer(
                                            o.pos,
                                            c
                                        );
                                    case "none":
                                        switch (e) {
                                            case "boolean":
                                                this.flowEnumErrorBooleanMemberNotInitialized(
                                                    o.pos,
                                                    c
                                                );
                                                break;
                                            case "number":
                                                this.flowEnumErrorNumberMemberNotInitialized(
                                                    o.pos,
                                                    c
                                                );
                                                break;
                                            default:
                                                r.defaultedMembers.push(
                                                    this.finishNode(
                                                        s,
                                                        "EnumDefaultedMember"
                                                    )
                                                );
                                        }
                                }
                                this.match(h.braceR) || this.expect(h.comma);
                            }
                            return r;
                        }
                        flowEnumStringMembers(t, e, { enumName: n }) {
                            if (0 === t.length) return e;
                            if (0 === e.length) return t;
                            if (e.length > t.length) {
                                for (let e = 0; e < t.length; e++) {
                                    const r = t[e];
                                    this.flowEnumErrorStringMemberInconsistentlyInitailized(
                                        r.start,
                                        { enumName: n }
                                    );
                                }
                                return e;
                            }
                            for (let t = 0; t < e.length; t++) {
                                const r = e[t];
                                this.flowEnumErrorStringMemberInconsistentlyInitailized(
                                    r.start,
                                    { enumName: n }
                                );
                            }
                            return t;
                        }
                        flowEnumParseExplicitType({ enumName: t }) {
                            if (this.eatContextual("of")) {
                                if (!this.match(h.name))
                                    throw this.flowEnumErrorInvalidExplicitType(
                                        this.state.start,
                                        { enumName: t, suppliedType: null }
                                    );
                                const { value: e } = this.state;
                                return (
                                    this.next(),
                                    "boolean" !== e &&
                                        "number" !== e &&
                                        "string" !== e &&
                                        "symbol" !== e &&
                                        this.flowEnumErrorInvalidExplicitType(
                                            this.state.start,
                                            { enumName: t, suppliedType: e }
                                        ),
                                    e
                                );
                            }
                            return null;
                        }
                        flowEnumBody(t, { enumName: e, nameLoc: n }) {
                            const r = this.flowEnumParseExplicitType({
                                enumName: e,
                            });
                            this.expect(h.braceL);
                            const s = this.flowEnumMembers({
                                enumName: e,
                                explicitType: r,
                            });
                            switch (r) {
                                case "boolean":
                                    return (
                                        (t.explicitType = !0),
                                        (t.members = s.booleanMembers),
                                        this.expect(h.braceR),
                                        this.finishNode(t, "EnumBooleanBody")
                                    );
                                case "number":
                                    return (
                                        (t.explicitType = !0),
                                        (t.members = s.numberMembers),
                                        this.expect(h.braceR),
                                        this.finishNode(t, "EnumNumberBody")
                                    );
                                case "string":
                                    return (
                                        (t.explicitType = !0),
                                        (t.members = this.flowEnumStringMembers(
                                            s.stringMembers,
                                            s.defaultedMembers,
                                            { enumName: e }
                                        )),
                                        this.expect(h.braceR),
                                        this.finishNode(t, "EnumStringBody")
                                    );
                                case "symbol":
                                    return (
                                        (t.members = s.defaultedMembers),
                                        this.expect(h.braceR),
                                        this.finishNode(t, "EnumSymbolBody")
                                    );
                                default: {
                                    const r = () => (
                                        (t.members = []),
                                        this.expect(h.braceR),
                                        this.finishNode(t, "EnumStringBody")
                                    );
                                    t.explicitType = !1;
                                    const i = s.booleanMembers.length,
                                        o = s.numberMembers.length,
                                        a = s.stringMembers.length,
                                        c = s.defaultedMembers.length;
                                    if (i || o || a || c) {
                                        if (i || o) {
                                            if (!o && !a && i >= c) {
                                                for (
                                                    let t = 0,
                                                        n = s.defaultedMembers;
                                                    t < n.length;
                                                    t++
                                                ) {
                                                    const r = n[t];
                                                    this.flowEnumErrorBooleanMemberNotInitialized(
                                                        r.start,
                                                        {
                                                            enumName: e,
                                                            memberName:
                                                                r.id.name,
                                                        }
                                                    );
                                                }
                                                return (
                                                    (t.members =
                                                        s.booleanMembers),
                                                    this.expect(h.braceR),
                                                    this.finishNode(
                                                        t,
                                                        "EnumBooleanBody"
                                                    )
                                                );
                                            }
                                            if (!i && !a && o >= c) {
                                                for (
                                                    let t = 0,
                                                        n = s.defaultedMembers;
                                                    t < n.length;
                                                    t++
                                                ) {
                                                    const r = n[t];
                                                    this.flowEnumErrorNumberMemberNotInitialized(
                                                        r.start,
                                                        {
                                                            enumName: e,
                                                            memberName:
                                                                r.id.name,
                                                        }
                                                    );
                                                }
                                                return (
                                                    (t.members =
                                                        s.numberMembers),
                                                    this.expect(h.braceR),
                                                    this.finishNode(
                                                        t,
                                                        "EnumNumberBody"
                                                    )
                                                );
                                            }
                                            return (
                                                this.flowEnumErrorInconsistentMemberValues(
                                                    n,
                                                    { enumName: e }
                                                ),
                                                r()
                                            );
                                        }
                                        return (
                                            (t.members =
                                                this.flowEnumStringMembers(
                                                    s.stringMembers,
                                                    s.defaultedMembers,
                                                    { enumName: e }
                                                )),
                                            this.expect(h.braceR),
                                            this.finishNode(t, "EnumStringBody")
                                        );
                                    }
                                    return r();
                                }
                            }
                        }
                        flowParseEnumDeclaration(t) {
                            const e = this.parseIdentifier();
                            return (
                                (t.id = e),
                                (t.body = this.flowEnumBody(this.startNode(), {
                                    enumName: e.name,
                                    nameLoc: e.start,
                                })),
                                this.finishNode(t, "EnumDeclaration")
                            );
                        }
                        updateContext(t) {
                            this.match(h.name) &&
                            "of" === this.state.value &&
                            t === h.name &&
                            "interface" ===
                                this.input.slice(
                                    this.state.lastTokStart,
                                    this.state.lastTokEnd
                                )
                                ? (this.state.exprAllowed = !1)
                                : super.updateContext(t);
                        }
                        isLookaheadToken_lt() {
                            const t = this.nextTokenStart();
                            if (60 === this.input.charCodeAt(t)) {
                                const e = this.input.charCodeAt(t + 1);
                                return 60 !== e && 61 !== e;
                            }
                            return !1;
                        }
                        maybeUnwrapTypeCastExpression(t) {
                            return "TypeCastExpression" === t.type
                                ? t.expression
                                : t;
                        }
                    },
                typescript: (t) =>
                    class extends t {
                        getScopeHandler() {
                            return ct;
                        }
                        tsIsIdentifier() {
                            return this.match(h.name);
                        }
                        tsNextTokenCanFollowModifier() {
                            return (
                                this.next(),
                                !(
                                    this.hasPrecedingLineBreak() ||
                                    this.match(h.parenL) ||
                                    this.match(h.parenR) ||
                                    this.match(h.colon) ||
                                    this.match(h.eq) ||
                                    this.match(h.question) ||
                                    this.match(h.bang)
                                )
                            );
                        }
                        tsParseModifier(t) {
                            if (!this.match(h.name)) return;
                            const e = this.state.value;
                            return -1 !== t.indexOf(e) &&
                                this.tsTryParse(
                                    this.tsNextTokenCanFollowModifier.bind(this)
                                )
                                ? e
                                : void 0;
                        }
                        tsParseModifiers(t, e) {
                            for (;;) {
                                const n = this.state.start,
                                    r = this.tsParseModifier(e);
                                if (!r) break;
                                Object.hasOwnProperty.call(t, r) &&
                                    this.raise(n, dt.DuplicateModifier, r),
                                    (t[r] = !0);
                            }
                        }
                        tsIsListTerminator(t) {
                            switch (t) {
                                case "EnumMembers":
                                case "TypeMembers":
                                    return this.match(h.braceR);
                                case "HeritageClauseElement":
                                    return this.match(h.braceL);
                                case "TupleElementTypes":
                                    return this.match(h.bracketR);
                                case "TypeParametersOrArguments":
                                    return this.isRelational(">");
                            }
                            throw new Error("Unreachable");
                        }
                        tsParseList(t, e) {
                            const n = [];
                            for (; !this.tsIsListTerminator(t); ) n.push(e());
                            return n;
                        }
                        tsParseDelimitedList(t, e) {
                            return ht(
                                this.tsParseDelimitedListWorker(t, e, !0)
                            );
                        }
                        tsParseDelimitedListWorker(t, e, n) {
                            const r = [];
                            for (; !this.tsIsListTerminator(t); ) {
                                const s = e();
                                if (null == s) return;
                                if ((r.push(s), !this.eat(h.comma))) {
                                    if (this.tsIsListTerminator(t)) break;
                                    return void (n && this.expect(h.comma));
                                }
                            }
                            return r;
                        }
                        tsParseBracketedList(t, e, n, r) {
                            r ||
                                (n
                                    ? this.expect(h.bracketL)
                                    : this.expectRelational("<"));
                            const s = this.tsParseDelimitedList(t, e);
                            return (
                                n
                                    ? this.expect(h.bracketR)
                                    : this.expectRelational(">"),
                                s
                            );
                        }
                        tsParseImportType() {
                            const t = this.startNode();
                            return (
                                this.expect(h._import),
                                this.expect(h.parenL),
                                this.match(h.string) ||
                                    this.raise(
                                        this.state.start,
                                        dt.UnsupportedImportTypeArgument
                                    ),
                                (t.argument = this.parseExprAtom()),
                                this.expect(h.parenR),
                                this.eat(h.dot) &&
                                    (t.qualifier = this.tsParseEntityName(!0)),
                                this.isRelational("<") &&
                                    (t.typeParameters =
                                        this.tsParseTypeArguments()),
                                this.finishNode(t, "TSImportType")
                            );
                        }
                        tsParseEntityName(t) {
                            let e = this.parseIdentifier();
                            for (; this.eat(h.dot); ) {
                                const n = this.startNodeAtNode(e);
                                (n.left = e),
                                    (n.right = this.parseIdentifier(t)),
                                    (e = this.finishNode(n, "TSQualifiedName"));
                            }
                            return e;
                        }
                        tsParseTypeReference() {
                            const t = this.startNode();
                            return (
                                (t.typeName = this.tsParseEntityName(!1)),
                                !this.hasPrecedingLineBreak() &&
                                    this.isRelational("<") &&
                                    (t.typeParameters =
                                        this.tsParseTypeArguments()),
                                this.finishNode(t, "TSTypeReference")
                            );
                        }
                        tsParseThisTypePredicate(t) {
                            this.next();
                            const e = this.startNodeAtNode(t);
                            return (
                                (e.parameterName = t),
                                (e.typeAnnotation = this.tsParseTypeAnnotation(
                                    !1
                                )),
                                this.finishNode(e, "TSTypePredicate")
                            );
                        }
                        tsParseThisTypeNode() {
                            const t = this.startNode();
                            return (
                                this.next(), this.finishNode(t, "TSThisType")
                            );
                        }
                        tsParseTypeQuery() {
                            const t = this.startNode();
                            return (
                                this.expect(h._typeof),
                                this.match(h._import)
                                    ? (t.exprName = this.tsParseImportType())
                                    : (t.exprName = this.tsParseEntityName(!0)),
                                this.finishNode(t, "TSTypeQuery")
                            );
                        }
                        tsParseTypeParameter() {
                            const t = this.startNode();
                            return (
                                (t.name = this.parseIdentifierName(t.start)),
                                (t.constraint = this.tsEatThenParseType(
                                    h._extends
                                )),
                                (t.default = this.tsEatThenParseType(h.eq)),
                                this.finishNode(t, "TSTypeParameter")
                            );
                        }
                        tsTryParseTypeParameters() {
                            if (this.isRelational("<"))
                                return this.tsParseTypeParameters();
                        }
                        tsParseTypeParameters() {
                            const t = this.startNode();
                            return (
                                this.isRelational("<") ||
                                this.match(h.jsxTagStart)
                                    ? this.next()
                                    : this.unexpected(),
                                (t.params = this.tsParseBracketedList(
                                    "TypeParametersOrArguments",
                                    this.tsParseTypeParameter.bind(this),
                                    !1,
                                    !0
                                )),
                                this.finishNode(t, "TSTypeParameterDeclaration")
                            );
                        }
                        tsTryNextParseConstantContext() {
                            return this.lookahead().type === h._const
                                ? (this.next(), this.tsParseTypeReference())
                                : null;
                        }
                        tsFillSignature(t, e) {
                            const n = t === h.arrow;
                            (e.typeParameters =
                                this.tsTryParseTypeParameters()),
                                this.expect(h.parenL),
                                (e.parameters =
                                    this.tsParseBindingListForSignature()),
                                (n || this.match(t)) &&
                                    (e.typeAnnotation =
                                        this.tsParseTypeOrTypePredicateAnnotation(
                                            t
                                        ));
                        }
                        tsParseBindingListForSignature() {
                            return this.parseBindingList(h.parenR, 41).map(
                                (t) => (
                                    "Identifier" !== t.type &&
                                        "RestElement" !== t.type &&
                                        "ObjectPattern" !== t.type &&
                                        "ArrayPattern" !== t.type &&
                                        this.raise(
                                            t.start,
                                            dt.UnsupportedSignatureParameterKind,
                                            t.type
                                        ),
                                    t
                                )
                            );
                        }
                        tsParseTypeMemberSemicolon() {
                            this.eat(h.comma) || this.semicolon();
                        }
                        tsParseSignatureMember(t, e) {
                            return (
                                this.tsFillSignature(h.colon, e),
                                this.tsParseTypeMemberSemicolon(),
                                this.finishNode(e, t)
                            );
                        }
                        tsIsUnambiguouslyIndexSignature() {
                            return (
                                this.next(),
                                this.eat(h.name) && this.match(h.colon)
                            );
                        }
                        tsTryParseIndexSignature(t) {
                            if (
                                !this.match(h.bracketL) ||
                                !this.tsLookAhead(
                                    this.tsIsUnambiguouslyIndexSignature.bind(
                                        this
                                    )
                                )
                            )
                                return;
                            this.expect(h.bracketL);
                            const e = this.parseIdentifier();
                            (e.typeAnnotation = this.tsParseTypeAnnotation()),
                                this.resetEndLocation(e),
                                this.expect(h.bracketR),
                                (t.parameters = [e]);
                            const n = this.tsTryParseTypeAnnotation();
                            return (
                                n && (t.typeAnnotation = n),
                                this.tsParseTypeMemberSemicolon(),
                                this.finishNode(t, "TSIndexSignature")
                            );
                        }
                        tsParsePropertyOrMethodSignature(t, e) {
                            this.eat(h.question) && (t.optional = !0);
                            const n = t;
                            if (
                                e ||
                                (!this.match(h.parenL) &&
                                    !this.isRelational("<"))
                            ) {
                                const t = n;
                                e && (t.readonly = !0);
                                const r = this.tsTryParseTypeAnnotation();
                                return (
                                    r && (t.typeAnnotation = r),
                                    this.tsParseTypeMemberSemicolon(),
                                    this.finishNode(t, "TSPropertySignature")
                                );
                            }
                            {
                                const t = n;
                                return (
                                    this.tsFillSignature(h.colon, t),
                                    this.tsParseTypeMemberSemicolon(),
                                    this.finishNode(t, "TSMethodSignature")
                                );
                            }
                        }
                        tsParseTypeMember() {
                            const t = this.startNode();
                            if (this.match(h.parenL) || this.isRelational("<"))
                                return this.tsParseSignatureMember(
                                    "TSCallSignatureDeclaration",
                                    t
                                );
                            if (this.match(h._new)) {
                                const e = this.startNode();
                                return (
                                    this.next(),
                                    this.match(h.parenL) ||
                                    this.isRelational("<")
                                        ? this.tsParseSignatureMember(
                                              "TSConstructSignatureDeclaration",
                                              t
                                          )
                                        : ((t.key = this.createIdentifier(
                                              e,
                                              "new"
                                          )),
                                          this.tsParsePropertyOrMethodSignature(
                                              t,
                                              !1
                                          ))
                                );
                            }
                            const e = !!this.tsParseModifier(["readonly"]),
                                n = this.tsTryParseIndexSignature(t);
                            return n
                                ? (e && (t.readonly = !0), n)
                                : (this.parsePropertyName(t, !1),
                                  this.tsParsePropertyOrMethodSignature(t, e));
                        }
                        tsParseTypeLiteral() {
                            const t = this.startNode();
                            return (
                                (t.members = this.tsParseObjectTypeMembers()),
                                this.finishNode(t, "TSTypeLiteral")
                            );
                        }
                        tsParseObjectTypeMembers() {
                            this.expect(h.braceL);
                            const t = this.tsParseList(
                                "TypeMembers",
                                this.tsParseTypeMember.bind(this)
                            );
                            return this.expect(h.braceR), t;
                        }
                        tsIsStartOfMappedType() {
                            return (
                                this.next(),
                                this.eat(h.plusMin)
                                    ? this.isContextual("readonly")
                                    : (this.isContextual("readonly") &&
                                          this.next(),
                                      !!this.match(h.bracketL) &&
                                          (this.next(),
                                          !!this.tsIsIdentifier() &&
                                              (this.next(), this.match(h._in))))
                            );
                        }
                        tsParseMappedTypeParameter() {
                            const t = this.startNode();
                            return (
                                (t.name = this.parseIdentifierName(t.start)),
                                (t.constraint = this.tsExpectThenParseType(
                                    h._in
                                )),
                                this.finishNode(t, "TSTypeParameter")
                            );
                        }
                        tsParseMappedType() {
                            const t = this.startNode();
                            return (
                                this.expect(h.braceL),
                                this.match(h.plusMin)
                                    ? ((t.readonly = this.state.value),
                                      this.next(),
                                      this.expectContextual("readonly"))
                                    : this.eatContextual("readonly") &&
                                      (t.readonly = !0),
                                this.expect(h.bracketL),
                                (t.typeParameter =
                                    this.tsParseMappedTypeParameter()),
                                this.expect(h.bracketR),
                                this.match(h.plusMin)
                                    ? ((t.optional = this.state.value),
                                      this.next(),
                                      this.expect(h.question))
                                    : this.eat(h.question) && (t.optional = !0),
                                (t.typeAnnotation = this.tsTryParseType()),
                                this.semicolon(),
                                this.expect(h.braceR),
                                this.finishNode(t, "TSMappedType")
                            );
                        }
                        tsParseTupleType() {
                            const t = this.startNode();
                            t.elementTypes = this.tsParseBracketedList(
                                "TupleElementTypes",
                                this.tsParseTupleElementType.bind(this),
                                !0,
                                !1
                            );
                            let e = !1,
                                n = null;
                            return (
                                t.elementTypes.forEach((t) => {
                                    var r;
                                    let { type: s } = t;
                                    !e ||
                                        "TSRestType" === s ||
                                        "TSOptionalType" === s ||
                                        ("TSNamedTupleMember" === s &&
                                            t.optional) ||
                                        this.raise(
                                            t.start,
                                            dt.OptionalTypeBeforeRequired
                                        ),
                                        (e =
                                            e ||
                                            ("TSNamedTupleMember" === s &&
                                                t.optional) ||
                                            "TSOptionalType" === s),
                                        "TSRestType" === s &&
                                            (s = (t = t.typeAnnotation).type);
                                    const i = "TSNamedTupleMember" === s;
                                    (n = null != (r = n) ? r : i),
                                        n !== i &&
                                            this.raise(
                                                t.start,
                                                dt.MixedLabeledAndUnlabeledElements
                                            );
                                }),
                                this.finishNode(t, "TSTupleType")
                            );
                        }
                        tsParseTupleElementType() {
                            const { start: t, startLoc: e } = this.state,
                                n = this.eat(h.ellipsis);
                            let r = this.tsParseType();
                            const s = this.eat(h.question);
                            if (this.eat(h.colon)) {
                                const t = this.startNodeAtNode(r);
                                (t.optional = s),
                                    "TSTypeReference" !== r.type ||
                                    r.typeParameters ||
                                    "Identifier" !== r.typeName.type
                                        ? (this.raise(
                                              r.start,
                                              dt.InvalidTupleMemberLabel
                                          ),
                                          (t.label = r))
                                        : (t.label = r.typeName),
                                    (t.elementType = this.tsParseType()),
                                    (r = this.finishNode(
                                        t,
                                        "TSNamedTupleMember"
                                    ));
                            } else if (s) {
                                const t = this.startNodeAtNode(r);
                                (t.typeAnnotation = r),
                                    (r = this.finishNode(t, "TSOptionalType"));
                            }
                            if (n) {
                                const n = this.startNodeAt(t, e);
                                (n.typeAnnotation = r),
                                    (r = this.finishNode(n, "TSRestType"));
                            }
                            return r;
                        }
                        tsParseParenthesizedType() {
                            const t = this.startNode();
                            return (
                                this.expect(h.parenL),
                                (t.typeAnnotation = this.tsParseType()),
                                this.expect(h.parenR),
                                this.finishNode(t, "TSParenthesizedType")
                            );
                        }
                        tsParseFunctionOrConstructorType(t) {
                            const e = this.startNode();
                            return (
                                "TSConstructorType" === t &&
                                    this.expect(h._new),
                                this.tsFillSignature(h.arrow, e),
                                this.finishNode(e, t)
                            );
                        }
                        tsParseLiteralTypeNode() {
                            const t = this.startNode();
                            return (
                                (t.literal = (() => {
                                    switch (this.state.type) {
                                        case h.num:
                                        case h.bigint:
                                        case h.string:
                                        case h._true:
                                        case h._false:
                                            return this.parseExprAtom();
                                        default:
                                            throw this.unexpected();
                                    }
                                })()),
                                this.finishNode(t, "TSLiteralType")
                            );
                        }
                        tsParseTemplateLiteralType() {
                            const t = this.startNode(),
                                e = this.parseTemplate(!1);
                            return (
                                e.expressions.length > 0 &&
                                    this.raise(
                                        e.expressions[0].start,
                                        dt.TemplateTypeHasSubstitution
                                    ),
                                (t.literal = e),
                                this.finishNode(t, "TSLiteralType")
                            );
                        }
                        tsParseThisTypeOrThisTypePredicate() {
                            const t = this.tsParseThisTypeNode();
                            return this.isContextual("is") &&
                                !this.hasPrecedingLineBreak()
                                ? this.tsParseThisTypePredicate(t)
                                : t;
                        }
                        tsParseNonArrayType() {
                            switch (this.state.type) {
                                case h.name:
                                case h._void:
                                case h._null: {
                                    const t = this.match(h._void)
                                        ? "TSVoidKeyword"
                                        : this.match(h._null)
                                        ? "TSNullKeyword"
                                        : (function (t) {
                                              switch (t) {
                                                  case "any":
                                                      return "TSAnyKeyword";
                                                  case "boolean":
                                                      return "TSBooleanKeyword";
                                                  case "bigint":
                                                      return "TSBigIntKeyword";
                                                  case "never":
                                                      return "TSNeverKeyword";
                                                  case "number":
                                                      return "TSNumberKeyword";
                                                  case "object":
                                                      return "TSObjectKeyword";
                                                  case "string":
                                                      return "TSStringKeyword";
                                                  case "symbol":
                                                      return "TSSymbolKeyword";
                                                  case "undefined":
                                                      return "TSUndefinedKeyword";
                                                  case "unknown":
                                                      return "TSUnknownKeyword";
                                                  default:
                                                      return;
                                              }
                                          })(this.state.value);
                                    if (
                                        void 0 !== t &&
                                        46 !== this.lookaheadCharCode()
                                    ) {
                                        const e = this.startNode();
                                        return (
                                            this.next(), this.finishNode(e, t)
                                        );
                                    }
                                    return this.tsParseTypeReference();
                                }
                                case h.string:
                                case h.num:
                                case h.bigint:
                                case h._true:
                                case h._false:
                                    return this.tsParseLiteralTypeNode();
                                case h.plusMin:
                                    if ("-" === this.state.value) {
                                        const t = this.startNode(),
                                            e = this.lookahead();
                                        if (
                                            e.type !== h.num &&
                                            e.type !== h.bigint
                                        )
                                            throw this.unexpected();
                                        return (
                                            (t.literal =
                                                this.parseMaybeUnary()),
                                            this.finishNode(t, "TSLiteralType")
                                        );
                                    }
                                    break;
                                case h._this:
                                    return this.tsParseThisTypeOrThisTypePredicate();
                                case h._typeof:
                                    return this.tsParseTypeQuery();
                                case h._import:
                                    return this.tsParseImportType();
                                case h.braceL:
                                    return this.tsLookAhead(
                                        this.tsIsStartOfMappedType.bind(this)
                                    )
                                        ? this.tsParseMappedType()
                                        : this.tsParseTypeLiteral();
                                case h.bracketL:
                                    return this.tsParseTupleType();
                                case h.parenL:
                                    return this.tsParseParenthesizedType();
                                case h.backQuote:
                                    return this.tsParseTemplateLiteralType();
                            }
                            throw this.unexpected();
                        }
                        tsParseArrayTypeOrHigher() {
                            let t = this.tsParseNonArrayType();
                            for (
                                ;
                                !this.hasPrecedingLineBreak() &&
                                this.eat(h.bracketL);

                            )
                                if (this.match(h.bracketR)) {
                                    const e = this.startNodeAtNode(t);
                                    (e.elementType = t),
                                        this.expect(h.bracketR),
                                        (t = this.finishNode(e, "TSArrayType"));
                                } else {
                                    const e = this.startNodeAtNode(t);
                                    (e.objectType = t),
                                        (e.indexType = this.tsParseType()),
                                        this.expect(h.bracketR),
                                        (t = this.finishNode(
                                            e,
                                            "TSIndexedAccessType"
                                        ));
                                }
                            return t;
                        }
                        tsParseTypeOperator(t) {
                            const e = this.startNode();
                            return (
                                this.expectContextual(t),
                                (e.operator = t),
                                (e.typeAnnotation =
                                    this.tsParseTypeOperatorOrHigher()),
                                "readonly" === t &&
                                    this.tsCheckTypeAnnotationForReadOnly(e),
                                this.finishNode(e, "TSTypeOperator")
                            );
                        }
                        tsCheckTypeAnnotationForReadOnly(t) {
                            switch (t.typeAnnotation.type) {
                                case "TSTupleType":
                                case "TSArrayType":
                                    return;
                                default:
                                    this.raise(t.start, dt.UnexpectedReadonly);
                            }
                        }
                        tsParseInferType() {
                            const t = this.startNode();
                            this.expectContextual("infer");
                            const e = this.startNode();
                            return (
                                (e.name = this.parseIdentifierName(e.start)),
                                (t.typeParameter = this.finishNode(
                                    e,
                                    "TSTypeParameter"
                                )),
                                this.finishNode(t, "TSInferType")
                            );
                        }
                        tsParseTypeOperatorOrHigher() {
                            const t = ["keyof", "unique", "readonly"].find(
                                (t) => this.isContextual(t)
                            );
                            return t
                                ? this.tsParseTypeOperator(t)
                                : this.isContextual("infer")
                                ? this.tsParseInferType()
                                : this.tsParseArrayTypeOrHigher();
                        }
                        tsParseUnionOrIntersectionType(t, e, n) {
                            this.eat(n);
                            let r = e();
                            if (this.match(n)) {
                                const s = [r];
                                for (; this.eat(n); ) s.push(e());
                                const i = this.startNodeAtNode(r);
                                (i.types = s), (r = this.finishNode(i, t));
                            }
                            return r;
                        }
                        tsParseIntersectionTypeOrHigher() {
                            return this.tsParseUnionOrIntersectionType(
                                "TSIntersectionType",
                                this.tsParseTypeOperatorOrHigher.bind(this),
                                h.bitwiseAND
                            );
                        }
                        tsParseUnionTypeOrHigher() {
                            return this.tsParseUnionOrIntersectionType(
                                "TSUnionType",
                                this.tsParseIntersectionTypeOrHigher.bind(this),
                                h.bitwiseOR
                            );
                        }
                        tsIsStartOfFunctionType() {
                            return (
                                !!this.isRelational("<") ||
                                (this.match(h.parenL) &&
                                    this.tsLookAhead(
                                        this.tsIsUnambiguouslyStartOfFunctionType.bind(
                                            this
                                        )
                                    ))
                            );
                        }
                        tsSkipParameterStart() {
                            if (this.match(h.name) || this.match(h._this))
                                return this.next(), !0;
                            if (this.match(h.braceL)) {
                                let t = 1;
                                for (this.next(); t > 0; )
                                    this.match(h.braceL)
                                        ? ++t
                                        : this.match(h.braceR) && --t,
                                        this.next();
                                return !0;
                            }
                            if (this.match(h.bracketL)) {
                                let t = 1;
                                for (this.next(); t > 0; )
                                    this.match(h.bracketL)
                                        ? ++t
                                        : this.match(h.bracketR) && --t,
                                        this.next();
                                return !0;
                            }
                            return !1;
                        }
                        tsIsUnambiguouslyStartOfFunctionType() {
                            if (
                                (this.next(),
                                this.match(h.parenR) || this.match(h.ellipsis))
                            )
                                return !0;
                            if (this.tsSkipParameterStart()) {
                                if (
                                    this.match(h.colon) ||
                                    this.match(h.comma) ||
                                    this.match(h.question) ||
                                    this.match(h.eq)
                                )
                                    return !0;
                                if (
                                    this.match(h.parenR) &&
                                    (this.next(), this.match(h.arrow))
                                )
                                    return !0;
                            }
                            return !1;
                        }
                        tsParseTypeOrTypePredicateAnnotation(t) {
                            return this.tsInType(() => {
                                const e = this.startNode();
                                this.expect(t);
                                const n = this.tsTryParse(
                                    this.tsParseTypePredicateAsserts.bind(this)
                                );
                                if (n && this.match(h._this)) {
                                    let t =
                                        this.tsParseThisTypeOrThisTypePredicate();
                                    if ("TSThisType" === t.type) {
                                        const n = this.startNodeAtNode(e);
                                        (n.parameterName = t),
                                            (n.asserts = !0),
                                            (t = this.finishNode(
                                                n,
                                                "TSTypePredicate"
                                            ));
                                    } else t.asserts = !0;
                                    return (
                                        (e.typeAnnotation = t),
                                        this.finishNode(e, "TSTypeAnnotation")
                                    );
                                }
                                const r =
                                    this.tsIsIdentifier() &&
                                    this.tsTryParse(
                                        this.tsParseTypePredicatePrefix.bind(
                                            this
                                        )
                                    );
                                if (!r) {
                                    if (!n)
                                        return this.tsParseTypeAnnotation(
                                            !1,
                                            e
                                        );
                                    const t = this.startNodeAtNode(e);
                                    return (
                                        (t.parameterName =
                                            this.parseIdentifier()),
                                        (t.asserts = n),
                                        (e.typeAnnotation = this.finishNode(
                                            t,
                                            "TSTypePredicate"
                                        )),
                                        this.finishNode(e, "TSTypeAnnotation")
                                    );
                                }
                                const s = this.tsParseTypeAnnotation(!1),
                                    i = this.startNodeAtNode(e);
                                return (
                                    (i.parameterName = r),
                                    (i.typeAnnotation = s),
                                    (i.asserts = n),
                                    (e.typeAnnotation = this.finishNode(
                                        i,
                                        "TSTypePredicate"
                                    )),
                                    this.finishNode(e, "TSTypeAnnotation")
                                );
                            });
                        }
                        tsTryParseTypeOrTypePredicateAnnotation() {
                            return this.match(h.colon)
                                ? this.tsParseTypeOrTypePredicateAnnotation(
                                      h.colon
                                  )
                                : void 0;
                        }
                        tsTryParseTypeAnnotation() {
                            return this.match(h.colon)
                                ? this.tsParseTypeAnnotation()
                                : void 0;
                        }
                        tsTryParseType() {
                            return this.tsEatThenParseType(h.colon);
                        }
                        tsParseTypePredicatePrefix() {
                            const t = this.parseIdentifier();
                            if (
                                this.isContextual("is") &&
                                !this.hasPrecedingLineBreak()
                            )
                                return this.next(), t;
                        }
                        tsParseTypePredicateAsserts() {
                            if (
                                !this.match(h.name) ||
                                "asserts" !== this.state.value ||
                                this.hasPrecedingLineBreak()
                            )
                                return !1;
                            const t = this.state.containsEsc;
                            return (
                                this.next(),
                                !(
                                    !this.match(h.name) && !this.match(h._this)
                                ) &&
                                    (t &&
                                        this.raise(
                                            this.state.lastTokStart,
                                            E.InvalidEscapedReservedWord,
                                            "asserts"
                                        ),
                                    !0)
                            );
                        }
                        tsParseTypeAnnotation(t = !0, e = this.startNode()) {
                            return (
                                this.tsInType(() => {
                                    t && this.expect(h.colon),
                                        (e.typeAnnotation = this.tsParseType());
                                }),
                                this.finishNode(e, "TSTypeAnnotation")
                            );
                        }
                        tsParseType() {
                            pt(this.state.inType);
                            const t = this.tsParseNonConditionalType();
                            if (
                                this.hasPrecedingLineBreak() ||
                                !this.eat(h._extends)
                            )
                                return t;
                            const e = this.startNodeAtNode(t);
                            return (
                                (e.checkType = t),
                                (e.extendsType =
                                    this.tsParseNonConditionalType()),
                                this.expect(h.question),
                                (e.trueType = this.tsParseType()),
                                this.expect(h.colon),
                                (e.falseType = this.tsParseType()),
                                this.finishNode(e, "TSConditionalType")
                            );
                        }
                        tsParseNonConditionalType() {
                            return this.tsIsStartOfFunctionType()
                                ? this.tsParseFunctionOrConstructorType(
                                      "TSFunctionType"
                                  )
                                : this.match(h._new)
                                ? this.tsParseFunctionOrConstructorType(
                                      "TSConstructorType"
                                  )
                                : this.tsParseUnionTypeOrHigher();
                        }
                        tsParseTypeAssertion() {
                            const t = this.startNode(),
                                e = this.tsTryNextParseConstantContext();
                            return (
                                (t.typeAnnotation =
                                    e || this.tsNextThenParseType()),
                                this.expectRelational(">"),
                                (t.expression = this.parseMaybeUnary()),
                                this.finishNode(t, "TSTypeAssertion")
                            );
                        }
                        tsParseHeritageClause(t) {
                            const e = this.state.start,
                                n = this.tsParseDelimitedList(
                                    "HeritageClauseElement",
                                    this.tsParseExpressionWithTypeArguments.bind(
                                        this
                                    )
                                );
                            return (
                                n.length ||
                                    this.raise(
                                        e,
                                        dt.EmptyHeritageClauseType,
                                        t
                                    ),
                                n
                            );
                        }
                        tsParseExpressionWithTypeArguments() {
                            const t = this.startNode();
                            return (
                                (t.expression = this.tsParseEntityName(!1)),
                                this.isRelational("<") &&
                                    (t.typeParameters =
                                        this.tsParseTypeArguments()),
                                this.finishNode(
                                    t,
                                    "TSExpressionWithTypeArguments"
                                )
                            );
                        }
                        tsParseInterfaceDeclaration(t) {
                            (t.id = this.parseIdentifier()),
                                this.checkLVal(
                                    t.id,
                                    130,
                                    void 0,
                                    "typescript interface declaration"
                                ),
                                (t.typeParameters =
                                    this.tsTryParseTypeParameters()),
                                this.eat(h._extends) &&
                                    (t.extends =
                                        this.tsParseHeritageClause("extends"));
                            const e = this.startNode();
                            return (
                                (e.body = this.tsInType(
                                    this.tsParseObjectTypeMembers.bind(this)
                                )),
                                (t.body = this.finishNode(
                                    e,
                                    "TSInterfaceBody"
                                )),
                                this.finishNode(t, "TSInterfaceDeclaration")
                            );
                        }
                        tsParseTypeAliasDeclaration(t) {
                            return (
                                (t.id = this.parseIdentifier()),
                                this.checkLVal(
                                    t.id,
                                    2,
                                    void 0,
                                    "typescript type alias"
                                ),
                                (t.typeParameters =
                                    this.tsTryParseTypeParameters()),
                                (t.typeAnnotation = this.tsExpectThenParseType(
                                    h.eq
                                )),
                                this.semicolon(),
                                this.finishNode(t, "TSTypeAliasDeclaration")
                            );
                        }
                        tsInNoContext(t) {
                            const e = this.state.context;
                            this.state.context = [e[0]];
                            try {
                                return t();
                            } finally {
                                this.state.context = e;
                            }
                        }
                        tsInType(t) {
                            const e = this.state.inType;
                            this.state.inType = !0;
                            try {
                                return t();
                            } finally {
                                this.state.inType = e;
                            }
                        }
                        tsEatThenParseType(t) {
                            return this.match(t)
                                ? this.tsNextThenParseType()
                                : void 0;
                        }
                        tsExpectThenParseType(t) {
                            return this.tsDoThenParseType(() => this.expect(t));
                        }
                        tsNextThenParseType() {
                            return this.tsDoThenParseType(() => this.next());
                        }
                        tsDoThenParseType(t) {
                            return this.tsInType(
                                () => (t(), this.tsParseType())
                            );
                        }
                        tsParseEnumMember() {
                            const t = this.startNode();
                            return (
                                (t.id = this.match(h.string)
                                    ? this.parseExprAtom()
                                    : this.parseIdentifier(!0)),
                                this.eat(h.eq) &&
                                    (t.initializer =
                                        this.parseMaybeAssignAllowIn()),
                                this.finishNode(t, "TSEnumMember")
                            );
                        }
                        tsParseEnumDeclaration(t, e) {
                            return (
                                e && (t.const = !0),
                                (t.id = this.parseIdentifier()),
                                this.checkLVal(
                                    t.id,
                                    e ? 779 : 267,
                                    void 0,
                                    "typescript enum declaration"
                                ),
                                this.expect(h.braceL),
                                (t.members = this.tsParseDelimitedList(
                                    "EnumMembers",
                                    this.tsParseEnumMember.bind(this)
                                )),
                                this.expect(h.braceR),
                                this.finishNode(t, "TSEnumDeclaration")
                            );
                        }
                        tsParseModuleBlock() {
                            const t = this.startNode();
                            return (
                                this.scope.enter(0),
                                this.expect(h.braceL),
                                this.parseBlockOrModuleBlockBody(
                                    (t.body = []),
                                    void 0,
                                    !0,
                                    h.braceR
                                ),
                                this.scope.exit(),
                                this.finishNode(t, "TSModuleBlock")
                            );
                        }
                        tsParseModuleOrNamespaceDeclaration(t, e = !1) {
                            if (
                                ((t.id = this.parseIdentifier()),
                                e ||
                                    this.checkLVal(
                                        t.id,
                                        1024,
                                        null,
                                        "module or namespace declaration"
                                    ),
                                this.eat(h.dot))
                            ) {
                                const e = this.startNode();
                                this.tsParseModuleOrNamespaceDeclaration(e, !0),
                                    (t.body = e);
                            } else
                                this.scope.enter(p),
                                    this.prodParam.enter(0),
                                    (t.body = this.tsParseModuleBlock()),
                                    this.prodParam.exit(),
                                    this.scope.exit();
                            return this.finishNode(t, "TSModuleDeclaration");
                        }
                        tsParseAmbientExternalModuleDeclaration(t) {
                            return (
                                this.isContextual("global")
                                    ? ((t.global = !0),
                                      (t.id = this.parseIdentifier()))
                                    : this.match(h.string)
                                    ? (t.id = this.parseExprAtom())
                                    : this.unexpected(),
                                this.match(h.braceL)
                                    ? (this.scope.enter(p),
                                      this.prodParam.enter(0),
                                      (t.body = this.tsParseModuleBlock()),
                                      this.prodParam.exit(),
                                      this.scope.exit())
                                    : this.semicolon(),
                                this.finishNode(t, "TSModuleDeclaration")
                            );
                        }
                        tsParseImportEqualsDeclaration(t, e) {
                            return (
                                (t.isExport = e || !1),
                                (t.id = this.parseIdentifier()),
                                this.checkLVal(
                                    t.id,
                                    9,
                                    void 0,
                                    "import equals declaration"
                                ),
                                this.expect(h.eq),
                                (t.moduleReference =
                                    this.tsParseModuleReference()),
                                this.semicolon(),
                                this.finishNode(t, "TSImportEqualsDeclaration")
                            );
                        }
                        tsIsExternalModuleReference() {
                            return (
                                this.isContextual("require") &&
                                40 === this.lookaheadCharCode()
                            );
                        }
                        tsParseModuleReference() {
                            return this.tsIsExternalModuleReference()
                                ? this.tsParseExternalModuleReference()
                                : this.tsParseEntityName(!1);
                        }
                        tsParseExternalModuleReference() {
                            const t = this.startNode();
                            if (
                                (this.expectContextual("require"),
                                this.expect(h.parenL),
                                !this.match(h.string))
                            )
                                throw this.unexpected();
                            return (
                                (t.expression = this.parseExprAtom()),
                                this.expect(h.parenR),
                                this.finishNode(t, "TSExternalModuleReference")
                            );
                        }
                        tsLookAhead(t) {
                            const e = this.state.clone(),
                                n = t();
                            return (this.state = e), n;
                        }
                        tsTryParseAndCatch(t) {
                            const e = this.tryParse((e) => t() || e());
                            if (!e.aborted && e.node)
                                return (
                                    e.error && (this.state = e.failState),
                                    e.node
                                );
                        }
                        tsTryParse(t) {
                            const e = this.state.clone(),
                                n = t();
                            return void 0 !== n && !1 !== n
                                ? n
                                : void (this.state = e);
                        }
                        tsTryParseDeclare(t) {
                            if (this.isLineTerminator()) return;
                            let e,
                                n = this.state.type;
                            switch (
                                (this.isContextual("let") &&
                                    ((n = h._var), (e = "let")),
                                n)
                            ) {
                                case h._function:
                                    return this.parseFunctionStatement(
                                        t,
                                        !1,
                                        !0
                                    );
                                case h._class:
                                    return (
                                        (t.declare = !0),
                                        this.parseClass(t, !0, !1)
                                    );
                                case h._const:
                                    if (
                                        this.match(h._const) &&
                                        this.isLookaheadContextual("enum")
                                    )
                                        return (
                                            this.expect(h._const),
                                            this.expectContextual("enum"),
                                            this.tsParseEnumDeclaration(t, !0)
                                        );
                                case h._var:
                                    return (
                                        (e = e || this.state.value),
                                        this.parseVarStatement(t, e)
                                    );
                                case h.name: {
                                    const e = this.state.value;
                                    return "global" === e
                                        ? this.tsParseAmbientExternalModuleDeclaration(
                                              t
                                          )
                                        : this.tsParseDeclaration(t, e, !0);
                                }
                            }
                        }
                        tsTryParseExportDeclaration() {
                            return this.tsParseDeclaration(
                                this.startNode(),
                                this.state.value,
                                !0
                            );
                        }
                        tsParseExpressionStatement(t, e) {
                            switch (e.name) {
                                case "declare": {
                                    const e = this.tsTryParseDeclare(t);
                                    if (e) return (e.declare = !0), e;
                                    break;
                                }
                                case "global":
                                    if (this.match(h.braceL)) {
                                        this.scope.enter(p),
                                            this.prodParam.enter(0);
                                        const n = t;
                                        return (
                                            (n.global = !0),
                                            (n.id = e),
                                            (n.body =
                                                this.tsParseModuleBlock()),
                                            this.scope.exit(),
                                            this.prodParam.exit(),
                                            this.finishNode(
                                                n,
                                                "TSModuleDeclaration"
                                            )
                                        );
                                    }
                                    break;
                                default:
                                    return this.tsParseDeclaration(
                                        t,
                                        e.name,
                                        !1
                                    );
                            }
                        }
                        tsParseDeclaration(t, e, n) {
                            switch (e) {
                                case "abstract":
                                    if (
                                        this.tsCheckLineTerminatorAndMatch(
                                            h._class,
                                            n
                                        )
                                    ) {
                                        const e = t;
                                        return (
                                            (e.abstract = !0),
                                            n &&
                                                (this.next(),
                                                this.match(h._class) ||
                                                    this.unexpected(
                                                        null,
                                                        h._class
                                                    )),
                                            this.parseClass(e, !0, !1)
                                        );
                                    }
                                    break;
                                case "enum":
                                    if (n || this.match(h.name))
                                        return (
                                            n && this.next(),
                                            this.tsParseEnumDeclaration(t, !1)
                                        );
                                    break;
                                case "interface":
                                    if (
                                        this.tsCheckLineTerminatorAndMatch(
                                            h.name,
                                            n
                                        )
                                    )
                                        return (
                                            n && this.next(),
                                            this.tsParseInterfaceDeclaration(t)
                                        );
                                    break;
                                case "module":
                                    if (
                                        (n && this.next(), this.match(h.string))
                                    )
                                        return this.tsParseAmbientExternalModuleDeclaration(
                                            t
                                        );
                                    if (
                                        this.tsCheckLineTerminatorAndMatch(
                                            h.name,
                                            n
                                        )
                                    )
                                        return this.tsParseModuleOrNamespaceDeclaration(
                                            t
                                        );
                                    break;
                                case "namespace":
                                    if (
                                        this.tsCheckLineTerminatorAndMatch(
                                            h.name,
                                            n
                                        )
                                    )
                                        return (
                                            n && this.next(),
                                            this.tsParseModuleOrNamespaceDeclaration(
                                                t
                                            )
                                        );
                                    break;
                                case "type":
                                    if (
                                        this.tsCheckLineTerminatorAndMatch(
                                            h.name,
                                            n
                                        )
                                    )
                                        return (
                                            n && this.next(),
                                            this.tsParseTypeAliasDeclaration(t)
                                        );
                            }
                        }
                        tsCheckLineTerminatorAndMatch(t, e) {
                            return (
                                (e || this.match(t)) && !this.isLineTerminator()
                            );
                        }
                        tsTryParseGenericAsyncArrowFunction(t, e) {
                            if (!this.isRelational("<")) return;
                            const n = this.state.maybeInArrowParameters,
                                r = this.state.yieldPos,
                                s = this.state.awaitPos;
                            (this.state.maybeInArrowParameters = !0),
                                (this.state.yieldPos = -1),
                                (this.state.awaitPos = -1);
                            const i = this.tsTryParseAndCatch(() => {
                                const n = this.startNodeAt(t, e);
                                return (
                                    (n.typeParameters =
                                        this.tsParseTypeParameters()),
                                    super.parseFunctionParams(n),
                                    (n.returnType =
                                        this.tsTryParseTypeOrTypePredicateAnnotation()),
                                    this.expect(h.arrow),
                                    n
                                );
                            });
                            return (
                                (this.state.maybeInArrowParameters = n),
                                (this.state.yieldPos = r),
                                (this.state.awaitPos = s),
                                i
                                    ? this.parseArrowExpression(i, null, !0)
                                    : void 0
                            );
                        }
                        tsParseTypeArguments() {
                            const t = this.startNode();
                            return (
                                (t.params = this.tsInType(() =>
                                    this.tsInNoContext(
                                        () => (
                                            this.expectRelational("<"),
                                            this.tsParseDelimitedList(
                                                "TypeParametersOrArguments",
                                                this.tsParseType.bind(this)
                                            )
                                        )
                                    )
                                )),
                                (this.state.exprAllowed = !1),
                                this.expectRelational(">"),
                                this.finishNode(
                                    t,
                                    "TSTypeParameterInstantiation"
                                )
                            );
                        }
                        tsIsDeclarationStart() {
                            if (this.match(h.name))
                                switch (this.state.value) {
                                    case "abstract":
                                    case "declare":
                                    case "enum":
                                    case "interface":
                                    case "module":
                                    case "namespace":
                                    case "type":
                                        return !0;
                                }
                            return !1;
                        }
                        isExportDefaultSpecifier() {
                            return (
                                !this.tsIsDeclarationStart() &&
                                super.isExportDefaultSpecifier()
                            );
                        }
                        parseAssignableListItem(t, e) {
                            const n = this.state.start,
                                r = this.state.startLoc;
                            let s,
                                i = !1;
                            t &&
                                ((s = this.parseAccessModifier()),
                                (i = !!this.tsParseModifier(["readonly"])));
                            const o = this.parseMaybeDefault();
                            this.parseAssignableListItemTypes(o);
                            const a = this.parseMaybeDefault(
                                o.start,
                                o.loc.start,
                                o
                            );
                            if (s || i) {
                                const t = this.startNodeAt(n, r);
                                return (
                                    e.length && (t.decorators = e),
                                    s && (t.accessibility = s),
                                    i && (t.readonly = i),
                                    "Identifier" !== a.type &&
                                        "AssignmentPattern" !== a.type &&
                                        this.raise(
                                            t.start,
                                            dt.UnsupportedParameterPropertyKind
                                        ),
                                    (t.parameter = a),
                                    this.finishNode(t, "TSParameterProperty")
                                );
                            }
                            return e.length && (o.decorators = e), a;
                        }
                        parseFunctionBodyAndFinish(t, e, n = !1) {
                            this.match(h.colon) &&
                                (t.returnType =
                                    this.tsParseTypeOrTypePredicateAnnotation(
                                        h.colon
                                    ));
                            const r =
                                "FunctionDeclaration" === e
                                    ? "TSDeclareFunction"
                                    : "ClassMethod" === e
                                    ? "TSDeclareMethod"
                                    : void 0;
                            r &&
                            !this.match(h.braceL) &&
                            this.isLineTerminator()
                                ? this.finishNode(t, r)
                                : super.parseFunctionBodyAndFinish(t, e, n);
                        }
                        registerFunctionStatementId(t) {
                            !t.body && t.id
                                ? this.checkLVal(
                                      t.id,
                                      1024,
                                      null,
                                      "function name"
                                  )
                                : super.registerFunctionStatementId(
                                      ...arguments
                                  );
                        }
                        parseSubscript(t, e, n, r, s) {
                            if (
                                !this.hasPrecedingLineBreak() &&
                                this.match(h.bang)
                            ) {
                                (this.state.exprAllowed = !1), this.next();
                                const r = this.startNodeAt(e, n);
                                return (
                                    (r.expression = t),
                                    this.finishNode(r, "TSNonNullExpression")
                                );
                            }
                            if (this.isRelational("<")) {
                                const i = this.tsTryParseAndCatch(() => {
                                    if (!r && this.atPossibleAsyncArrow(t)) {
                                        const t =
                                            this.tsTryParseGenericAsyncArrowFunction(
                                                e,
                                                n
                                            );
                                        if (t) return t;
                                    }
                                    const i = this.startNodeAt(e, n);
                                    i.callee = t;
                                    const o = this.tsParseTypeArguments();
                                    if (o) {
                                        if (!r && this.eat(h.parenL))
                                            return (
                                                (i.arguments =
                                                    this.parseCallExpressionArguments(
                                                        h.parenR,
                                                        !1
                                                    )),
                                                (i.typeParameters = o),
                                                this.finishCallExpression(
                                                    i,
                                                    s.optionalChainMember
                                                )
                                            );
                                        if (this.match(h.backQuote)) {
                                            const r =
                                                this.parseTaggedTemplateExpression(
                                                    t,
                                                    e,
                                                    n,
                                                    s
                                                );
                                            return (r.typeParameters = o), r;
                                        }
                                    }
                                    this.unexpected();
                                });
                                if (i) return i;
                            }
                            return super.parseSubscript(t, e, n, r, s);
                        }
                        parseNewArguments(t) {
                            if (this.isRelational("<")) {
                                const e = this.tsTryParseAndCatch(() => {
                                    const t = this.tsParseTypeArguments();
                                    return (
                                        this.match(h.parenL) ||
                                            this.unexpected(),
                                        t
                                    );
                                });
                                e && (t.typeParameters = e);
                            }
                            super.parseNewArguments(t);
                        }
                        parseExprOp(t, e, n, r) {
                            if (
                                ht(h._in.binop) > r &&
                                !this.hasPrecedingLineBreak() &&
                                this.isContextual("as")
                            ) {
                                const s = this.startNodeAt(e, n);
                                s.expression = t;
                                const i = this.tsTryNextParseConstantContext();
                                return (
                                    (s.typeAnnotation =
                                        i || this.tsNextThenParseType()),
                                    this.finishNode(s, "TSAsExpression"),
                                    this.reScan_lt_gt(),
                                    this.parseExprOp(s, e, n, r)
                                );
                            }
                            return super.parseExprOp(t, e, n, r);
                        }
                        checkReservedWord(t, e, n, r) {}
                        checkDuplicateExports() {}
                        parseImport(t) {
                            if (
                                this.match(h.name) ||
                                this.match(h.star) ||
                                this.match(h.braceL)
                            ) {
                                const e = this.lookahead();
                                if (this.match(h.name) && e.type === h.eq)
                                    return this.tsParseImportEqualsDeclaration(
                                        t
                                    );
                                !this.isContextual("type") ||
                                e.type === h.comma ||
                                (e.type === h.name && "from" === e.value)
                                    ? (t.importKind = "value")
                                    : ((t.importKind = "type"), this.next());
                            }
                            const e = super.parseImport(t);
                            return (
                                "type" === e.importKind &&
                                    e.specifiers.length > 1 &&
                                    "ImportDefaultSpecifier" ===
                                        e.specifiers[0].type &&
                                    this.raise(
                                        e.start,
                                        "A type-only import can specify a default import or named bindings, but not both."
                                    ),
                                e
                            );
                        }
                        parseExport(t) {
                            if (this.match(h._import))
                                return (
                                    this.expect(h._import),
                                    this.tsParseImportEqualsDeclaration(t, !0)
                                );
                            if (this.eat(h.eq)) {
                                const e = t;
                                return (
                                    (e.expression = this.parseExpression()),
                                    this.semicolon(),
                                    this.finishNode(e, "TSExportAssignment")
                                );
                            }
                            if (this.eatContextual("as")) {
                                const e = t;
                                return (
                                    this.expectContextual("namespace"),
                                    (e.id = this.parseIdentifier()),
                                    this.semicolon(),
                                    this.finishNode(
                                        e,
                                        "TSNamespaceExportDeclaration"
                                    )
                                );
                            }
                            return (
                                this.isContextual("type") &&
                                this.lookahead().type === h.braceL
                                    ? (this.next(), (t.exportKind = "type"))
                                    : (t.exportKind = "value"),
                                super.parseExport(t)
                            );
                        }
                        isAbstractClass() {
                            return (
                                this.isContextual("abstract") &&
                                this.lookahead().type === h._class
                            );
                        }
                        parseExportDefaultExpression() {
                            if (this.isAbstractClass()) {
                                const t = this.startNode();
                                return (
                                    this.next(),
                                    this.parseClass(t, !0, !0),
                                    (t.abstract = !0),
                                    t
                                );
                            }
                            if ("interface" === this.state.value) {
                                const t = this.tsParseDeclaration(
                                    this.startNode(),
                                    this.state.value,
                                    !0
                                );
                                if (t) return t;
                            }
                            return super.parseExportDefaultExpression();
                        }
                        parseStatementContent(t, e) {
                            if (this.state.type === h._const) {
                                const t = this.lookahead();
                                if (t.type === h.name && "enum" === t.value) {
                                    const t = this.startNode();
                                    return (
                                        this.expect(h._const),
                                        this.expectContextual("enum"),
                                        this.tsParseEnumDeclaration(t, !0)
                                    );
                                }
                            }
                            return super.parseStatementContent(t, e);
                        }
                        parseAccessModifier() {
                            return this.tsParseModifier([
                                "public",
                                "protected",
                                "private",
                            ]);
                        }
                        parseClassMember(t, e, n, r) {
                            this.tsParseModifiers(e, ["declare"]);
                            const s = this.parseAccessModifier();
                            s && (e.accessibility = s),
                                this.tsParseModifiers(e, ["declare"]),
                                super.parseClassMember(t, e, n, r);
                        }
                        parseClassMemberWithIsStatic(t, e, n, r, s) {
                            this.tsParseModifiers(e, [
                                "abstract",
                                "readonly",
                                "declare",
                            ]);
                            const i = this.tsTryParseIndexSignature(e);
                            if (i)
                                return (
                                    t.body.push(i),
                                    e.abstract &&
                                        this.raise(
                                            e.start,
                                            dt.IndexSignatureHasAbstract
                                        ),
                                    r &&
                                        this.raise(
                                            e.start,
                                            dt.IndexSignatureHasStatic
                                        ),
                                    void (
                                        e.accessibility &&
                                        this.raise(
                                            e.start,
                                            dt.IndexSignatureHasAccessibility,
                                            e.accessibility
                                        )
                                    )
                                );
                            super.parseClassMemberWithIsStatic(t, e, n, r, s);
                        }
                        parsePostMemberNameModifiers(t) {
                            this.eat(h.question) && (t.optional = !0),
                                t.readonly &&
                                    this.match(h.parenL) &&
                                    this.raise(
                                        t.start,
                                        dt.ClassMethodHasReadonly
                                    ),
                                t.declare &&
                                    this.match(h.parenL) &&
                                    this.raise(
                                        t.start,
                                        dt.ClassMethodHasDeclare
                                    );
                        }
                        parseExpressionStatement(t, e) {
                            return (
                                ("Identifier" === e.type
                                    ? this.tsParseExpressionStatement(t, e)
                                    : void 0) ||
                                super.parseExpressionStatement(t, e)
                            );
                        }
                        shouldParseExportDeclaration() {
                            return (
                                !!this.tsIsDeclarationStart() ||
                                super.shouldParseExportDeclaration()
                            );
                        }
                        parseConditional(t, e, n, r) {
                            if (!r || !this.match(h.question))
                                return super.parseConditional(t, e, n, r);
                            const s = this.tryParse(() =>
                                super.parseConditional(t, e, n)
                            );
                            return s.node
                                ? (s.error && (this.state = s.failState),
                                  s.node)
                                : ((r.start = s.error.pos || this.state.start),
                                  t);
                        }
                        parseParenItem(t, e, n) {
                            if (
                                ((t = super.parseParenItem(t, e, n)),
                                this.eat(h.question) &&
                                    ((t.optional = !0),
                                    this.resetEndLocation(t)),
                                this.match(h.colon))
                            ) {
                                const r = this.startNodeAt(e, n);
                                return (
                                    (r.expression = t),
                                    (r.typeAnnotation =
                                        this.tsParseTypeAnnotation()),
                                    this.finishNode(r, "TSTypeCastExpression")
                                );
                            }
                            return t;
                        }
                        parseExportDeclaration(t) {
                            const e = this.state.start,
                                n = this.state.startLoc,
                                r = this.eatContextual("declare");
                            let s;
                            return (
                                this.match(h.name) &&
                                    (s = this.tsTryParseExportDeclaration()),
                                s || (s = super.parseExportDeclaration(t)),
                                s &&
                                    ("TSInterfaceDeclaration" === s.type ||
                                        "TSTypeAliasDeclaration" === s.type ||
                                        r) &&
                                    (t.exportKind = "type"),
                                s &&
                                    r &&
                                    (this.resetStartLocation(s, e, n),
                                    (s.declare = !0)),
                                s
                            );
                        }
                        parseClassId(t, e, n) {
                            if ((!e || n) && this.isContextual("implements"))
                                return;
                            super.parseClassId(t, e, n, t.declare ? 1024 : 139);
                            const r = this.tsTryParseTypeParameters();
                            r && (t.typeParameters = r);
                        }
                        parseClassPropertyAnnotation(t) {
                            !t.optional &&
                                this.eat(h.bang) &&
                                (t.definite = !0);
                            const e = this.tsTryParseTypeAnnotation();
                            e && (t.typeAnnotation = e);
                        }
                        parseClassProperty(t) {
                            return (
                                this.parseClassPropertyAnnotation(t),
                                t.declare &&
                                    this.match(h.equal) &&
                                    this.raise(
                                        this.state.start,
                                        dt.DeclareClassFieldHasInitializer
                                    ),
                                super.parseClassProperty(t)
                            );
                        }
                        parseClassPrivateProperty(t) {
                            return (
                                t.abstract &&
                                    this.raise(
                                        t.start,
                                        dt.PrivateElementHasAbstract
                                    ),
                                t.accessibility &&
                                    this.raise(
                                        t.start,
                                        dt.PrivateElementHasAccessibility,
                                        t.accessibility
                                    ),
                                this.parseClassPropertyAnnotation(t),
                                super.parseClassPrivateProperty(t)
                            );
                        }
                        pushClassMethod(t, e, n, r, s, i) {
                            const o = this.tsTryParseTypeParameters();
                            o && (e.typeParameters = o),
                                super.pushClassMethod(t, e, n, r, s, i);
                        }
                        pushClassPrivateMethod(t, e, n, r) {
                            const s = this.tsTryParseTypeParameters();
                            s && (e.typeParameters = s),
                                super.pushClassPrivateMethod(t, e, n, r);
                        }
                        parseClassSuper(t) {
                            super.parseClassSuper(t),
                                t.superClass &&
                                    this.isRelational("<") &&
                                    (t.superTypeParameters =
                                        this.tsParseTypeArguments()),
                                this.eatContextual("implements") &&
                                    (t.implements =
                                        this.tsParseHeritageClause(
                                            "implements"
                                        ));
                        }
                        parseObjPropValue(t, ...e) {
                            const n = this.tsTryParseTypeParameters();
                            n && (t.typeParameters = n),
                                super.parseObjPropValue(t, ...e);
                        }
                        parseFunctionParams(t, e) {
                            const n = this.tsTryParseTypeParameters();
                            n && (t.typeParameters = n),
                                super.parseFunctionParams(t, e);
                        }
                        parseVarId(t, e) {
                            super.parseVarId(t, e),
                                "Identifier" === t.id.type &&
                                    this.eat(h.bang) &&
                                    (t.definite = !0);
                            const n = this.tsTryParseTypeAnnotation();
                            n &&
                                ((t.id.typeAnnotation = n),
                                this.resetEndLocation(t.id));
                        }
                        parseAsyncArrowFromCallExpression(t, e) {
                            return (
                                this.match(h.colon) &&
                                    (t.returnType =
                                        this.tsParseTypeAnnotation()),
                                super.parseAsyncArrowFromCallExpression(t, e)
                            );
                        }
                        parseMaybeAssign(...t) {
                            var e, n, r, s, i, o, a;
                            let c, l, u, p;
                            if (this.match(h.jsxTagStart)) {
                                if (
                                    ((c = this.state.clone()),
                                    (l = this.tryParse(
                                        () => super.parseMaybeAssign(...t),
                                        c
                                    )),
                                    !l.error)
                                )
                                    return l.node;
                                const { context: e } = this.state;
                                e[e.length - 1] === C.j_oTag
                                    ? (e.length -= 2)
                                    : e[e.length - 1] === C.j_expr &&
                                      (e.length -= 1);
                            }
                            if (
                                !(null == (e = l) ? void 0 : e.error) &&
                                !this.isRelational("<")
                            )
                                return super.parseMaybeAssign(...t);
                            c = c || this.state.clone();
                            const d = this.tryParse((e) => {
                                var n;
                                p = this.tsParseTypeParameters();
                                const r = super.parseMaybeAssign(...t);
                                return (
                                    ("ArrowFunctionExpression" !== r.type ||
                                        (r.extra && r.extra.parenthesized)) &&
                                        e(),
                                    0 !==
                                        (null == (n = p)
                                            ? void 0
                                            : n.params.length) &&
                                        this.resetStartLocationFromNode(r, p),
                                    (r.typeParameters = p),
                                    r
                                );
                            }, c);
                            if (!d.error && !d.aborted) return d.node;
                            if (
                                !l &&
                                (pt(!this.hasPlugin("jsx")),
                                (u = this.tryParse(
                                    () => super.parseMaybeAssign(...t),
                                    c
                                )),
                                !u.error)
                            )
                                return u.node;
                            if (null == (n = l) ? void 0 : n.node)
                                return (this.state = l.failState), l.node;
                            if (d.node)
                                return (this.state = d.failState), d.node;
                            if (null == (r = u) ? void 0 : r.node)
                                return (this.state = u.failState), u.node;
                            if (null == (s = l) ? void 0 : s.thrown)
                                throw l.error;
                            if (d.thrown) throw d.error;
                            if (null == (i = u) ? void 0 : i.thrown)
                                throw u.error;
                            throw (
                                (null == (o = l) ? void 0 : o.error) ||
                                d.error ||
                                (null == (a = u) ? void 0 : a.error)
                            );
                        }
                        parseMaybeUnary(t) {
                            return !this.hasPlugin("jsx") &&
                                this.isRelational("<")
                                ? this.tsParseTypeAssertion()
                                : super.parseMaybeUnary(t);
                        }
                        parseArrow(t) {
                            if (this.match(h.colon)) {
                                const e = this.tryParse((t) => {
                                    const e =
                                        this.tsParseTypeOrTypePredicateAnnotation(
                                            h.colon
                                        );
                                    return (
                                        (!this.canInsertSemicolon() &&
                                            this.match(h.arrow)) ||
                                            t(),
                                        e
                                    );
                                });
                                if (e.aborted) return;
                                e.thrown ||
                                    (e.error && (this.state = e.failState),
                                    (t.returnType = e.node));
                            }
                            return super.parseArrow(t);
                        }
                        parseAssignableListItemTypes(t) {
                            this.eat(h.question) &&
                                ("Identifier" !== t.type &&
                                    this.raise(t.start, dt.PatternIsOptional),
                                (t.optional = !0));
                            const e = this.tsTryParseTypeAnnotation();
                            return (
                                e && (t.typeAnnotation = e),
                                this.resetEndLocation(t),
                                t
                            );
                        }
                        toAssignable(t) {
                            switch (t.type) {
                                case "TSTypeCastExpression":
                                    return super.toAssignable(
                                        this.typeCastToParameter(t)
                                    );
                                case "TSParameterProperty":
                                    return super.toAssignable(t);
                                case "TSAsExpression":
                                case "TSNonNullExpression":
                                case "TSTypeAssertion":
                                    return (
                                        (t.expression = this.toAssignable(
                                            t.expression
                                        )),
                                        t
                                    );
                                default:
                                    return super.toAssignable(t);
                            }
                        }
                        checkLVal(t, e = 64, n, r) {
                            switch (t.type) {
                                case "TSTypeCastExpression":
                                    return;
                                case "TSParameterProperty":
                                    return void this.checkLVal(
                                        t.parameter,
                                        e,
                                        n,
                                        "parameter property"
                                    );
                                case "TSAsExpression":
                                case "TSNonNullExpression":
                                case "TSTypeAssertion":
                                    return void this.checkLVal(
                                        t.expression,
                                        e,
                                        n,
                                        r
                                    );
                                default:
                                    return void super.checkLVal(t, e, n, r);
                            }
                        }
                        parseBindingAtom() {
                            switch (this.state.type) {
                                case h._this:
                                    return this.parseIdentifier(!0);
                                default:
                                    return super.parseBindingAtom();
                            }
                        }
                        parseMaybeDecoratorArguments(t) {
                            if (this.isRelational("<")) {
                                const e = this.tsParseTypeArguments();
                                if (this.match(h.parenL)) {
                                    const n =
                                        super.parseMaybeDecoratorArguments(t);
                                    return (n.typeParameters = e), n;
                                }
                                this.unexpected(this.state.start, h.parenL);
                            }
                            return super.parseMaybeDecoratorArguments(t);
                        }
                        isClassMethod() {
                            return (
                                this.isRelational("<") || super.isClassMethod()
                            );
                        }
                        isClassProperty() {
                            return (
                                this.match(h.bang) ||
                                this.match(h.colon) ||
                                super.isClassProperty()
                            );
                        }
                        parseMaybeDefault(...t) {
                            const e = super.parseMaybeDefault(...t);
                            return (
                                "AssignmentPattern" === e.type &&
                                    e.typeAnnotation &&
                                    e.right.start < e.typeAnnotation.start &&
                                    this.raise(
                                        e.typeAnnotation.start,
                                        dt.TypeAnnotationAfterAssign
                                    ),
                                e
                            );
                        }
                        getTokenFromCode(t) {
                            return !this.state.inType || (62 !== t && 60 !== t)
                                ? super.getTokenFromCode(t)
                                : this.finishOp(h.relational, 1);
                        }
                        reScan_lt_gt() {
                            if (this.match(h.relational)) {
                                const t = this.input.charCodeAt(
                                    this.state.start
                                );
                                (60 !== t && 62 !== t) ||
                                    ((this.state.pos -= 1),
                                    this.readToken_lt_gt(t));
                            }
                        }
                        toAssignableList(t) {
                            for (let e = 0; e < t.length; e++) {
                                const n = t[e];
                                if (n)
                                    switch (n.type) {
                                        case "TSTypeCastExpression":
                                            t[e] = this.typeCastToParameter(n);
                                            break;
                                        case "TSAsExpression":
                                        case "TSTypeAssertion":
                                            this.state.maybeInArrowParameters
                                                ? this.raise(
                                                      n.start,
                                                      dt.UnexpectedTypeCastInParameter
                                                  )
                                                : (t[e] =
                                                      this.typeCastToParameter(
                                                          n
                                                      ));
                                    }
                            }
                            return super.toAssignableList(...arguments);
                        }
                        typeCastToParameter(t) {
                            return (
                                (t.expression.typeAnnotation =
                                    t.typeAnnotation),
                                this.resetEndLocation(
                                    t.expression,
                                    t.typeAnnotation.end,
                                    t.typeAnnotation.loc.end
                                ),
                                t.expression
                            );
                        }
                        toReferencedList(t, e) {
                            for (let e = 0; e < t.length; e++) {
                                const n = t[e];
                                "TSTypeCastExpression" ===
                                    (null == n ? void 0 : n.type) &&
                                    this.raise(
                                        n.start,
                                        dt.UnexpectedTypeAnnotation
                                    );
                            }
                            return t;
                        }
                        shouldParseArrow() {
                            return (
                                this.match(h.colon) || super.shouldParseArrow()
                            );
                        }
                        shouldParseAsyncArrow() {
                            return (
                                this.match(h.colon) ||
                                super.shouldParseAsyncArrow()
                            );
                        }
                        canHaveLeadingDecorator() {
                            return (
                                super.canHaveLeadingDecorator() ||
                                this.isAbstractClass()
                            );
                        }
                        jsxParseOpeningElementAfterName(t) {
                            if (this.isRelational("<")) {
                                const e = this.tsTryParseAndCatch(() =>
                                    this.tsParseTypeArguments()
                                );
                                e && (t.typeParameters = e);
                            }
                            return super.jsxParseOpeningElementAfterName(t);
                        }
                        getGetterSetterExpectedParamCount(t) {
                            const e = super.getGetterSetterExpectedParamCount(
                                    t
                                ),
                                n = t.params[0];
                            return n &&
                                "Identifier" === n.type &&
                                "this" === n.name
                                ? e + 1
                                : e;
                        }
                        parseCatchClauseParam() {
                            const t = super.parseCatchClauseParam(),
                                e = this.tsTryParseTypeAnnotation();
                            return (
                                e &&
                                    ((t.typeAnnotation = e),
                                    this.resetEndLocation(t)),
                                t
                            );
                        }
                    },
                v8intrinsic: (t) =>
                    class extends t {
                        parseV8Intrinsic() {
                            if (this.match(h.modulo)) {
                                const t = this.state.start,
                                    e = this.startNode();
                                if ((this.eat(h.modulo), this.match(h.name))) {
                                    const t = this.parseIdentifierName(
                                            this.state.start
                                        ),
                                        n = this.createIdentifier(e, t);
                                    if (
                                        ((n.type = "V8IntrinsicIdentifier"),
                                        this.match(h.parenL))
                                    )
                                        return n;
                                }
                                this.unexpected(t);
                            }
                        }
                        parseExprAtom() {
                            return (
                                this.parseV8Intrinsic() ||
                                super.parseExprAtom(...arguments)
                            );
                        }
                    },
                placeholders: (t) =>
                    class extends t {
                        parsePlaceholder(t) {
                            if (this.match(h.placeholder)) {
                                const e = this.startNode();
                                return (
                                    this.next(),
                                    this.assertNoSpace(
                                        "Unexpected space in placeholder."
                                    ),
                                    (e.name = super.parseIdentifier(!0)),
                                    this.assertNoSpace(
                                        "Unexpected space in placeholder."
                                    ),
                                    this.expect(h.placeholder),
                                    this.finishPlaceholder(e, t)
                                );
                            }
                        }
                        finishPlaceholder(t, e) {
                            const n = !(
                                !t.expectedNode || "Placeholder" !== t.type
                            );
                            return (
                                (t.expectedNode = e),
                                n ? t : this.finishNode(t, "Placeholder")
                            );
                        }
                        getTokenFromCode(t) {
                            return 37 === t &&
                                37 === this.input.charCodeAt(this.state.pos + 1)
                                ? this.finishOp(h.placeholder, 2)
                                : super.getTokenFromCode(...arguments);
                        }
                        parseExprAtom() {
                            return (
                                this.parsePlaceholder("Expression") ||
                                super.parseExprAtom(...arguments)
                            );
                        }
                        parseIdentifier() {
                            return (
                                this.parsePlaceholder("Identifier") ||
                                super.parseIdentifier(...arguments)
                            );
                        }
                        checkReservedWord(t) {
                            void 0 !== t &&
                                super.checkReservedWord(...arguments);
                        }
                        parseBindingAtom() {
                            return (
                                this.parsePlaceholder("Pattern") ||
                                super.parseBindingAtom(...arguments)
                            );
                        }
                        checkLVal(t) {
                            "Placeholder" !== t.type &&
                                super.checkLVal(...arguments);
                        }
                        toAssignable(t) {
                            return t &&
                                "Placeholder" === t.type &&
                                "Expression" === t.expectedNode
                                ? ((t.expectedNode = "Pattern"), t)
                                : super.toAssignable(...arguments);
                        }
                        verifyBreakContinue(t) {
                            (t.label && "Placeholder" === t.label.type) ||
                                super.verifyBreakContinue(...arguments);
                        }
                        parseExpressionStatement(t, e) {
                            if (
                                "Placeholder" !== e.type ||
                                (e.extra && e.extra.parenthesized)
                            )
                                return super.parseExpressionStatement(
                                    ...arguments
                                );
                            if (this.match(h.colon)) {
                                const n = t;
                                return (
                                    (n.label = this.finishPlaceholder(
                                        e,
                                        "Identifier"
                                    )),
                                    this.next(),
                                    (n.body = this.parseStatement("label")),
                                    this.finishNode(n, "LabeledStatement")
                                );
                            }
                            return (
                                this.semicolon(),
                                (t.name = e.name),
                                this.finishPlaceholder(t, "Statement")
                            );
                        }
                        parseBlock() {
                            return (
                                this.parsePlaceholder("BlockStatement") ||
                                super.parseBlock(...arguments)
                            );
                        }
                        parseFunctionId() {
                            return (
                                this.parsePlaceholder("Identifier") ||
                                super.parseFunctionId(...arguments)
                            );
                        }
                        parseClass(t, e, n) {
                            const r = e
                                ? "ClassDeclaration"
                                : "ClassExpression";
                            this.next(), this.takeDecorators(t);
                            const s = this.state.strict,
                                i = this.parsePlaceholder("Identifier");
                            if (i)
                                if (
                                    this.match(h._extends) ||
                                    this.match(h.placeholder) ||
                                    this.match(h.braceL)
                                )
                                    t.id = i;
                                else {
                                    if (n || !e)
                                        return (
                                            (t.id = null),
                                            (t.body = this.finishPlaceholder(
                                                i,
                                                "ClassBody"
                                            )),
                                            this.finishNode(t, r)
                                        );
                                    this.unexpected(
                                        null,
                                        "A class name is required"
                                    );
                                }
                            else this.parseClassId(t, e, n);
                            return (
                                this.parseClassSuper(t),
                                (t.body =
                                    this.parsePlaceholder("ClassBody") ||
                                    this.parseClassBody(!!t.superClass, s)),
                                this.finishNode(t, r)
                            );
                        }
                        parseExport(t) {
                            const e = this.parsePlaceholder("Identifier");
                            if (!e) return super.parseExport(...arguments);
                            if (
                                !this.isContextual("from") &&
                                !this.match(h.comma)
                            )
                                return (
                                    (t.specifiers = []),
                                    (t.source = null),
                                    (t.declaration = this.finishPlaceholder(
                                        e,
                                        "Declaration"
                                    )),
                                    this.finishNode(t, "ExportNamedDeclaration")
                                );
                            this.expectPlugin("exportDefaultFrom");
                            const n = this.startNode();
                            return (
                                (n.exported = e),
                                (t.specifiers = [
                                    this.finishNode(
                                        n,
                                        "ExportDefaultSpecifier"
                                    ),
                                ]),
                                super.parseExport(t)
                            );
                        }
                        isExportDefaultSpecifier() {
                            if (this.match(h._default)) {
                                const t = this.nextTokenStart();
                                if (
                                    this.isUnparsedContextual(t, "from") &&
                                    this.input.startsWith(
                                        h.placeholder.label,
                                        this.nextTokenStartSince(t + 4)
                                    )
                                )
                                    return !0;
                            }
                            return super.isExportDefaultSpecifier();
                        }
                        maybeParseExportDefaultSpecifier(t) {
                            return (
                                !!(t.specifiers && t.specifiers.length > 0) ||
                                super.maybeParseExportDefaultSpecifier(
                                    ...arguments
                                )
                            );
                        }
                        checkExport(t) {
                            const { specifiers: e } = t;
                            (null == e ? void 0 : e.length) &&
                                (t.specifiers = e.filter(
                                    (t) => "Placeholder" === t.exported.type
                                )),
                                super.checkExport(t),
                                (t.specifiers = e);
                        }
                        parseImport(t) {
                            const e = this.parsePlaceholder("Identifier");
                            if (!e) return super.parseImport(...arguments);
                            if (
                                ((t.specifiers = []),
                                !this.isContextual("from") &&
                                    !this.match(h.comma))
                            )
                                return (
                                    (t.source = this.finishPlaceholder(
                                        e,
                                        "StringLiteral"
                                    )),
                                    this.semicolon(),
                                    this.finishNode(t, "ImportDeclaration")
                                );
                            const n = this.startNodeAtNode(e);
                            if (
                                ((n.local = e),
                                this.finishNode(n, "ImportDefaultSpecifier"),
                                t.specifiers.push(n),
                                this.eat(h.comma))
                            ) {
                                this.maybeParseStarImportSpecifier(t) ||
                                    this.parseNamedImportSpecifiers(t);
                            }
                            return (
                                this.expectContextual("from"),
                                (t.source = this.parseImportSource()),
                                this.semicolon(),
                                this.finishNode(t, "ImportDeclaration")
                            );
                        }
                        parseImportSource() {
                            return (
                                this.parsePlaceholder("StringLiteral") ||
                                super.parseImportSource(...arguments)
                            );
                        }
                    },
            },
            bt = Object.keys(vt),
            xt = {
                sourceType: "script",
                sourceFilename: void 0,
                startLine: 1,
                allowAwaitOutsideFunction: !1,
                allowReturnOutsideFunction: !1,
                allowImportExportEverywhere: !1,
                allowSuperOutsideMethod: !1,
                allowUndeclaredExports: !1,
                plugins: [],
                strictMode: null,
                ranges: !1,
                tokens: !1,
                createParenthesizedExpressions: !1,
                errorRecovery: !1,
            };
        class wt {
            constructor() {
                (this.errors = []),
                    (this.potentialArrowAt = -1),
                    (this.noArrowAt = []),
                    (this.noArrowParamsConversionAt = []),
                    (this.inParameters = !1),
                    (this.maybeInArrowParameters = !1),
                    (this.maybeInAsyncArrowHead = !1),
                    (this.inPipeline = !1),
                    (this.inType = !1),
                    (this.noAnonFunctionType = !1),
                    (this.inPropertyName = !1),
                    (this.hasFlowComment = !1),
                    (this.isIterator = !1),
                    (this.topicContext = {
                        maxNumOfResolvableTopics: 0,
                        maxTopicIndex: null,
                    }),
                    (this.soloAwait = !1),
                    (this.inFSharpPipelineDirectBody = !1),
                    (this.labels = []),
                    (this.decoratorStack = [[]]),
                    (this.yieldPos = -1),
                    (this.awaitPos = -1),
                    (this.comments = []),
                    (this.trailingComments = []),
                    (this.leadingComments = []),
                    (this.commentStack = []),
                    (this.commentPreviousNode = null),
                    (this.pos = 0),
                    (this.lineStart = 0),
                    (this.type = h.eof),
                    (this.value = null),
                    (this.start = 0),
                    (this.end = 0),
                    (this.lastTokEndLoc = null),
                    (this.lastTokStartLoc = null),
                    (this.lastTokStart = 0),
                    (this.lastTokEnd = 0),
                    (this.context = [C.braceStatement]),
                    (this.exprAllowed = !0),
                    (this.containsEsc = !1),
                    (this.octalPositions = []),
                    (this.exportedIdentifiers = []),
                    (this.tokensLength = 0);
            }
            init(t) {
                (this.strict =
                    !1 !== t.strictMode && "module" === t.sourceType),
                    (this.curLine = t.startLine),
                    (this.startLoc = this.endLoc = this.curPosition());
            }
            curPosition() {
                return new w(this.curLine, this.pos - this.lineStart);
            }
            clone(t) {
                const e = new wt(),
                    n = Object.keys(this);
                for (let r = 0, s = n.length; r < s; r++) {
                    const s = n[r];
                    let i = this[s];
                    !t && Array.isArray(i) && (i = i.slice()), (e[s] = i);
                }
                return e;
            }
        }
        var Pt = function (t) {
            return t >= 48 && t <= 57;
        };
        const At = new Set(["g", "m", "s", "i", "y", "u"]),
            Et = {
                decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
                hex: [46, 88, 95, 120],
            },
            Tt = { bin: [48, 49] };
        (Tt.oct = [...Tt.bin, 50, 51, 52, 53, 54, 55]),
            (Tt.dec = [...Tt.oct, 56, 57]),
            (Tt.hex = [
                ...Tt.dec,
                65,
                66,
                67,
                68,
                69,
                70,
                97,
                98,
                99,
                100,
                101,
                102,
            ]);
        class St {
            constructor(t) {
                (this.type = t.type),
                    (this.value = t.value),
                    (this.start = t.start),
                    (this.end = t.end),
                    (this.loc = new P(t.startLoc, t.endLoc));
            }
        }
        class Ct {
            constructor() {
                (this.shorthandAssign = -1), (this.doubleProto = -1);
            }
        }
        class Ot {
            constructor(t, e, n) {
                (this.type = ""),
                    (this.start = e),
                    (this.end = 0),
                    (this.loc = new P(n)),
                    (null == t ? void 0 : t.options.ranges) &&
                        (this.range = [e, 0]),
                    (null == t ? void 0 : t.filename) &&
                        (this.loc.filename = t.filename);
            }
            __clone() {
                const t = new Ot(),
                    e = Object.keys(this);
                for (let n = 0, r = e.length; n < r; n++) {
                    const r = e[n];
                    "leadingComments" !== r &&
                        "trailingComments" !== r &&
                        "innerComments" !== r &&
                        (t[r] = this[r]);
                }
                return t;
            }
        }
        const kt = (t) =>
            "ParenthesizedExpression" === t.type ? kt(t.expression) : t;
        const _t = { kind: "loop" },
            Nt = { kind: "switch" };
        class It {
            constructor() {
                (this.privateNames = new Set()),
                    (this.loneAccessors = new Map()),
                    (this.undefinedPrivateNames = new Map());
            }
        }
        class jt {
            constructor(t) {
                (this.stack = []),
                    (this.undefinedPrivateNames = new Map()),
                    (this.raise = t);
            }
            current() {
                return this.stack[this.stack.length - 1];
            }
            enter() {
                this.stack.push(new It());
            }
            exit() {
                const t = this.stack.pop(),
                    e = this.current();
                for (
                    let n = 0, r = Array.from(t.undefinedPrivateNames);
                    n < r.length;
                    n++
                ) {
                    const [t, s] = r[n];
                    e
                        ? e.undefinedPrivateNames.has(t) ||
                          e.undefinedPrivateNames.set(t, s)
                        : this.raise(s, E.InvalidPrivateFieldResolution, t);
                }
            }
            declarePrivateName(t, e, n) {
                const r = this.current();
                let s = r.privateNames.has(t);
                if (3 & e) {
                    const n = s && r.loneAccessors.get(t);
                    if (n) {
                        const i = 4 & n,
                            o = 4 & e;
                        (s = (3 & n) === (3 & e) || i !== o),
                            s || r.loneAccessors.delete(t);
                    } else s || r.loneAccessors.set(t, e);
                }
                s && this.raise(n, E.PrivateNameRedeclaration, t),
                    r.privateNames.add(t),
                    r.undefinedPrivateNames.delete(t);
            }
            usePrivateName(t, e) {
                let n;
                for (let e = 0, r = this.stack; e < r.length; e++)
                    if (((n = r[e]), n.privateNames.has(t))) return;
                n
                    ? n.undefinedPrivateNames.set(t, e)
                    : this.raise(e, E.InvalidPrivateFieldResolution, t);
            }
        }
        class Lt extends class extends class extends class extends class extends class extends class extends class extends class extends class {
            constructor() {
                (this.sawUnambiguousESM = !1),
                    (this.ambiguousScriptDifferentAst = !1);
            }
            hasPlugin(t) {
                return this.plugins.has(t);
            }
            getPluginOption(t, e) {
                if (this.hasPlugin(t)) return this.plugins.get(t)[e];
            }
        } {
            addComment(t) {
                this.filename && (t.loc.filename = this.filename),
                    this.state.trailingComments.push(t),
                    this.state.leadingComments.push(t);
            }
            adjustCommentsAfterTrailingComma(t, e, n) {
                if (0 === this.state.leadingComments.length) return;
                let r = null,
                    s = e.length;
                for (; null === r && s > 0; ) r = e[--s];
                if (null === r) return;
                for (let t = 0; t < this.state.leadingComments.length; t++)
                    this.state.leadingComments[t].end <
                        this.state.commentPreviousNode.end &&
                        (this.state.leadingComments.splice(t, 1), t--);
                const i = [];
                for (let e = 0; e < this.state.leadingComments.length; e++) {
                    const r = this.state.leadingComments[e];
                    r.end < t.end
                        ? (i.push(r),
                          n || (this.state.leadingComments.splice(e, 1), e--))
                        : (void 0 === t.trailingComments &&
                              (t.trailingComments = []),
                          t.trailingComments.push(r));
                }
                n && (this.state.leadingComments = []),
                    i.length > 0
                        ? (r.trailingComments = i)
                        : void 0 !== r.trailingComments &&
                          (r.trailingComments = []);
            }
            processComment(t) {
                if ("Program" === t.type && t.body.length > 0) return;
                const e = this.state.commentStack;
                let n, r, s, i, o;
                if (this.state.trailingComments.length > 0)
                    this.state.trailingComments[0].start >= t.end
                        ? ((s = this.state.trailingComments),
                          (this.state.trailingComments = []))
                        : (this.state.trailingComments.length = 0);
                else if (e.length > 0) {
                    const n = A(e);
                    n.trailingComments &&
                        n.trailingComments[0].start >= t.end &&
                        ((s = n.trailingComments), delete n.trailingComments);
                }
                for (
                    e.length > 0 && A(e).start >= t.start && (n = e.pop());
                    e.length > 0 && A(e).start >= t.start;

                )
                    r = e.pop();
                if ((!r && n && (r = n), n))
                    switch (t.type) {
                        case "ObjectExpression":
                            this.adjustCommentsAfterTrailingComma(
                                t,
                                t.properties
                            );
                            break;
                        case "ObjectPattern":
                            this.adjustCommentsAfterTrailingComma(
                                t,
                                t.properties,
                                !0
                            );
                            break;
                        case "CallExpression":
                            this.adjustCommentsAfterTrailingComma(
                                t,
                                t.arguments
                            );
                            break;
                        case "ArrayExpression":
                            this.adjustCommentsAfterTrailingComma(
                                t,
                                t.elements
                            );
                            break;
                        case "ArrayPattern":
                            this.adjustCommentsAfterTrailingComma(
                                t,
                                t.elements,
                                !0
                            );
                    }
                else
                    this.state.commentPreviousNode &&
                        (("ImportSpecifier" ===
                            this.state.commentPreviousNode.type &&
                            "ImportSpecifier" !== t.type) ||
                            ("ExportSpecifier" ===
                                this.state.commentPreviousNode.type &&
                                "ExportSpecifier" !== t.type)) &&
                        this.adjustCommentsAfterTrailingComma(t, [
                            this.state.commentPreviousNode,
                        ]);
                if (r) {
                    if (r.leadingComments)
                        if (
                            r !== t &&
                            r.leadingComments.length > 0 &&
                            A(r.leadingComments).end <= t.start
                        )
                            (t.leadingComments = r.leadingComments),
                                delete r.leadingComments;
                        else
                            for (i = r.leadingComments.length - 2; i >= 0; --i)
                                if (r.leadingComments[i].end <= t.start) {
                                    t.leadingComments =
                                        r.leadingComments.splice(0, i + 1);
                                    break;
                                }
                } else if (this.state.leadingComments.length > 0)
                    if (A(this.state.leadingComments).end <= t.start) {
                        if (this.state.commentPreviousNode)
                            for (
                                o = 0;
                                o < this.state.leadingComments.length;
                                o++
                            )
                                this.state.leadingComments[o].end <
                                    this.state.commentPreviousNode.end &&
                                    (this.state.leadingComments.splice(o, 1),
                                    o--);
                        this.state.leadingComments.length > 0 &&
                            ((t.leadingComments = this.state.leadingComments),
                            (this.state.leadingComments = []));
                    } else {
                        for (
                            i = 0;
                            i < this.state.leadingComments.length &&
                            !(this.state.leadingComments[i].end > t.start);
                            i++
                        );
                        const e = this.state.leadingComments.slice(0, i);
                        e.length && (t.leadingComments = e),
                            (s = this.state.leadingComments.slice(i)),
                            0 === s.length && (s = null);
                    }
                if (((this.state.commentPreviousNode = t), s))
                    if (s.length && s[0].start >= t.start && A(s).end <= t.end)
                        t.innerComments = s;
                    else {
                        const e = s.findIndex((e) => e.end >= t.end);
                        e > 0
                            ? ((t.innerComments = s.slice(0, e)),
                              (t.trailingComments = s.slice(e)))
                            : (t.trailingComments = s);
                    }
                e.push(t);
            }
        } {
            getLocationForPosition(t) {
                let e;
                return (
                    (e =
                        t === this.state.start
                            ? this.state.startLoc
                            : t === this.state.lastTokStart
                            ? this.state.lastTokStartLoc
                            : t === this.state.end
                            ? this.state.endLoc
                            : t === this.state.lastTokEnd
                            ? this.state.lastTokEndLoc
                            : (function (t, e) {
                                  let n,
                                      r = 1,
                                      s = 0;
                                  for (
                                      g.lastIndex = 0;
                                      (n = g.exec(t)) && n.index < e;

                                  )
                                      r++, (s = g.lastIndex);
                                  return new w(r, e - s);
                              })(this.input, t)),
                    e
                );
            }
            raise(t, e, ...n) {
                return this.raiseWithData(t, void 0, e, ...n);
            }
            raiseWithData(t, e, n, ...r) {
                const s = this.getLocationForPosition(t),
                    i =
                        n.replace(/%(\d+)/g, (t, e) => r[e]) +
                        ` (${s.line}:${s.column})`;
                return this._raise(Object.assign({ loc: s, pos: t }, e), i);
            }
            _raise(t, e) {
                const n = new SyntaxError(e);
                if ((Object.assign(n, t), this.options.errorRecovery))
                    return this.isLookahead || this.state.errors.push(n), n;
                throw n;
            }
        } {
            constructor(t, e) {
                super(),
                    (this.tokens = []),
                    (this.state = new wt()),
                    this.state.init(t),
                    (this.input = e),
                    (this.length = e.length),
                    (this.isLookahead = !1);
            }
            pushToken(t) {
                (this.tokens.length = this.state.tokensLength),
                    this.tokens.push(t),
                    ++this.state.tokensLength;
            }
            next() {
                this.isLookahead ||
                    (this.checkKeywordEscapes(),
                    this.options.tokens && this.pushToken(new St(this.state))),
                    (this.state.lastTokEnd = this.state.end),
                    (this.state.lastTokStart = this.state.start),
                    (this.state.lastTokEndLoc = this.state.endLoc),
                    (this.state.lastTokStartLoc = this.state.startLoc),
                    this.nextToken();
            }
            eat(t) {
                return !!this.match(t) && (this.next(), !0);
            }
            match(t) {
                return this.state.type === t;
            }
            lookahead() {
                const t = this.state;
                (this.state = t.clone(!0)),
                    (this.isLookahead = !0),
                    this.next(),
                    (this.isLookahead = !1);
                const e = this.state;
                return (this.state = t), e;
            }
            nextTokenStart() {
                return this.nextTokenStartSince(this.state.pos);
            }
            nextTokenStartSince(t) {
                b.lastIndex = t;
                return t + b.exec(this.input)[0].length;
            }
            lookaheadCharCode() {
                return this.input.charCodeAt(this.nextTokenStart());
            }
            setStrict(t) {
                if (
                    ((this.state.strict = t),
                    this.match(h.num) || this.match(h.string))
                ) {
                    for (
                        this.state.pos = this.state.start;
                        this.state.pos < this.state.lineStart;

                    )
                        (this.state.lineStart =
                            this.input.lastIndexOf(
                                "\n",
                                this.state.lineStart - 2
                            ) + 1),
                            --this.state.curLine;
                    this.nextToken();
                }
            }
            curContext() {
                return this.state.context[this.state.context.length - 1];
            }
            nextToken() {
                const t = this.curContext();
                if (
                    ((null == t ? void 0 : t.preserveSpace) || this.skipSpace(),
                    (this.state.octalPositions = []),
                    (this.state.start = this.state.pos),
                    (this.state.startLoc = this.state.curPosition()),
                    this.state.pos >= this.length)
                )
                    return void this.finishToken(h.eof);
                const e = null == t ? void 0 : t.override;
                e
                    ? e(this)
                    : this.getTokenFromCode(
                          this.input.codePointAt(this.state.pos)
                      );
            }
            pushComment(t, e, n, r, s, i) {
                const o = {
                    type: t ? "CommentBlock" : "CommentLine",
                    value: e,
                    start: n,
                    end: r,
                    loc: new P(s, i),
                };
                this.options.tokens && this.pushToken(o),
                    this.state.comments.push(o),
                    this.addComment(o);
            }
            skipBlockComment() {
                const t = this.state.curPosition(),
                    e = this.state.pos,
                    n = this.input.indexOf("*/", this.state.pos + 2);
                if (-1 === n) throw this.raise(e, E.UnterminatedComment);
                let r;
                for (
                    this.state.pos = n + 2, g.lastIndex = e;
                    (r = g.exec(this.input)) && r.index < this.state.pos;

                )
                    ++this.state.curLine,
                        (this.state.lineStart = r.index + r[0].length);
                this.isLookahead ||
                    this.pushComment(
                        !0,
                        this.input.slice(e + 2, n),
                        e,
                        this.state.pos,
                        t,
                        this.state.curPosition()
                    );
            }
            skipLineComment(t) {
                const e = this.state.pos,
                    n = this.state.curPosition();
                let r = this.input.charCodeAt((this.state.pos += t));
                if (this.state.pos < this.length)
                    for (; !v(r) && ++this.state.pos < this.length; )
                        r = this.input.charCodeAt(this.state.pos);
                this.isLookahead ||
                    this.pushComment(
                        !1,
                        this.input.slice(e + t, this.state.pos),
                        e,
                        this.state.pos,
                        n,
                        this.state.curPosition()
                    );
            }
            skipSpace() {
                t: for (; this.state.pos < this.length; ) {
                    const t = this.input.charCodeAt(this.state.pos);
                    switch (t) {
                        case 32:
                        case 160:
                        case 9:
                            ++this.state.pos;
                            break;
                        case 13:
                            10 === this.input.charCodeAt(this.state.pos + 1) &&
                                ++this.state.pos;
                        case 10:
                        case 8232:
                        case 8233:
                            ++this.state.pos,
                                ++this.state.curLine,
                                (this.state.lineStart = this.state.pos);
                            break;
                        case 47:
                            switch (this.input.charCodeAt(this.state.pos + 1)) {
                                case 42:
                                    this.skipBlockComment();
                                    break;
                                case 47:
                                    this.skipLineComment(2);
                                    break;
                                default:
                                    break t;
                            }
                            break;
                        default:
                            if (!x(t)) break t;
                            ++this.state.pos;
                    }
                }
            }
            finishToken(t, e) {
                (this.state.end = this.state.pos),
                    (this.state.endLoc = this.state.curPosition());
                const n = this.state.type;
                (this.state.type = t),
                    (this.state.value = e),
                    this.isLookahead || this.updateContext(n);
            }
            readToken_numberSign() {
                if (0 === this.state.pos && this.readToken_interpreter())
                    return;
                const t = this.state.pos + 1,
                    e = this.input.charCodeAt(t);
                if (e >= 48 && e <= 57)
                    throw this.raise(
                        this.state.pos,
                        E.UnexpectedDigitAfterHash
                    );
                if (
                    123 === e ||
                    (91 === e && this.hasPlugin("recordAndTuple"))
                ) {
                    if (
                        (this.expectPlugin("recordAndTuple"),
                        "hash" !==
                            this.getPluginOption(
                                "recordAndTuple",
                                "syntaxType"
                            ))
                    )
                        throw this.raise(
                            this.state.pos,
                            123 === e
                                ? E.RecordExpressionHashIncorrectStartSyntaxType
                                : E.TupleExpressionHashIncorrectStartSyntaxType
                        );
                    123 === e
                        ? this.finishToken(h.braceHashL)
                        : this.finishToken(h.bracketHashL),
                        (this.state.pos += 2);
                } else this.finishOp(h.hash, 1);
            }
            readToken_dot() {
                const t = this.input.charCodeAt(this.state.pos + 1);
                t >= 48 && t <= 57
                    ? this.readNumber(!0)
                    : 46 === t &&
                      46 === this.input.charCodeAt(this.state.pos + 2)
                    ? ((this.state.pos += 3), this.finishToken(h.ellipsis))
                    : (++this.state.pos, this.finishToken(h.dot));
            }
            readToken_slash() {
                if (this.state.exprAllowed && !this.state.inType)
                    return ++this.state.pos, void this.readRegexp();
                61 === this.input.charCodeAt(this.state.pos + 1)
                    ? this.finishOp(h.assign, 2)
                    : this.finishOp(h.slash, 1);
            }
            readToken_interpreter() {
                if (0 !== this.state.pos || this.length < 2) return !1;
                let t = this.input.charCodeAt(this.state.pos + 1);
                if (33 !== t) return !1;
                const e = this.state.pos;
                for (
                    this.state.pos += 1;
                    !v(t) && ++this.state.pos < this.length;

                )
                    t = this.input.charCodeAt(this.state.pos);
                const n = this.input.slice(e + 2, this.state.pos);
                return this.finishToken(h.interpreterDirective, n), !0;
            }
            readToken_mult_modulo(t) {
                let e = 42 === t ? h.star : h.modulo,
                    n = 1,
                    r = this.input.charCodeAt(this.state.pos + 1);
                const s = this.state.exprAllowed;
                42 === t &&
                    42 === r &&
                    (n++,
                    (r = this.input.charCodeAt(this.state.pos + 2)),
                    (e = h.exponent)),
                    61 !== r || s || (n++, (e = h.assign)),
                    this.finishOp(e, n);
            }
            readToken_pipe_amp(t) {
                const e = this.input.charCodeAt(this.state.pos + 1);
                if (e !== t) {
                    if (124 === t) {
                        if (62 === e) return void this.finishOp(h.pipeline, 2);
                        if (this.hasPlugin("recordAndTuple") && 125 === e) {
                            if (
                                "bar" !==
                                this.getPluginOption(
                                    "recordAndTuple",
                                    "syntaxType"
                                )
                            )
                                throw this.raise(
                                    this.state.pos,
                                    E.RecordExpressionBarIncorrectEndSyntaxType
                                );
                            return void this.finishOp(h.braceBarR, 2);
                        }
                        if (this.hasPlugin("recordAndTuple") && 93 === e) {
                            if (
                                "bar" !==
                                this.getPluginOption(
                                    "recordAndTuple",
                                    "syntaxType"
                                )
                            )
                                throw this.raise(
                                    this.state.pos,
                                    E.TupleExpressionBarIncorrectEndSyntaxType
                                );
                            return void this.finishOp(h.bracketBarR, 2);
                        }
                    }
                    61 !== e
                        ? this.finishOp(
                              124 === t ? h.bitwiseOR : h.bitwiseAND,
                              1
                          )
                        : this.finishOp(h.assign, 2);
                } else
                    61 === this.input.charCodeAt(this.state.pos + 2)
                        ? this.finishOp(h.assign, 3)
                        : this.finishOp(
                              124 === t ? h.logicalOR : h.logicalAND,
                              2
                          );
            }
            readToken_caret() {
                61 === this.input.charCodeAt(this.state.pos + 1)
                    ? this.finishOp(h.assign, 2)
                    : this.finishOp(h.bitwiseXOR, 1);
            }
            readToken_plus_min(t) {
                const e = this.input.charCodeAt(this.state.pos + 1);
                if (e === t)
                    return 45 !== e ||
                        this.inModule ||
                        62 !== this.input.charCodeAt(this.state.pos + 2) ||
                        (0 !== this.state.lastTokEnd &&
                            !this.hasPrecedingLineBreak())
                        ? void this.finishOp(h.incDec, 2)
                        : (this.skipLineComment(3),
                          this.skipSpace(),
                          void this.nextToken());
                61 === e
                    ? this.finishOp(h.assign, 2)
                    : this.finishOp(h.plusMin, 1);
            }
            readToken_lt_gt(t) {
                const e = this.input.charCodeAt(this.state.pos + 1);
                let n = 1;
                return e === t
                    ? ((n =
                          62 === t &&
                          62 === this.input.charCodeAt(this.state.pos + 2)
                              ? 3
                              : 2),
                      61 === this.input.charCodeAt(this.state.pos + n)
                          ? void this.finishOp(h.assign, n + 1)
                          : void this.finishOp(h.bitShift, n))
                    : 33 !== e ||
                      60 !== t ||
                      this.inModule ||
                      45 !== this.input.charCodeAt(this.state.pos + 2) ||
                      45 !== this.input.charCodeAt(this.state.pos + 3)
                    ? (61 === e && (n = 2), void this.finishOp(h.relational, n))
                    : (this.skipLineComment(4),
                      this.skipSpace(),
                      void this.nextToken());
            }
            readToken_eq_excl(t) {
                const e = this.input.charCodeAt(this.state.pos + 1);
                if (61 !== e)
                    return 61 === t && 62 === e
                        ? ((this.state.pos += 2),
                          void this.finishToken(h.arrow))
                        : void this.finishOp(61 === t ? h.eq : h.bang, 1);
                this.finishOp(
                    h.equality,
                    61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2
                );
            }
            readToken_question() {
                const t = this.input.charCodeAt(this.state.pos + 1),
                    e = this.input.charCodeAt(this.state.pos + 2);
                63 === t
                    ? 61 === e
                        ? this.finishOp(h.assign, 3)
                        : this.finishOp(h.nullishCoalescing, 2)
                    : 46 !== t || (e >= 48 && e <= 57)
                    ? (++this.state.pos, this.finishToken(h.question))
                    : ((this.state.pos += 2), this.finishToken(h.questionDot));
            }
            getTokenFromCode(t) {
                switch (t) {
                    case 46:
                        return void this.readToken_dot();
                    case 40:
                        return (
                            ++this.state.pos, void this.finishToken(h.parenL)
                        );
                    case 41:
                        return (
                            ++this.state.pos, void this.finishToken(h.parenR)
                        );
                    case 59:
                        return ++this.state.pos, void this.finishToken(h.semi);
                    case 44:
                        return ++this.state.pos, void this.finishToken(h.comma);
                    case 91:
                        if (
                            this.hasPlugin("recordAndTuple") &&
                            124 === this.input.charCodeAt(this.state.pos + 1)
                        ) {
                            if (
                                "bar" !==
                                this.getPluginOption(
                                    "recordAndTuple",
                                    "syntaxType"
                                )
                            )
                                throw this.raise(
                                    this.state.pos,
                                    E.TupleExpressionBarIncorrectStartSyntaxType
                                );
                            this.finishToken(h.bracketBarL),
                                (this.state.pos += 2);
                        } else ++this.state.pos, this.finishToken(h.bracketL);
                        return;
                    case 93:
                        return (
                            ++this.state.pos, void this.finishToken(h.bracketR)
                        );
                    case 123:
                        if (
                            this.hasPlugin("recordAndTuple") &&
                            124 === this.input.charCodeAt(this.state.pos + 1)
                        ) {
                            if (
                                "bar" !==
                                this.getPluginOption(
                                    "recordAndTuple",
                                    "syntaxType"
                                )
                            )
                                throw this.raise(
                                    this.state.pos,
                                    E.RecordExpressionBarIncorrectStartSyntaxType
                                );
                            this.finishToken(h.braceBarL),
                                (this.state.pos += 2);
                        } else ++this.state.pos, this.finishToken(h.braceL);
                        return;
                    case 125:
                        return (
                            ++this.state.pos, void this.finishToken(h.braceR)
                        );
                    case 58:
                        return void (this.hasPlugin("functionBind") &&
                        58 === this.input.charCodeAt(this.state.pos + 1)
                            ? this.finishOp(h.doubleColon, 2)
                            : (++this.state.pos, this.finishToken(h.colon)));
                    case 63:
                        return void this.readToken_question();
                    case 96:
                        return (
                            ++this.state.pos, void this.finishToken(h.backQuote)
                        );
                    case 48: {
                        const t = this.input.charCodeAt(this.state.pos + 1);
                        if (120 === t || 88 === t)
                            return void this.readRadixNumber(16);
                        if (111 === t || 79 === t)
                            return void this.readRadixNumber(8);
                        if (98 === t || 66 === t)
                            return void this.readRadixNumber(2);
                    }
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                        return void this.readNumber(!1);
                    case 34:
                    case 39:
                        return void this.readString(t);
                    case 47:
                        return void this.readToken_slash();
                    case 37:
                    case 42:
                        return void this.readToken_mult_modulo(t);
                    case 124:
                    case 38:
                        return void this.readToken_pipe_amp(t);
                    case 94:
                        return void this.readToken_caret();
                    case 43:
                    case 45:
                        return void this.readToken_plus_min(t);
                    case 60:
                    case 62:
                        return void this.readToken_lt_gt(t);
                    case 61:
                    case 33:
                        return void this.readToken_eq_excl(t);
                    case 126:
                        return void this.finishOp(h.tilde, 1);
                    case 64:
                        return ++this.state.pos, void this.finishToken(h.at);
                    case 35:
                        return void this.readToken_numberSign();
                    case 92:
                        return void this.readWord();
                    default:
                        if (M(t)) return void this.readWord();
                }
                throw this.raise(
                    this.state.pos,
                    E.InvalidOrUnexpectedToken,
                    String.fromCodePoint(t)
                );
            }
            finishOp(t, e) {
                const n = this.input.slice(this.state.pos, this.state.pos + e);
                (this.state.pos += e), this.finishToken(t, n);
            }
            readRegexp() {
                const t = this.state.pos;
                let e, n;
                for (;;) {
                    if (this.state.pos >= this.length)
                        throw this.raise(t, E.UnterminatedRegExp);
                    const r = this.input.charAt(this.state.pos);
                    if (y.test(r)) throw this.raise(t, E.UnterminatedRegExp);
                    if (e) e = !1;
                    else {
                        if ("[" === r) n = !0;
                        else if ("]" === r && n) n = !1;
                        else if ("/" === r && !n) break;
                        e = "\\" === r;
                    }
                    ++this.state.pos;
                }
                const r = this.input.slice(t, this.state.pos);
                ++this.state.pos;
                let s = "";
                for (; this.state.pos < this.length; ) {
                    const t = this.input[this.state.pos],
                        e = this.input.codePointAt(this.state.pos);
                    if (At.has(t))
                        s.indexOf(t) > -1 &&
                            this.raise(
                                this.state.pos + 1,
                                E.DuplicateRegExpFlags
                            );
                    else {
                        if (!R(e) && 92 !== e) break;
                        this.raise(this.state.pos + 1, E.MalformedRegExpFlags);
                    }
                    ++this.state.pos, (s += t);
                }
                this.finishToken(h.regexp, { pattern: r, flags: s });
            }
            readInt(t, e, n, r = !0) {
                const s = this.state.pos,
                    i = 16 === t ? Et.hex : Et.decBinOct,
                    o =
                        16 === t
                            ? Tt.hex
                            : 10 === t
                            ? Tt.dec
                            : 8 === t
                            ? Tt.oct
                            : Tt.bin;
                let a = !1,
                    c = 0;
                for (let s = 0, l = null == e ? 1 / 0 : e; s < l; ++s) {
                    const e = this.input.charCodeAt(this.state.pos);
                    let l;
                    if (95 !== e) {
                        if (
                            ((l =
                                e >= 97
                                    ? e - 97 + 10
                                    : e >= 65
                                    ? e - 65 + 10
                                    : Pt(e)
                                    ? e - 48
                                    : 1 / 0),
                            l >= t)
                        )
                            if (this.options.errorRecovery && l <= 9)
                                (l = 0),
                                    this.raise(
                                        this.state.start + s + 2,
                                        E.InvalidDigit,
                                        t
                                    );
                            else {
                                if (!n) break;
                                (l = 0), (a = !0);
                            }
                        ++this.state.pos, (c = c * t + l);
                    } else {
                        const t = this.input.charCodeAt(this.state.pos - 1),
                            e = this.input.charCodeAt(this.state.pos + 1);
                        (-1 === o.indexOf(e) ||
                            i.indexOf(t) > -1 ||
                            i.indexOf(e) > -1 ||
                            Number.isNaN(e)) &&
                            this.raise(
                                this.state.pos,
                                E.UnexpectedNumericSeparator
                            ),
                            r ||
                                this.raise(
                                    this.state.pos,
                                    E.NumericSeparatorInEscapeSequence
                                ),
                            ++this.state.pos;
                    }
                }
                return this.state.pos === s ||
                    (null != e && this.state.pos - s !== e) ||
                    a
                    ? null
                    : c;
            }
            readRadixNumber(t) {
                const e = this.state.pos;
                let n = !1;
                this.state.pos += 2;
                const r = this.readInt(t);
                null == r &&
                    this.raise(this.state.start + 2, E.InvalidDigit, t);
                const s = this.input.charCodeAt(this.state.pos);
                if (110 === s) ++this.state.pos, (n = !0);
                else if (109 === s) throw this.raise(e, E.InvalidDecimal);
                if (M(this.input.codePointAt(this.state.pos)))
                    throw this.raise(this.state.pos, E.NumberIdentifier);
                if (n) {
                    const t = this.input
                        .slice(e, this.state.pos)
                        .replace(/[_n]/g, "");
                    this.finishToken(h.bigint, t);
                } else this.finishToken(h.num, r);
            }
            readNumber(t) {
                const e = this.state.pos;
                let n = !1,
                    r = !1,
                    s = !1,
                    i = !1,
                    o = !1;
                t ||
                    null !== this.readInt(10) ||
                    this.raise(e, E.InvalidNumber);
                const a =
                    this.state.pos - e >= 2 && 48 === this.input.charCodeAt(e);
                if (a) {
                    const t = this.input.slice(e, this.state.pos);
                    if (this.state.strict) this.raise(e, E.StrictOctalLiteral);
                    else {
                        const n = t.indexOf("_");
                        n > 0 && this.raise(n + e, E.ZeroDigitNumericSeparator);
                    }
                    o = a && !/[89]/.test(t);
                }
                let c = this.input.charCodeAt(this.state.pos);
                if (
                    (46 !== c ||
                        o ||
                        (++this.state.pos,
                        this.readInt(10),
                        (n = !0),
                        (c = this.input.charCodeAt(this.state.pos))),
                    (69 !== c && 101 !== c) ||
                        o ||
                        ((c = this.input.charCodeAt(++this.state.pos)),
                        (43 !== c && 45 !== c) || ++this.state.pos,
                        null === this.readInt(10) &&
                            this.raise(e, E.InvalidNumber),
                        (n = !0),
                        (i = !0),
                        (c = this.input.charCodeAt(this.state.pos))),
                    110 === c &&
                        ((n || a) && this.raise(e, E.InvalidBigIntLiteral),
                        ++this.state.pos,
                        (r = !0)),
                    109 === c &&
                        (this.expectPlugin("decimal", this.state.pos),
                        (i || a) && this.raise(e, E.InvalidDecimal),
                        ++this.state.pos,
                        (s = !0)),
                    M(this.input.codePointAt(this.state.pos)))
                )
                    throw this.raise(this.state.pos, E.NumberIdentifier);
                const l = this.input
                    .slice(e, this.state.pos)
                    .replace(/[_mn]/g, "");
                if (r) return void this.finishToken(h.bigint, l);
                if (s) return void this.finishToken(h.decimal, l);
                const u = o ? parseInt(l, 8) : parseFloat(l);
                this.finishToken(h.num, u);
            }
            readCodePoint(t) {
                let e;
                if (123 === this.input.charCodeAt(this.state.pos)) {
                    const n = ++this.state.pos;
                    if (
                        ((e = this.readHexChar(
                            this.input.indexOf("}", this.state.pos) -
                                this.state.pos,
                            !0,
                            t
                        )),
                        ++this.state.pos,
                        null !== e && e > 1114111)
                    ) {
                        if (!t) return null;
                        this.raise(n, E.InvalidCodePoint);
                    }
                } else e = this.readHexChar(4, !1, t);
                return e;
            }
            readString(t) {
                let e = "",
                    n = ++this.state.pos;
                for (;;) {
                    if (this.state.pos >= this.length)
                        throw this.raise(
                            this.state.start,
                            E.UnterminatedString
                        );
                    const r = this.input.charCodeAt(this.state.pos);
                    if (r === t) break;
                    if (92 === r)
                        (e += this.input.slice(n, this.state.pos)),
                            (e += this.readEscapedChar(!1)),
                            (n = this.state.pos);
                    else if (8232 === r || 8233 === r)
                        ++this.state.pos,
                            ++this.state.curLine,
                            (this.state.lineStart = this.state.pos);
                    else {
                        if (v(r))
                            throw this.raise(
                                this.state.start,
                                E.UnterminatedString
                            );
                        ++this.state.pos;
                    }
                }
                (e += this.input.slice(n, this.state.pos++)),
                    this.finishToken(h.string, e);
            }
            readTmplToken() {
                let t = "",
                    e = this.state.pos,
                    n = !1;
                for (;;) {
                    if (this.state.pos >= this.length)
                        throw this.raise(
                            this.state.start,
                            E.UnterminatedTemplate
                        );
                    const r = this.input.charCodeAt(this.state.pos);
                    if (
                        96 === r ||
                        (36 === r &&
                            123 === this.input.charCodeAt(this.state.pos + 1))
                    )
                        return this.state.pos === this.state.start &&
                            this.match(h.template)
                            ? 36 === r
                                ? ((this.state.pos += 2),
                                  void this.finishToken(h.dollarBraceL))
                                : (++this.state.pos,
                                  void this.finishToken(h.backQuote))
                            : ((t += this.input.slice(e, this.state.pos)),
                              void this.finishToken(h.template, n ? null : t));
                    if (92 === r) {
                        t += this.input.slice(e, this.state.pos);
                        const r = this.readEscapedChar(!0);
                        null === r ? (n = !0) : (t += r), (e = this.state.pos);
                    } else if (v(r)) {
                        switch (
                            ((t += this.input.slice(e, this.state.pos)),
                            ++this.state.pos,
                            r)
                        ) {
                            case 13:
                                10 === this.input.charCodeAt(this.state.pos) &&
                                    ++this.state.pos;
                            case 10:
                                t += "\n";
                                break;
                            default:
                                t += String.fromCharCode(r);
                        }
                        ++this.state.curLine,
                            (this.state.lineStart = this.state.pos),
                            (e = this.state.pos);
                    } else ++this.state.pos;
                }
            }
            readEscapedChar(t) {
                const e = !t,
                    n = this.input.charCodeAt(++this.state.pos);
                switch ((++this.state.pos, n)) {
                    case 110:
                        return "\n";
                    case 114:
                        return "\r";
                    case 120: {
                        const t = this.readHexChar(2, !1, e);
                        return null === t ? null : String.fromCharCode(t);
                    }
                    case 117: {
                        const t = this.readCodePoint(e);
                        return null === t ? null : String.fromCodePoint(t);
                    }
                    case 116:
                        return "\t";
                    case 98:
                        return "\b";
                    case 118:
                        return "\v";
                    case 102:
                        return "\f";
                    case 13:
                        10 === this.input.charCodeAt(this.state.pos) &&
                            ++this.state.pos;
                    case 10:
                        (this.state.lineStart = this.state.pos),
                            ++this.state.curLine;
                    case 8232:
                    case 8233:
                        return "";
                    case 56:
                    case 57:
                        if (t) return null;
                        this.state.strict &&
                            this.raise(
                                this.state.pos - 1,
                                E.StrictNumericEscape
                            );
                    default:
                        if (n >= 48 && n <= 55) {
                            const e = this.state.pos - 1;
                            let n = this.input
                                    .substr(this.state.pos - 1, 3)
                                    .match(/^[0-7]+/)[0],
                                r = parseInt(n, 8);
                            r > 255 &&
                                ((n = n.slice(0, -1)), (r = parseInt(n, 8))),
                                (this.state.pos += n.length - 1);
                            const s = this.input.charCodeAt(this.state.pos);
                            if ("0" !== n || 56 === s || 57 === s) {
                                if (t) return null;
                                this.state.strict
                                    ? this.raise(e, E.StrictNumericEscape)
                                    : this.state.octalPositions.push(e);
                            }
                            return String.fromCharCode(r);
                        }
                        return String.fromCharCode(n);
                }
            }
            readHexChar(t, e, n) {
                const r = this.state.pos,
                    s = this.readInt(16, t, e, !1);
                return (
                    null === s &&
                        (n
                            ? this.raise(r, E.InvalidEscapeSequence)
                            : (this.state.pos = r - 1)),
                    s
                );
            }
            readWord1() {
                let t = "";
                this.state.containsEsc = !1;
                const e = this.state.pos;
                let n = this.state.pos;
                for (; this.state.pos < this.length; ) {
                    const r = this.input.codePointAt(this.state.pos);
                    if (R(r)) this.state.pos += r <= 65535 ? 1 : 2;
                    else if (this.state.isIterator && 64 === r)
                        ++this.state.pos;
                    else {
                        if (92 !== r) break;
                        {
                            (this.state.containsEsc = !0),
                                (t += this.input.slice(n, this.state.pos));
                            const r = this.state.pos,
                                s = this.state.pos === e ? M : R;
                            if (
                                117 !== this.input.charCodeAt(++this.state.pos)
                            ) {
                                this.raise(
                                    this.state.pos,
                                    E.MissingUnicodeEscape
                                );
                                continue;
                            }
                            ++this.state.pos;
                            const i = this.readCodePoint(!0);
                            null !== i &&
                                (s(i) ||
                                    this.raise(r, E.EscapedCharNotAnIdentifier),
                                (t += String.fromCodePoint(i))),
                                (n = this.state.pos);
                        }
                    }
                }
                return t + this.input.slice(n, this.state.pos);
            }
            isIterator(t) {
                return "@@iterator" === t || "@@asyncIterator" === t;
            }
            readWord() {
                const t = this.readWord1(),
                    e = c.get(t) || h.name;
                !this.state.isIterator ||
                    (this.isIterator(t) && this.state.inType) ||
                    this.raise(this.state.pos, E.InvalidIdentifier, t),
                    this.finishToken(e, t);
            }
            checkKeywordEscapes() {
                const t = this.state.type.keyword;
                t &&
                    this.state.containsEsc &&
                    this.raise(
                        this.state.start,
                        E.InvalidEscapedReservedWord,
                        t
                    );
            }
            braceIsBlock(t) {
                const e = this.curContext();
                return (
                    e === C.functionExpression ||
                    e === C.functionStatement ||
                    (t !== h.colon ||
                    (e !== C.braceStatement && e !== C.braceExpression)
                        ? t === h._return ||
                          (t === h.name && this.state.exprAllowed)
                            ? this.hasPrecedingLineBreak()
                            : t === h._else ||
                              t === h.semi ||
                              t === h.eof ||
                              t === h.parenR ||
                              t === h.arrow ||
                              (t === h.braceL
                                  ? e === C.braceStatement
                                  : t !== h._var &&
                                    t !== h._const &&
                                    t !== h.name &&
                                    (t === h.relational ||
                                        !this.state.exprAllowed))
                        : !e.isExpr)
                );
            }
            updateContext(t) {
                const e = this.state.type;
                let n;
                !e.keyword || (t !== h.dot && t !== h.questionDot)
                    ? (n = e.updateContext)
                        ? n.call(this, t)
                        : (this.state.exprAllowed = e.beforeExpr)
                    : (this.state.exprAllowed = !1);
            }
        } {
            addExtra(t, e, n) {
                if (!t) return;
                (t.extra = t.extra || {})[e] = n;
            }
            isRelational(t) {
                return this.match(h.relational) && this.state.value === t;
            }
            expectRelational(t) {
                this.isRelational(t)
                    ? this.next()
                    : this.unexpected(null, h.relational);
            }
            isContextual(t) {
                return (
                    this.match(h.name) &&
                    this.state.value === t &&
                    !this.state.containsEsc
                );
            }
            isUnparsedContextual(t, e) {
                const n = t + e.length;
                return (
                    this.input.slice(t, n) === e &&
                    (n === this.input.length || !R(this.input.charCodeAt(n)))
                );
            }
            isLookaheadContextual(t) {
                const e = this.nextTokenStart();
                return this.isUnparsedContextual(e, t);
            }
            eatContextual(t) {
                return this.isContextual(t) && this.eat(h.name);
            }
            expectContextual(t, e) {
                this.eatContextual(t) || this.unexpected(null, e);
            }
            canInsertSemicolon() {
                return (
                    this.match(h.eof) ||
                    this.match(h.braceR) ||
                    this.hasPrecedingLineBreak()
                );
            }
            hasPrecedingLineBreak() {
                return y.test(
                    this.input.slice(this.state.lastTokEnd, this.state.start)
                );
            }
            isLineTerminator() {
                return this.eat(h.semi) || this.canInsertSemicolon();
            }
            semicolon() {
                this.isLineTerminator() || this.unexpected(null, h.semi);
            }
            expect(t, e) {
                this.eat(t) || this.unexpected(e, t);
            }
            assertNoSpace(t = "Unexpected space.") {
                this.state.start > this.state.lastTokEnd &&
                    this.raise(this.state.lastTokEnd, t);
            }
            unexpected(t, e = "Unexpected token") {
                throw (
                    ("string" != typeof e &&
                        (e = `Unexpected token, expected "${e.label}"`),
                    this.raise(null != t ? t : this.state.start, e))
                );
            }
            expectPlugin(t, e) {
                if (!this.hasPlugin(t))
                    throw this.raiseWithData(
                        null != e ? e : this.state.start,
                        { missingPlugin: [t] },
                        `This experimental syntax requires enabling the parser plugin: '${t}'`
                    );
                return !0;
            }
            expectOnePlugin(t, e) {
                if (!t.some((t) => this.hasPlugin(t)))
                    throw this.raiseWithData(
                        null != e ? e : this.state.start,
                        { missingPlugin: t },
                        `This experimental syntax requires enabling one of the following parser plugin(s): '${t.join(
                            ", "
                        )}'`
                    );
            }
            checkYieldAwaitInDefaultParams() {
                -1 !== this.state.yieldPos &&
                    (-1 === this.state.awaitPos ||
                        this.state.yieldPos < this.state.awaitPos) &&
                    this.raise(this.state.yieldPos, E.YieldBindingIdentifier),
                    -1 !== this.state.awaitPos &&
                        this.raise(
                            this.state.awaitPos,
                            E.AwaitBindingIdentifier
                        );
            }
            tryParse(t, e = this.state.clone()) {
                const n = { node: null };
                try {
                    const r = t((t = null) => {
                        throw ((n.node = t), n);
                    });
                    if (this.state.errors.length > e.errors.length) {
                        const t = this.state;
                        return (
                            (this.state = e),
                            {
                                node: r,
                                error: t.errors[e.errors.length],
                                thrown: !1,
                                aborted: !1,
                                failState: t,
                            }
                        );
                    }
                    return {
                        node: r,
                        error: null,
                        thrown: !1,
                        aborted: !1,
                        failState: null,
                    };
                } catch (t) {
                    const r = this.state;
                    if (((this.state = e), t instanceof SyntaxError))
                        return {
                            node: null,
                            error: t,
                            thrown: !0,
                            aborted: !1,
                            failState: r,
                        };
                    if (t === n)
                        return {
                            node: n.node,
                            error: null,
                            thrown: !1,
                            aborted: !0,
                            failState: r,
                        };
                    throw t;
                }
            }
            checkExpressionErrors(t, e) {
                if (!t) return !1;
                const { shorthandAssign: n, doubleProto: r } = t;
                if (!e) return n >= 0 || r >= 0;
                n >= 0 && this.unexpected(n),
                    r >= 0 && this.raise(r, E.DuplicateProto);
            }
            isLiteralPropertyName() {
                return (
                    this.match(h.name) ||
                    !!this.state.type.keyword ||
                    this.match(h.string) ||
                    this.match(h.num) ||
                    this.match(h.bigint) ||
                    this.match(h.decimal)
                );
            }
        } {
            startNode() {
                return new Ot(this, this.state.start, this.state.startLoc);
            }
            startNodeAt(t, e) {
                return new Ot(this, t, e);
            }
            startNodeAtNode(t) {
                return this.startNodeAt(t.start, t.loc.start);
            }
            finishNode(t, e) {
                return this.finishNodeAt(
                    t,
                    e,
                    this.state.lastTokEnd,
                    this.state.lastTokEndLoc
                );
            }
            finishNodeAt(t, e, n, r) {
                return (
                    (t.type = e),
                    (t.end = n),
                    (t.loc.end = r),
                    this.options.ranges && (t.range[1] = n),
                    this.processComment(t),
                    t
                );
            }
            resetStartLocation(t, e, n) {
                (t.start = e),
                    (t.loc.start = n),
                    this.options.ranges && (t.range[0] = e);
            }
            resetEndLocation(
                t,
                e = this.state.lastTokEnd,
                n = this.state.lastTokEndLoc
            ) {
                (t.end = e),
                    (t.loc.end = n),
                    this.options.ranges && (t.range[1] = e);
            }
            resetStartLocationFromNode(t, e) {
                this.resetStartLocation(t, e.start, e.loc.start);
            }
        } {
            toAssignable(t) {
                var e, n;
                let r = void 0;
                switch (
                    (("ParenthesizedExpression" === t.type ||
                        (null == (e = t.extra) ? void 0 : e.parenthesized)) &&
                        ((r = kt(t)),
                        "Identifier" !== r.type &&
                            "MemberExpression" !== r.type &&
                            this.raise(
                                t.start,
                                E.InvalidParenthesizedAssignment
                            )),
                    t.type)
                ) {
                    case "Identifier":
                    case "ObjectPattern":
                    case "ArrayPattern":
                    case "AssignmentPattern":
                        break;
                    case "ObjectExpression":
                        t.type = "ObjectPattern";
                        for (
                            let e = 0, n = t.properties.length, r = n - 1;
                            e < n;
                            e++
                        ) {
                            var s;
                            const n = t.properties[e],
                                i = e === r;
                            this.toAssignableObjectExpressionProp(n, i),
                                i &&
                                    "RestElement" === n.type &&
                                    (null == (s = t.extra)
                                        ? void 0
                                        : s.trailingComma) &&
                                    this.raiseRestNotLast(
                                        t.extra.trailingComma
                                    );
                        }
                        break;
                    case "ObjectProperty":
                        this.toAssignable(t.value);
                        break;
                    case "SpreadElement": {
                        this.checkToRestConversion(t), (t.type = "RestElement");
                        const e = t.argument;
                        this.toAssignable(e);
                        break;
                    }
                    case "ArrayExpression":
                        (t.type = "ArrayPattern"),
                            this.toAssignableList(
                                t.elements,
                                null == (n = t.extra) ? void 0 : n.trailingComma
                            );
                        break;
                    case "AssignmentExpression":
                        "=" !== t.operator &&
                            this.raise(t.left.end, E.MissingEqInAssignment),
                            (t.type = "AssignmentPattern"),
                            delete t.operator,
                            this.toAssignable(t.left);
                        break;
                    case "ParenthesizedExpression":
                        this.toAssignable(r);
                }
                return t;
            }
            toAssignableObjectExpressionProp(t, e) {
                if ("ObjectMethod" === t.type) {
                    const e =
                        "get" === t.kind || "set" === t.kind
                            ? E.PatternHasAccessor
                            : E.PatternHasMethod;
                    this.raise(t.key.start, e);
                } else
                    "SpreadElement" !== t.type || e
                        ? this.toAssignable(t)
                        : this.raiseRestNotLast(t.start);
            }
            toAssignableList(t, e) {
                let n = t.length;
                if (n) {
                    const r = t[n - 1];
                    if ("RestElement" === (null == r ? void 0 : r.type)) --n;
                    else if (
                        "SpreadElement" === (null == r ? void 0 : r.type)
                    ) {
                        r.type = "RestElement";
                        const t = r.argument;
                        this.toAssignable(t),
                            "Identifier" !== t.type &&
                                "MemberExpression" !== t.type &&
                                "ArrayPattern" !== t.type &&
                                "ObjectPattern" !== t.type &&
                                this.unexpected(t.start),
                            e && this.raiseTrailingCommaAfterRest(e),
                            --n;
                    }
                }
                for (let e = 0; e < n; e++) {
                    const n = t[e];
                    n &&
                        (this.toAssignable(n),
                        "RestElement" === n.type &&
                            this.raiseRestNotLast(n.start));
                }
                return t;
            }
            toReferencedList(t, e) {
                return t;
            }
            toReferencedListDeep(t, e) {
                this.toReferencedList(t, e);
                for (let e = 0; e < t.length; e++) {
                    const n = t[e];
                    "ArrayExpression" === (null == n ? void 0 : n.type) &&
                        this.toReferencedListDeep(n.elements);
                }
            }
            parseSpread(t, e) {
                const n = this.startNode();
                return (
                    this.next(),
                    (n.argument = this.parseMaybeAssignAllowIn(t, void 0, e)),
                    this.finishNode(n, "SpreadElement")
                );
            }
            parseRestBinding() {
                const t = this.startNode();
                return (
                    this.next(),
                    (t.argument = this.parseBindingAtom()),
                    this.finishNode(t, "RestElement")
                );
            }
            parseBindingAtom() {
                switch (this.state.type) {
                    case h.bracketL: {
                        const t = this.startNode();
                        return (
                            this.next(),
                            (t.elements = this.parseBindingList(
                                h.bracketR,
                                93,
                                !0
                            )),
                            this.finishNode(t, "ArrayPattern")
                        );
                    }
                    case h.braceL:
                        return this.parseObjectLike(h.braceR, !0);
                }
                return this.parseIdentifier();
            }
            parseBindingList(t, e, n, r) {
                const s = [];
                let i = !0;
                for (; !this.eat(t); )
                    if (
                        (i ? (i = !1) : this.expect(h.comma),
                        n && this.match(h.comma))
                    )
                        s.push(null);
                    else {
                        if (this.eat(t)) break;
                        if (this.match(h.ellipsis)) {
                            s.push(
                                this.parseAssignableListItemTypes(
                                    this.parseRestBinding()
                                )
                            ),
                                this.checkCommaAfterRest(e),
                                this.expect(t);
                            break;
                        }
                        {
                            const t = [];
                            for (
                                this.match(h.at) &&
                                this.hasPlugin("decorators") &&
                                this.raise(
                                    this.state.start,
                                    E.UnsupportedParameterDecorator
                                );
                                this.match(h.at);

                            )
                                t.push(this.parseDecorator());
                            s.push(this.parseAssignableListItem(r, t));
                        }
                    }
                return s;
            }
            parseAssignableListItem(t, e) {
                const n = this.parseMaybeDefault();
                this.parseAssignableListItemTypes(n);
                const r = this.parseMaybeDefault(n.start, n.loc.start, n);
                return e.length && (n.decorators = e), r;
            }
            parseAssignableListItemTypes(t) {
                return t;
            }
            parseMaybeDefault(t, e, n) {
                var r, s, i;
                if (
                    ((e = null != (r = e) ? r : this.state.startLoc),
                    (t = null != (s = t) ? s : this.state.start),
                    (n = null != (i = n) ? i : this.parseBindingAtom()),
                    !this.eat(h.eq))
                )
                    return n;
                const o = this.startNodeAt(t, e);
                return (
                    (o.left = n),
                    (o.right = this.parseMaybeAssignAllowIn()),
                    this.finishNode(o, "AssignmentPattern")
                );
            }
            checkLVal(t, e = 64, n, r, s, i = !1) {
                switch (t.type) {
                    case "Identifier":
                        if (
                            (this.state.strict &&
                                (i ? H(t.name, this.inModule) : z(t.name)) &&
                                this.raise(
                                    t.start,
                                    e === m
                                        ? E.StrictEvalArguments
                                        : E.StrictEvalArgumentsBinding,
                                    t.name
                                ),
                            n)
                        ) {
                            const e = "_" + t.name;
                            n[e]
                                ? this.raise(t.start, E.ParamDupe)
                                : (n[e] = !0);
                        }
                        s &&
                            "let" === t.name &&
                            this.raise(t.start, E.LetInLexicalBinding),
                            e & m || this.scope.declareName(t.name, e, t.start);
                        break;
                    case "MemberExpression":
                        e !== m &&
                            this.raise(
                                t.start,
                                E.InvalidPropertyBindingPattern
                            );
                        break;
                    case "ObjectPattern":
                        for (let r = 0, i = t.properties; r < i.length; r++) {
                            let t = i[r];
                            if ("ObjectProperty" === t.type) t = t.value;
                            else if ("ObjectMethod" === t.type) continue;
                            this.checkLVal(
                                t,
                                e,
                                n,
                                "object destructuring pattern",
                                s
                            );
                        }
                        break;
                    case "ArrayPattern":
                        for (let r = 0, i = t.elements; r < i.length; r++) {
                            const t = i[r];
                            t &&
                                this.checkLVal(
                                    t,
                                    e,
                                    n,
                                    "array destructuring pattern",
                                    s
                                );
                        }
                        break;
                    case "AssignmentPattern":
                        this.checkLVal(t.left, e, n, "assignment pattern");
                        break;
                    case "RestElement":
                        this.checkLVal(t.argument, e, n, "rest element");
                        break;
                    case "ParenthesizedExpression":
                        this.checkLVal(
                            t.expression,
                            e,
                            n,
                            "parenthesized expression"
                        );
                        break;
                    default:
                        this.raise(
                            t.start,
                            e === m ? E.InvalidLhs : E.InvalidLhsBinding,
                            r
                        );
                }
            }
            checkToRestConversion(t) {
                "Identifier" !== t.argument.type &&
                    "MemberExpression" !== t.argument.type &&
                    this.raise(
                        t.argument.start,
                        E.InvalidRestAssignmentPattern
                    );
            }
            checkCommaAfterRest(t) {
                this.match(h.comma) &&
                    (this.lookaheadCharCode() === t
                        ? this.raiseTrailingCommaAfterRest(this.state.start)
                        : this.raiseRestNotLast(this.state.start));
            }
            raiseRestNotLast(t) {
                throw this.raise(t, E.ElementAfterRest);
            }
            raiseTrailingCommaAfterRest(t) {
                this.raise(t, E.RestTrailingComma);
            }
        } {
            checkProto(t, e, n, r) {
                if (
                    "SpreadElement" === t.type ||
                    "ObjectMethod" === t.type ||
                    t.computed ||
                    t.shorthand
                )
                    return;
                const s = t.key;
                if (
                    "__proto__" === ("Identifier" === s.type ? s.name : s.value)
                ) {
                    if (e) return void this.raise(s.start, E.RecordNoProto);
                    n.used &&
                        (r
                            ? -1 === r.doubleProto && (r.doubleProto = s.start)
                            : this.raise(s.start, E.DuplicateProto)),
                        (n.used = !0);
                }
            }
            shouldExitDescending(t, e) {
                return "ArrowFunctionExpression" === t.type && t.start === e;
            }
            getExpression() {
                let t = 0;
                this.hasPlugin("topLevelAwait") && this.inModule && (t |= 2),
                    this.scope.enter(1),
                    this.prodParam.enter(t),
                    this.nextToken();
                const e = this.parseExpression();
                return (
                    this.match(h.eof) || this.unexpected(),
                    (e.comments = this.state.comments),
                    (e.errors = this.state.errors),
                    e
                );
            }
            parseExpression(t, e) {
                return t
                    ? this.disallowInAnd(() => this.parseExpressionBase(e))
                    : this.allowInAnd(() => this.parseExpressionBase(e));
            }
            parseExpressionBase(t) {
                const e = this.state.start,
                    n = this.state.startLoc,
                    r = this.parseMaybeAssign(t);
                if (this.match(h.comma)) {
                    const s = this.startNodeAt(e, n);
                    for (s.expressions = [r]; this.eat(h.comma); )
                        s.expressions.push(this.parseMaybeAssign(t));
                    return (
                        this.toReferencedList(s.expressions),
                        this.finishNode(s, "SequenceExpression")
                    );
                }
                return r;
            }
            parseMaybeAssignDisallowIn(t, e, n) {
                return this.disallowInAnd(() => this.parseMaybeAssign(t, e, n));
            }
            parseMaybeAssignAllowIn(t, e, n) {
                return this.allowInAnd(() => this.parseMaybeAssign(t, e, n));
            }
            parseMaybeAssign(t, e, n) {
                const r = this.state.start,
                    s = this.state.startLoc;
                if (this.isContextual("yield")) {
                    if (this.prodParam.hasYield) {
                        let t = this.parseYield();
                        return e && (t = e.call(this, t, r, s)), t;
                    }
                    this.state.exprAllowed = !1;
                }
                let i;
                t ? (i = !1) : ((t = new Ct()), (i = !0)),
                    (this.match(h.parenL) || this.match(h.name)) &&
                        (this.state.potentialArrowAt = this.state.start);
                let o = this.parseMaybeConditional(t, n);
                if (
                    (e && (o = e.call(this, o, r, s)), this.state.type.isAssign)
                ) {
                    const e = this.startNodeAt(r, s),
                        n = this.state.value;
                    return (
                        (e.operator = n),
                        this.match(h.eq)
                            ? ((e.left = this.toAssignable(o)),
                              (t.doubleProto = -1))
                            : (e.left = o),
                        t.shorthandAssign >= e.left.start &&
                            (t.shorthandAssign = -1),
                        this.checkLVal(
                            o,
                            void 0,
                            void 0,
                            "assignment expression"
                        ),
                        this.next(),
                        (e.right = this.parseMaybeAssign()),
                        this.finishNode(e, "AssignmentExpression")
                    );
                }
                return i && this.checkExpressionErrors(t, !0), o;
            }
            parseMaybeConditional(t, e) {
                const n = this.state.start,
                    r = this.state.startLoc,
                    s = this.state.potentialArrowAt,
                    i = this.parseExprOps(t);
                return this.shouldExitDescending(i, s)
                    ? i
                    : this.parseConditional(i, n, r, e);
            }
            parseConditional(t, e, n, r) {
                if (this.eat(h.question)) {
                    const r = this.startNodeAt(e, n);
                    return (
                        (r.test = t),
                        (r.consequent = this.parseMaybeAssignAllowIn()),
                        this.expect(h.colon),
                        (r.alternate = this.parseMaybeAssign()),
                        this.finishNode(r, "ConditionalExpression")
                    );
                }
                return t;
            }
            parseExprOps(t) {
                const e = this.state.start,
                    n = this.state.startLoc,
                    r = this.state.potentialArrowAt,
                    s = this.parseMaybeUnary(t);
                return this.shouldExitDescending(s, r)
                    ? s
                    : this.parseExprOp(s, e, n, -1);
            }
            parseExprOp(t, e, n, r) {
                let s = this.state.type.binop;
                if (
                    null != s &&
                    (this.prodParam.hasIn || !this.match(h._in)) &&
                    s > r
                ) {
                    const i = this.state.type;
                    if (i === h.pipeline) {
                        if (
                            (this.expectPlugin("pipelineOperator"),
                            this.state.inFSharpPipelineDirectBody)
                        )
                            return t;
                        (this.state.inPipeline = !0),
                            this.checkPipelineAtInfixOperator(t, e);
                    }
                    const o = this.startNodeAt(e, n);
                    (o.left = t),
                        (o.operator = this.state.value),
                        i !== h.exponent ||
                            "UnaryExpression" !== t.type ||
                            (!this.options.createParenthesizedExpressions &&
                                t.extra &&
                                t.extra.parenthesized) ||
                            this.raise(
                                t.argument.start,
                                E.UnexpectedTokenUnaryExponentiation
                            );
                    const a = i === h.logicalOR || i === h.logicalAND,
                        c = i === h.nullishCoalescing;
                    if (
                        (c && (s = h.logicalAND.binop),
                        this.next(),
                        i === h.pipeline &&
                            "minimal" ===
                                this.getPluginOption(
                                    "pipelineOperator",
                                    "proposal"
                                ) &&
                            this.match(h.name) &&
                            "await" === this.state.value &&
                            this.prodParam.hasAwait)
                    )
                        throw this.raise(
                            this.state.start,
                            E.UnexpectedAwaitAfterPipelineBody
                        );
                    (o.right = this.parseExprOpRightExpr(i, s)),
                        this.finishNode(
                            o,
                            a || c ? "LogicalExpression" : "BinaryExpression"
                        );
                    const l = this.state.type;
                    if (
                        (c && (l === h.logicalOR || l === h.logicalAND)) ||
                        (a && l === h.nullishCoalescing)
                    )
                        throw this.raise(
                            this.state.start,
                            E.MixingCoalesceWithLogical
                        );
                    return this.parseExprOp(o, e, n, r);
                }
                return t;
            }
            parseExprOpRightExpr(t, e) {
                const n = this.state.start,
                    r = this.state.startLoc;
                switch (t) {
                    case h.pipeline:
                        switch (
                            this.getPluginOption("pipelineOperator", "proposal")
                        ) {
                            case "smart":
                                return this.withTopicPermittingContext(() =>
                                    this.parseSmartPipelineBody(
                                        this.parseExprOpBaseRightExpr(t, e),
                                        n,
                                        r
                                    )
                                );
                            case "fsharp":
                                return this.withSoloAwaitPermittingContext(() =>
                                    this.parseFSharpPipelineBody(e)
                                );
                        }
                    default:
                        return this.parseExprOpBaseRightExpr(t, e);
                }
            }
            parseExprOpBaseRightExpr(t, e) {
                const n = this.state.start,
                    r = this.state.startLoc;
                return this.parseExprOp(
                    this.parseMaybeUnary(),
                    n,
                    r,
                    t.rightAssociative ? e - 1 : e
                );
            }
            parseMaybeUnary(t) {
                if (this.isContextual("await") && this.isAwaitAllowed())
                    return this.parseAwait();
                const e = this.match(h.incDec),
                    n = this.startNode();
                if (this.state.type.prefix) {
                    (n.operator = this.state.value),
                        (n.prefix = !0),
                        this.match(h._throw) &&
                            this.expectPlugin("throwExpressions");
                    const r = this.match(h._delete);
                    if (
                        (this.next(),
                        (n.argument = this.parseMaybeUnary()),
                        this.checkExpressionErrors(t, !0),
                        this.state.strict && r)
                    ) {
                        const t = n.argument;
                        "Identifier" === t.type
                            ? this.raise(n.start, E.StrictDelete)
                            : ("MemberExpression" !== t.type &&
                                  "OptionalMemberExpression" !== t.type) ||
                              "PrivateName" !== t.property.type ||
                              this.raise(n.start, E.DeletePrivateField);
                    }
                    if (!e) return this.finishNode(n, "UnaryExpression");
                }
                return this.parseUpdate(n, e, t);
            }
            parseUpdate(t, e, n) {
                if (e)
                    return (
                        this.checkLVal(
                            t.argument,
                            void 0,
                            void 0,
                            "prefix operation"
                        ),
                        this.finishNode(t, "UpdateExpression")
                    );
                const r = this.state.start,
                    s = this.state.startLoc;
                let i = this.parseExprSubscripts(n);
                if (this.checkExpressionErrors(n, !1)) return i;
                for (
                    ;
                    this.state.type.postfix && !this.canInsertSemicolon();

                ) {
                    const t = this.startNodeAt(r, s);
                    (t.operator = this.state.value),
                        (t.prefix = !1),
                        (t.argument = i),
                        this.checkLVal(i, void 0, void 0, "postfix operation"),
                        this.next(),
                        (i = this.finishNode(t, "UpdateExpression"));
                }
                return i;
            }
            parseExprSubscripts(t) {
                const e = this.state.start,
                    n = this.state.startLoc,
                    r = this.state.potentialArrowAt,
                    s = this.parseExprAtom(t);
                return this.shouldExitDescending(s, r)
                    ? s
                    : this.parseSubscripts(s, e, n);
            }
            parseSubscripts(t, e, n, r) {
                const s = {
                    optionalChainMember: !1,
                    maybeAsyncArrow: this.atPossibleAsyncArrow(t),
                    stop: !1,
                };
                do {
                    const i = this.state.maybeInAsyncArrowHead;
                    s.maybeAsyncArrow &&
                        (this.state.maybeInAsyncArrowHead = !0),
                        (t = this.parseSubscript(t, e, n, r, s)),
                        (s.maybeAsyncArrow = !1),
                        (this.state.maybeInAsyncArrowHead = i);
                } while (!s.stop);
                return t;
            }
            parseSubscript(t, e, n, r, s) {
                if (!r && this.eat(h.doubleColon))
                    return this.parseBind(t, e, n, r, s);
                if (this.match(h.backQuote))
                    return this.parseTaggedTemplateExpression(t, e, n, s);
                let i = !1;
                if (this.match(h.questionDot)) {
                    if (
                        ((s.optionalChainMember = i = !0),
                        r && 40 === this.lookaheadCharCode())
                    )
                        return (s.stop = !0), t;
                    this.next();
                }
                return !r && this.match(h.parenL)
                    ? this.parseCoverCallAndAsyncArrowHead(t, e, n, s, i)
                    : i || this.match(h.bracketL) || this.eat(h.dot)
                    ? this.parseMember(t, e, n, s, i)
                    : ((s.stop = !0), t);
            }
            parseMember(t, e, n, r, s) {
                const i = this.startNodeAt(e, n),
                    o = this.eat(h.bracketL);
                (i.object = t), (i.computed = o);
                const a = o
                    ? this.parseExpression()
                    : this.parseMaybePrivateName(!0);
                return (
                    "PrivateName" === a.type &&
                        ("Super" === i.object.type &&
                            this.raise(e, E.SuperPrivateField),
                        this.classScope.usePrivateName(a.id.name, a.start)),
                    (i.property = a),
                    o && this.expect(h.bracketR),
                    r.optionalChainMember
                        ? ((i.optional = s),
                          this.finishNode(i, "OptionalMemberExpression"))
                        : this.finishNode(i, "MemberExpression")
                );
            }
            parseBind(t, e, n, r, s) {
                const i = this.startNodeAt(e, n);
                return (
                    (i.object = t),
                    (i.callee = this.parseNoCallExpr()),
                    (s.stop = !0),
                    this.parseSubscripts(
                        this.finishNode(i, "BindExpression"),
                        e,
                        n,
                        r
                    )
                );
            }
            parseCoverCallAndAsyncArrowHead(t, e, n, r, s) {
                const i = this.state.maybeInArrowParameters,
                    o = this.state.yieldPos,
                    a = this.state.awaitPos;
                (this.state.maybeInArrowParameters = !0),
                    (this.state.yieldPos = -1),
                    (this.state.awaitPos = -1),
                    this.next();
                let c = this.startNodeAt(e, n);
                return (
                    (c.callee = t),
                    r.optionalChainMember && (c.optional = s),
                    (c.arguments = s
                        ? this.parseCallExpressionArguments(h.parenR, !1)
                        : this.parseCallExpressionArguments(
                              h.parenR,
                              r.maybeAsyncArrow,
                              "Import" === t.type,
                              "Super" !== t.type,
                              c
                          )),
                    this.finishCallExpression(c, r.optionalChainMember),
                    r.maybeAsyncArrow && this.shouldParseAsyncArrow() && !s
                        ? ((r.stop = !0),
                          (c = this.parseAsyncArrowFromCallExpression(
                              this.startNodeAt(e, n),
                              c
                          )),
                          this.checkYieldAwaitInDefaultParams(),
                          (this.state.yieldPos = o),
                          (this.state.awaitPos = a))
                        : (this.toReferencedListDeep(c.arguments),
                          -1 !== o && (this.state.yieldPos = o),
                          ((this.isAwaitAllowed() || i) && -1 === a) ||
                              (this.state.awaitPos = a)),
                    (this.state.maybeInArrowParameters = i),
                    c
                );
            }
            parseTaggedTemplateExpression(t, e, n, r) {
                const s = this.startNodeAt(e, n);
                return (
                    (s.tag = t),
                    (s.quasi = this.parseTemplate(!0)),
                    r.optionalChainMember &&
                        this.raise(e, E.OptionalChainingNoTemplate),
                    this.finishNode(s, "TaggedTemplateExpression")
                );
            }
            atPossibleAsyncArrow(t) {
                return (
                    "Identifier" === t.type &&
                    "async" === t.name &&
                    this.state.lastTokEnd === t.end &&
                    !this.canInsertSemicolon() &&
                    t.end - t.start == 5 &&
                    t.start === this.state.potentialArrowAt
                );
            }
            finishCallExpression(t, e) {
                if ("Import" === t.callee.type)
                    if (
                        (2 === t.arguments.length &&
                            this.expectPlugin("moduleAttributes"),
                        0 === t.arguments.length || t.arguments.length > 2)
                    )
                        this.raise(
                            t.start,
                            E.ImportCallArity,
                            this.hasPlugin("moduleAttributes")
                                ? "one or two arguments"
                                : "one argument"
                        );
                    else
                        for (let e = 0, n = t.arguments; e < n.length; e++) {
                            const t = n[e];
                            "SpreadElement" === t.type &&
                                this.raise(t.start, E.ImportCallSpreadArgument);
                        }
                return this.finishNode(
                    t,
                    e ? "OptionalCallExpression" : "CallExpression"
                );
            }
            parseCallExpressionArguments(t, e, n, r, s) {
                const i = [];
                let o,
                    a = !0;
                const c = this.state.inFSharpPipelineDirectBody;
                for (
                    this.state.inFSharpPipelineDirectBody = !1;
                    !this.eat(t);

                ) {
                    if (a) a = !1;
                    else if ((this.expect(h.comma), this.match(t))) {
                        n &&
                            !this.hasPlugin("moduleAttributes") &&
                            this.raise(
                                this.state.lastTokStart,
                                E.ImportCallArgumentTrailingComma
                            ),
                            s &&
                                this.addExtra(
                                    s,
                                    "trailingComma",
                                    this.state.lastTokStart
                                ),
                            this.next();
                        break;
                    }
                    this.match(h.parenL) && !o && (o = this.state.start),
                        i.push(
                            this.parseExprListItem(
                                !1,
                                e ? new Ct() : void 0,
                                e ? { start: 0 } : void 0,
                                r
                            )
                        );
                }
                return (
                    e && o && this.shouldParseAsyncArrow() && this.unexpected(),
                    (this.state.inFSharpPipelineDirectBody = c),
                    i
                );
            }
            shouldParseAsyncArrow() {
                return this.match(h.arrow) && !this.canInsertSemicolon();
            }
            parseAsyncArrowFromCallExpression(t, e) {
                var n;
                return (
                    this.expect(h.arrow),
                    this.parseArrowExpression(
                        t,
                        e.arguments,
                        !0,
                        null == (n = e.extra) ? void 0 : n.trailingComma
                    ),
                    t
                );
            }
            parseNoCallExpr() {
                const t = this.state.start,
                    e = this.state.startLoc;
                return this.parseSubscripts(this.parseExprAtom(), t, e, !0);
            }
            parseExprAtom(t) {
                this.state.type === h.slash && this.readRegexp();
                const e = this.state.potentialArrowAt === this.state.start;
                let n;
                switch (this.state.type) {
                    case h._super:
                        return this.parseSuper();
                    case h._import:
                        return (
                            (n = this.startNode()),
                            this.next(),
                            this.match(h.dot)
                                ? this.parseImportMetaProperty(n)
                                : (this.match(h.parenL) ||
                                      this.raise(
                                          this.state.lastTokStart,
                                          E.UnsupportedImport
                                      ),
                                  this.finishNode(n, "Import"))
                        );
                    case h._this:
                        return (
                            (n = this.startNode()),
                            this.next(),
                            this.finishNode(n, "ThisExpression")
                        );
                    case h.name: {
                        const t = this.state.containsEsc,
                            n = this.parseIdentifier();
                        if (
                            !t &&
                            "async" === n.name &&
                            !this.canInsertSemicolon()
                        ) {
                            if (this.match(h._function)) {
                                const t = this.state.context.length - 1;
                                if (
                                    this.state.context[t] !==
                                    C.functionStatement
                                )
                                    throw new Error("Internal error");
                                return (
                                    (this.state.context[t] =
                                        C.functionExpression),
                                    this.next(),
                                    this.parseFunction(
                                        this.startNodeAtNode(n),
                                        void 0,
                                        !0
                                    )
                                );
                            }
                            if (this.match(h.name))
                                return this.parseAsyncArrowUnaryFunction(n);
                        }
                        return e &&
                            this.match(h.arrow) &&
                            !this.canInsertSemicolon()
                            ? (this.next(),
                              this.parseArrowExpression(
                                  this.startNodeAtNode(n),
                                  [n],
                                  !1
                              ))
                            : n;
                    }
                    case h._do:
                        return this.parseDo();
                    case h.regexp: {
                        const t = this.state.value;
                        return (
                            (n = this.parseLiteral(t.value, "RegExpLiteral")),
                            (n.pattern = t.pattern),
                            (n.flags = t.flags),
                            n
                        );
                    }
                    case h.num:
                        return this.parseLiteral(
                            this.state.value,
                            "NumericLiteral"
                        );
                    case h.bigint:
                        return this.parseLiteral(
                            this.state.value,
                            "BigIntLiteral"
                        );
                    case h.decimal:
                        return this.parseLiteral(
                            this.state.value,
                            "DecimalLiteral"
                        );
                    case h.string:
                        return this.parseLiteral(
                            this.state.value,
                            "StringLiteral"
                        );
                    case h._null:
                        return (
                            (n = this.startNode()),
                            this.next(),
                            this.finishNode(n, "NullLiteral")
                        );
                    case h._true:
                    case h._false:
                        return this.parseBooleanLiteral();
                    case h.parenL:
                        return this.parseParenAndDistinguishExpression(e);
                    case h.bracketBarL:
                    case h.bracketHashL:
                        return this.parseArrayLike(
                            this.state.type === h.bracketBarL
                                ? h.bracketBarR
                                : h.bracketR,
                            !1,
                            !0,
                            t
                        );
                    case h.bracketL:
                        return this.parseArrayLike(h.bracketR, !0, !1, t);
                    case h.braceBarL:
                    case h.braceHashL:
                        return this.parseObjectLike(
                            this.state.type === h.braceBarL
                                ? h.braceBarR
                                : h.braceR,
                            !1,
                            !0,
                            t
                        );
                    case h.braceL:
                        return this.parseObjectLike(h.braceR, !1, !1, t);
                    case h._function:
                        return this.parseFunctionOrFunctionSent();
                    case h.at:
                        this.parseDecorators();
                    case h._class:
                        return (
                            (n = this.startNode()),
                            this.takeDecorators(n),
                            this.parseClass(n, !1)
                        );
                    case h._new:
                        return this.parseNewOrNewTarget();
                    case h.backQuote:
                        return this.parseTemplate(!1);
                    case h.doubleColon: {
                        (n = this.startNode()), this.next(), (n.object = null);
                        const t = (n.callee = this.parseNoCallExpr());
                        if ("MemberExpression" === t.type)
                            return this.finishNode(n, "BindExpression");
                        throw this.raise(t.start, E.UnsupportedBind);
                    }
                    case h.hash: {
                        if (this.state.inPipeline)
                            return (
                                (n = this.startNode()),
                                "smart" !==
                                    this.getPluginOption(
                                        "pipelineOperator",
                                        "proposal"
                                    ) &&
                                    this.raise(
                                        n.start,
                                        E.PrimaryTopicRequiresSmartPipeline
                                    ),
                                this.next(),
                                this.primaryTopicReferenceIsAllowedInCurrentTopicContext() ||
                                    this.raise(
                                        n.start,
                                        E.PrimaryTopicNotAllowed
                                    ),
                                this.registerTopicReference(),
                                this.finishNode(
                                    n,
                                    "PipelinePrimaryTopicReference"
                                )
                            );
                        const t = this.input.codePointAt(this.state.end);
                        if (M(t) || 92 === t) {
                            const t = this.state.start;
                            if (
                                ((n = this.parseMaybePrivateName(!0)),
                                this.match(h._in))
                            )
                                this.expectPlugin("privateIn"),
                                    this.classScope.usePrivateName(
                                        n.id.name,
                                        n.start
                                    );
                            else {
                                if (!this.hasPlugin("privateIn"))
                                    throw this.unexpected(t);
                                this.raise(
                                    this.state.start,
                                    E.PrivateInExpectedIn,
                                    n.id.name
                                );
                            }
                            return n;
                        }
                    }
                    case h.relational:
                        if ("<" === this.state.value) {
                            const t = this.input.codePointAt(
                                this.nextTokenStart()
                            );
                            (M(t) || 62 === t) &&
                                this.expectOnePlugin([
                                    "jsx",
                                    "flow",
                                    "typescript",
                                ]);
                        }
                    default:
                        throw this.unexpected();
                }
            }
            parseAsyncArrowUnaryFunction(t) {
                const e = this.startNodeAtNode(t),
                    n = this.state.maybeInArrowParameters,
                    r = this.state.maybeInAsyncArrowHead,
                    s = this.state.yieldPos,
                    i = this.state.awaitPos;
                (this.state.maybeInArrowParameters = !0),
                    (this.state.maybeInAsyncArrowHead = !0),
                    (this.state.yieldPos = -1),
                    (this.state.awaitPos = -1);
                const o = [this.parseIdentifier()];
                return (
                    this.hasPrecedingLineBreak() &&
                        this.raise(this.state.pos, E.LineTerminatorBeforeArrow),
                    this.expect(h.arrow),
                    this.checkYieldAwaitInDefaultParams(),
                    (this.state.maybeInArrowParameters = n),
                    (this.state.maybeInAsyncArrowHead = r),
                    (this.state.yieldPos = s),
                    (this.state.awaitPos = i),
                    this.parseArrowExpression(e, o, !0),
                    e
                );
            }
            parseDo() {
                this.expectPlugin("doExpressions");
                const t = this.startNode();
                this.next();
                const e = this.state.labels;
                return (
                    (this.state.labels = []),
                    (t.body = this.parseBlock()),
                    (this.state.labels = e),
                    this.finishNode(t, "DoExpression")
                );
            }
            parseSuper() {
                const t = this.startNode();
                return (
                    this.next(),
                    !this.match(h.parenL) ||
                    this.scope.allowDirectSuper ||
                    this.options.allowSuperOutsideMethod
                        ? this.scope.allowSuper ||
                          this.options.allowSuperOutsideMethod ||
                          this.raise(t.start, E.UnexpectedSuper)
                        : this.raise(t.start, E.SuperNotAllowed),
                    this.match(h.parenL) ||
                        this.match(h.bracketL) ||
                        this.match(h.dot) ||
                        this.raise(t.start, E.UnsupportedSuper),
                    this.finishNode(t, "Super")
                );
            }
            parseBooleanLiteral() {
                const t = this.startNode();
                return (
                    (t.value = this.match(h._true)),
                    this.next(),
                    this.finishNode(t, "BooleanLiteral")
                );
            }
            parseMaybePrivateName(t) {
                if (this.match(h.hash)) {
                    this.expectOnePlugin([
                        "classPrivateProperties",
                        "classPrivateMethods",
                    ]),
                        t ||
                            this.raise(
                                this.state.pos,
                                E.UnexpectedPrivateField
                            );
                    const e = this.startNode();
                    return (
                        this.next(),
                        this.assertNoSpace(
                            "Unexpected space between # and identifier"
                        ),
                        (e.id = this.parseIdentifier(!0)),
                        this.finishNode(e, "PrivateName")
                    );
                }
                return this.parseIdentifier(!0);
            }
            parseFunctionOrFunctionSent() {
                const t = this.startNode();
                if (
                    (this.next(), this.prodParam.hasYield && this.match(h.dot))
                ) {
                    const e = this.createIdentifier(
                        this.startNodeAtNode(t),
                        "function"
                    );
                    return this.next(), this.parseMetaProperty(t, e, "sent");
                }
                return this.parseFunction(t);
            }
            parseMetaProperty(t, e, n) {
                (t.meta = e),
                    "function" === e.name &&
                        "sent" === n &&
                        (this.isContextual(n)
                            ? this.expectPlugin("functionSent")
                            : this.hasPlugin("functionSent") ||
                              this.unexpected());
                const r = this.state.containsEsc;
                return (
                    (t.property = this.parseIdentifier(!0)),
                    (t.property.name !== n || r) &&
                        this.raise(
                            t.property.start,
                            E.UnsupportedMetaProperty,
                            e.name,
                            n
                        ),
                    this.finishNode(t, "MetaProperty")
                );
            }
            parseImportMetaProperty(t) {
                const e = this.createIdentifier(
                    this.startNodeAtNode(t),
                    "import"
                );
                return (
                    this.next(),
                    this.isContextual("meta") &&
                        (this.inModule ||
                            this.raiseWithData(
                                e.start,
                                {
                                    code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED",
                                },
                                E.ImportMetaOutsideModule
                            ),
                        (this.sawUnambiguousESM = !0)),
                    this.parseMetaProperty(t, e, "meta")
                );
            }
            parseLiteral(t, e, n, r) {
                (n = n || this.state.start), (r = r || this.state.startLoc);
                const s = this.startNodeAt(n, r);
                return (
                    this.addExtra(s, "rawValue", t),
                    this.addExtra(
                        s,
                        "raw",
                        this.input.slice(n, this.state.end)
                    ),
                    (s.value = t),
                    this.next(),
                    this.finishNode(s, e)
                );
            }
            parseParenAndDistinguishExpression(t) {
                const e = this.state.start,
                    n = this.state.startLoc;
                let r;
                this.next();
                const s = this.state.maybeInArrowParameters,
                    i = this.state.yieldPos,
                    o = this.state.awaitPos,
                    a = this.state.inFSharpPipelineDirectBody;
                (this.state.maybeInArrowParameters = !0),
                    (this.state.yieldPos = -1),
                    (this.state.awaitPos = -1),
                    (this.state.inFSharpPipelineDirectBody = !1);
                const c = this.state.start,
                    l = this.state.startLoc,
                    u = [],
                    p = new Ct(),
                    d = { start: 0 };
                let f,
                    m,
                    y = !0;
                for (; !this.match(h.parenR); ) {
                    if (y) y = !1;
                    else if (
                        (this.expect(h.comma, d.start || null),
                        this.match(h.parenR))
                    ) {
                        m = this.state.start;
                        break;
                    }
                    if (this.match(h.ellipsis)) {
                        const t = this.state.start,
                            e = this.state.startLoc;
                        (f = this.state.start),
                            u.push(
                                this.parseParenItem(
                                    this.parseRestBinding(),
                                    t,
                                    e
                                )
                            ),
                            this.checkCommaAfterRest(41);
                        break;
                    }
                    u.push(
                        this.parseMaybeAssignAllowIn(p, this.parseParenItem, d)
                    );
                }
                const g = this.state.lastTokEnd,
                    v = this.state.lastTokEndLoc;
                this.expect(h.parenR),
                    (this.state.maybeInArrowParameters = s),
                    (this.state.inFSharpPipelineDirectBody = a);
                let b = this.startNodeAt(e, n);
                if (t && this.shouldParseArrow() && (b = this.parseArrow(b))) {
                    this.isAwaitAllowed() ||
                        this.state.maybeInAsyncArrowHead ||
                        (this.state.awaitPos = o),
                        this.checkYieldAwaitInDefaultParams(),
                        (this.state.yieldPos = i),
                        (this.state.awaitPos = o);
                    for (let t = 0; t < u.length; t++) {
                        const e = u[t];
                        e.extra &&
                            e.extra.parenthesized &&
                            this.unexpected(e.extra.parenStart);
                    }
                    return this.parseArrowExpression(b, u, !1), b;
                }
                if (
                    (-1 !== i && (this.state.yieldPos = i),
                    -1 !== o && (this.state.awaitPos = o),
                    u.length || this.unexpected(this.state.lastTokStart),
                    m && this.unexpected(m),
                    f && this.unexpected(f),
                    this.checkExpressionErrors(p, !0),
                    d.start && this.unexpected(d.start),
                    this.toReferencedListDeep(u, !0),
                    u.length > 1
                        ? ((r = this.startNodeAt(c, l)),
                          (r.expressions = u),
                          this.finishNodeAt(r, "SequenceExpression", g, v))
                        : (r = u[0]),
                    !this.options.createParenthesizedExpressions)
                )
                    return (
                        this.addExtra(r, "parenthesized", !0),
                        this.addExtra(r, "parenStart", e),
                        r
                    );
                const x = this.startNodeAt(e, n);
                return (
                    (x.expression = r),
                    this.finishNode(x, "ParenthesizedExpression"),
                    x
                );
            }
            shouldParseArrow() {
                return !this.canInsertSemicolon();
            }
            parseArrow(t) {
                if (this.eat(h.arrow)) return t;
            }
            parseParenItem(t, e, n) {
                return t;
            }
            parseNewOrNewTarget() {
                const t = this.startNode();
                if ((this.next(), this.match(h.dot))) {
                    const e = this.createIdentifier(
                        this.startNodeAtNode(t),
                        "new"
                    );
                    this.next();
                    const n = this.parseMetaProperty(t, e, "target");
                    if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
                        let t = E.UnexpectedNewTarget;
                        this.hasPlugin("classProperties") &&
                            (t += " or class properties"),
                            this.raise(n.start, t);
                    }
                    return n;
                }
                return this.parseNew(t);
            }
            parseNew(t) {
                return (
                    (t.callee = this.parseNoCallExpr()),
                    "Import" === t.callee.type
                        ? this.raise(
                              t.callee.start,
                              E.ImportCallNotNewExpression
                          )
                        : "OptionalMemberExpression" === t.callee.type ||
                          "OptionalCallExpression" === t.callee.type
                        ? this.raise(
                              this.state.lastTokEnd,
                              E.OptionalChainingNoNew
                          )
                        : this.eat(h.questionDot) &&
                          this.raise(this.state.start, E.OptionalChainingNoNew),
                    this.parseNewArguments(t),
                    this.finishNode(t, "NewExpression")
                );
            }
            parseNewArguments(t) {
                if (this.eat(h.parenL)) {
                    const e = this.parseExprList(h.parenR);
                    this.toReferencedList(e), (t.arguments = e);
                } else t.arguments = [];
            }
            parseTemplateElement(t) {
                const e = this.startNode();
                return (
                    null === this.state.value &&
                        (t ||
                            this.raise(
                                this.state.start + 1,
                                E.InvalidEscapeSequenceTemplate
                            )),
                    (e.value = {
                        raw: this.input
                            .slice(this.state.start, this.state.end)
                            .replace(/\r\n?/g, "\n"),
                        cooked: this.state.value,
                    }),
                    this.next(),
                    (e.tail = this.match(h.backQuote)),
                    this.finishNode(e, "TemplateElement")
                );
            }
            parseTemplate(t) {
                const e = this.startNode();
                this.next(), (e.expressions = []);
                let n = this.parseTemplateElement(t);
                for (e.quasis = [n]; !n.tail; )
                    this.expect(h.dollarBraceL),
                        e.expressions.push(this.parseExpression()),
                        this.expect(h.braceR),
                        e.quasis.push((n = this.parseTemplateElement(t)));
                return this.next(), this.finishNode(e, "TemplateLiteral");
            }
            parseObjectLike(t, e, n, r) {
                n && this.expectPlugin("recordAndTuple");
                const s = this.state.inFSharpPipelineDirectBody;
                this.state.inFSharpPipelineDirectBody = !1;
                const i = Object.create(null);
                let o = !0;
                const a = this.startNode();
                for (a.properties = [], this.next(); !this.eat(t); ) {
                    if (o) o = !1;
                    else if ((this.expect(h.comma), this.match(t))) {
                        this.addExtra(
                            a,
                            "trailingComma",
                            this.state.lastTokStart
                        ),
                            this.next();
                        break;
                    }
                    const s = this.parsePropertyDefinition(e, r);
                    e || this.checkProto(s, n, i, r),
                        n &&
                            "ObjectProperty" !== s.type &&
                            "SpreadElement" !== s.type &&
                            this.raise(s.start, E.InvalidRecordProperty),
                        s.shorthand && this.addExtra(s, "shorthand", !0),
                        a.properties.push(s);
                }
                this.state.inFSharpPipelineDirectBody = s;
                let c = "ObjectExpression";
                return (
                    e ? (c = "ObjectPattern") : n && (c = "RecordExpression"),
                    this.finishNode(a, c)
                );
            }
            maybeAsyncOrAccessorProp(t) {
                return (
                    !t.computed &&
                    "Identifier" === t.key.type &&
                    (this.isLiteralPropertyName() ||
                        this.match(h.bracketL) ||
                        this.match(h.star))
                );
            }
            parsePropertyDefinition(t, e) {
                let n = [];
                if (this.match(h.at))
                    for (
                        this.hasPlugin("decorators") &&
                        this.raise(
                            this.state.start,
                            E.UnsupportedPropertyDecorator
                        );
                        this.match(h.at);

                    )
                        n.push(this.parseDecorator());
                const r = this.startNode();
                let s,
                    i,
                    o = !1,
                    a = !1,
                    c = !1;
                if (this.match(h.ellipsis))
                    return (
                        n.length && this.unexpected(),
                        t
                            ? (this.next(),
                              (r.argument = this.parseIdentifier()),
                              this.checkCommaAfterRest(125),
                              this.finishNode(r, "RestElement"))
                            : this.parseSpread()
                    );
                n.length && ((r.decorators = n), (n = [])),
                    (r.method = !1),
                    (t || e) &&
                        ((s = this.state.start), (i = this.state.startLoc)),
                    t || (o = this.eat(h.star));
                const l = this.state.containsEsc,
                    u = this.parsePropertyName(r, !1);
                if (!t && !o && !l && this.maybeAsyncOrAccessorProp(r)) {
                    const t = u.name;
                    "async" !== t ||
                        this.hasPrecedingLineBreak() ||
                        ((a = !0),
                        (o = this.eat(h.star)),
                        this.parsePropertyName(r, !1)),
                        ("get" !== t && "set" !== t) ||
                            ((c = !0),
                            (r.kind = t),
                            this.match(h.star) &&
                                (this.raise(
                                    this.state.pos,
                                    E.AccessorIsGenerator,
                                    t
                                ),
                                this.next()),
                            this.parsePropertyName(r, !1));
                }
                return this.parseObjPropValue(r, s, i, o, a, t, c, e), r;
            }
            getGetterSetterExpectedParamCount(t) {
                return "get" === t.kind ? 0 : 1;
            }
            checkGetterSetterParams(t) {
                const e = this.getGetterSetterExpectedParamCount(t),
                    n = t.start;
                t.params.length !== e &&
                    ("get" === t.kind
                        ? this.raise(n, E.BadGetterArity)
                        : this.raise(n, E.BadSetterArity)),
                    "set" === t.kind &&
                        "RestElement" === t.params[t.params.length - 1].type &&
                        this.raise(n, E.BadSetterRestParameter);
            }
            parseObjectMethod(t, e, n, r, s) {
                return s
                    ? (this.parseMethod(t, !1, !1, !1, !1, "ObjectMethod"),
                      this.checkGetterSetterParams(t),
                      t)
                    : n || e || this.match(h.parenL)
                    ? (r && this.unexpected(),
                      (t.kind = "method"),
                      (t.method = !0),
                      this.parseMethod(t, e, n, !1, !1, "ObjectMethod"))
                    : void 0;
            }
            parseObjectProperty(t, e, n, r, s) {
                return (
                    (t.shorthand = !1),
                    this.eat(h.colon)
                        ? ((t.value = r
                              ? this.parseMaybeDefault(
                                    this.state.start,
                                    this.state.startLoc
                                )
                              : this.parseMaybeAssignAllowIn(s)),
                          this.finishNode(t, "ObjectProperty"))
                        : t.computed || "Identifier" !== t.key.type
                        ? void 0
                        : (this.checkReservedWord(
                              t.key.name,
                              t.key.start,
                              !0,
                              !1
                          ),
                          r
                              ? (t.value = this.parseMaybeDefault(
                                    e,
                                    n,
                                    t.key.__clone()
                                ))
                              : this.match(h.eq) && s
                              ? (-1 === s.shorthandAssign &&
                                    (s.shorthandAssign = this.state.start),
                                (t.value = this.parseMaybeDefault(
                                    e,
                                    n,
                                    t.key.__clone()
                                )))
                              : (t.value = t.key.__clone()),
                          (t.shorthand = !0),
                          this.finishNode(t, "ObjectProperty"))
                );
            }
            parseObjPropValue(t, e, n, r, s, i, o, a) {
                const c =
                    this.parseObjectMethod(t, r, s, i, o) ||
                    this.parseObjectProperty(t, e, n, i, a);
                return c || this.unexpected(), c;
            }
            parsePropertyName(t, e) {
                if (this.eat(h.bracketL))
                    (t.computed = !0),
                        (t.key = this.parseMaybeAssignAllowIn()),
                        this.expect(h.bracketR);
                else {
                    const n = this.state.inPropertyName;
                    (this.state.inPropertyName = !0),
                        (t.key =
                            this.match(h.num) ||
                            this.match(h.string) ||
                            this.match(h.bigint) ||
                            this.match(h.decimal)
                                ? this.parseExprAtom()
                                : this.parseMaybePrivateName(e)),
                        "PrivateName" !== t.key.type && (t.computed = !1),
                        (this.state.inPropertyName = n);
                }
                return t.key;
            }
            initFunction(t, e) {
                (t.id = null), (t.generator = !1), (t.async = !!e);
            }
            parseMethod(t, e, n, r, s, i, o = !1) {
                const a = this.state.yieldPos,
                    c = this.state.awaitPos;
                (this.state.yieldPos = -1),
                    (this.state.awaitPos = -1),
                    this.initFunction(t, n),
                    (t.generator = !!e);
                const l = r;
                return (
                    this.scope.enter(18 | (o ? 64 : 0) | (s ? 32 : 0)),
                    this.prodParam.enter(ut(n, t.generator)),
                    this.parseFunctionParams(t, l),
                    this.parseFunctionBodyAndFinish(t, i, !0),
                    this.prodParam.exit(),
                    this.scope.exit(),
                    (this.state.yieldPos = a),
                    (this.state.awaitPos = c),
                    t
                );
            }
            parseArrayLike(t, e, n, r) {
                n && this.expectPlugin("recordAndTuple");
                const s = this.state.inFSharpPipelineDirectBody;
                this.state.inFSharpPipelineDirectBody = !1;
                const i = this.startNode();
                return (
                    this.next(),
                    (i.elements = this.parseExprList(t, !n, r, i)),
                    e &&
                        !this.state.maybeInArrowParameters &&
                        this.toReferencedList(i.elements),
                    (this.state.inFSharpPipelineDirectBody = s),
                    this.finishNode(
                        i,
                        n ? "TupleExpression" : "ArrayExpression"
                    )
                );
            }
            parseArrowExpression(t, e, n, r) {
                this.scope.enter(6);
                let s = ut(n, !1);
                !this.match(h.bracketL) && this.prodParam.hasIn && (s |= 8),
                    this.prodParam.enter(s),
                    this.initFunction(t, n);
                const i = this.state.maybeInArrowParameters,
                    o = this.state.yieldPos,
                    a = this.state.awaitPos;
                return (
                    e &&
                        ((this.state.maybeInArrowParameters = !0),
                        this.setArrowFunctionParameters(t, e, r)),
                    (this.state.maybeInArrowParameters = !1),
                    (this.state.yieldPos = -1),
                    (this.state.awaitPos = -1),
                    this.parseFunctionBody(t, !0),
                    this.prodParam.exit(),
                    this.scope.exit(),
                    (this.state.maybeInArrowParameters = i),
                    (this.state.yieldPos = o),
                    (this.state.awaitPos = a),
                    this.finishNode(t, "ArrowFunctionExpression")
                );
            }
            setArrowFunctionParameters(t, e, n) {
                t.params = this.toAssignableList(e, n);
            }
            parseFunctionBodyAndFinish(t, e, n = !1) {
                this.parseFunctionBody(t, !1, n), this.finishNode(t, e);
            }
            parseFunctionBody(t, e, n = !1) {
                const r = e && !this.match(h.braceL),
                    s = this.state.inParameters;
                if (((this.state.inParameters = !1), r))
                    (t.body = this.parseMaybeAssignAllowIn()),
                        this.checkParams(t, !1, e, !1);
                else {
                    const r = this.state.strict,
                        s = this.state.labels;
                    (this.state.labels = []),
                        this.prodParam.enter(4 | this.prodParam.currentFlags()),
                        (t.body = this.parseBlock(!0, !1, (s) => {
                            const i = !this.isSimpleParamList(t.params);
                            if (s && i) {
                                const e =
                                    ("method" !== t.kind &&
                                        "constructor" !== t.kind) ||
                                    !t.key
                                        ? t.start
                                        : t.key.end;
                                this.raise(e, E.IllegalLanguageModeDirective);
                            }
                            const o = !r && this.state.strict;
                            this.checkParams(
                                t,
                                !(this.state.strict || e || n || i),
                                e,
                                o
                            ),
                                this.state.strict &&
                                    t.id &&
                                    this.checkLVal(
                                        t.id,
                                        65,
                                        void 0,
                                        "function name",
                                        void 0,
                                        o
                                    );
                        })),
                        this.prodParam.exit(),
                        (this.state.labels = s);
                }
                this.state.inParameters = s;
            }
            isSimpleParamList(t) {
                for (let e = 0, n = t.length; e < n; e++)
                    if ("Identifier" !== t[e].type) return !1;
                return !0;
            }
            checkParams(t, e, n, r = !0) {
                const s = Object.create(null);
                for (let n = 0; n < t.params.length; n++)
                    this.checkLVal(
                        t.params[n],
                        5,
                        e ? null : s,
                        "function parameter list",
                        void 0,
                        r
                    );
            }
            parseExprList(t, e, n, r) {
                const s = [];
                let i = !0;
                for (; !this.eat(t); ) {
                    if (i) i = !1;
                    else if ((this.expect(h.comma), this.match(t))) {
                        r &&
                            this.addExtra(
                                r,
                                "trailingComma",
                                this.state.lastTokStart
                            ),
                            this.next();
                        break;
                    }
                    s.push(this.parseExprListItem(e, n));
                }
                return s;
            }
            parseExprListItem(t, e, n, r) {
                let s;
                if (this.match(h.comma))
                    t || this.raise(this.state.pos, E.UnexpectedToken, ","),
                        (s = null);
                else if (this.match(h.ellipsis)) {
                    const t = this.state.start,
                        r = this.state.startLoc;
                    s = this.parseParenItem(this.parseSpread(e, n), t, r);
                } else if (this.match(h.question)) {
                    this.expectPlugin("partialApplication"),
                        r ||
                            this.raise(
                                this.state.start,
                                E.UnexpectedArgumentPlaceholder
                            );
                    const t = this.startNode();
                    this.next(),
                        (s = this.finishNode(t, "ArgumentPlaceholder"));
                } else
                    s = this.parseMaybeAssignAllowIn(e, this.parseParenItem, n);
                return s;
            }
            parseIdentifier(t) {
                const e = this.startNode(),
                    n = this.parseIdentifierName(e.start, t);
                return this.createIdentifier(e, n);
            }
            createIdentifier(t, e) {
                return (
                    (t.name = e),
                    (t.loc.identifierName = e),
                    this.finishNode(t, "Identifier")
                );
            }
            parseIdentifierName(t, e) {
                let n;
                const { start: r, type: s } = this.state;
                if (s === h.name) n = this.state.value;
                else {
                    if (!s.keyword) throw this.unexpected();
                    {
                        n = s.keyword;
                        const t = this.curContext();
                        (s !== h._class && s !== h._function) ||
                            (t !== C.functionStatement &&
                                t !== C.functionExpression) ||
                            this.state.context.pop();
                    }
                }
                return (
                    e
                        ? (this.state.type = h.name)
                        : this.checkReservedWord(n, r, !!s.keyword, !1),
                    this.next(),
                    n
                );
            }
            checkReservedWord(t, e, n, r) {
                if (this.prodParam.hasYield && "yield" === t)
                    return void this.raise(e, E.YieldBindingIdentifier);
                if ("await" === t) {
                    if (this.prodParam.hasAwait)
                        return void this.raise(e, E.AwaitBindingIdentifier);
                    -1 === this.state.awaitPos &&
                        (this.state.maybeInAsyncArrowHead ||
                            this.isAwaitAllowed()) &&
                        (this.state.awaitPos = this.state.start);
                }
                if (
                    this.scope.inClass &&
                    !this.scope.inNonArrowFunction &&
                    "arguments" === t
                )
                    return void this.raise(
                        e,
                        E.ArgumentsDisallowedInInitializer
                    );
                if (
                    n &&
                    (function (t) {
                        return B.has(t);
                    })(t)
                )
                    return void this.raise(e, E.UnexpectedKeyword, t);
                (this.state.strict ? (r ? H : $) : q)(t, this.inModule) &&
                    (this.prodParam.hasAwait || "await" !== t
                        ? this.raise(e, E.UnexpectedReservedWord, t)
                        : this.raise(e, E.AwaitNotInAsyncFunction));
            }
            isAwaitAllowed() {
                return this.scope.inFunction
                    ? this.prodParam.hasAwait
                    : !!this.options.allowAwaitOutsideFunction ||
                          (!!this.hasPlugin("topLevelAwait") &&
                              this.inModule &&
                              this.prodParam.hasAwait);
            }
            parseAwait() {
                const t = this.startNode();
                return (
                    this.next(),
                    this.state.inParameters
                        ? this.raise(t.start, E.AwaitExpressionFormalParameter)
                        : -1 === this.state.awaitPos &&
                          (this.state.awaitPos = t.start),
                    this.eat(h.star) &&
                        this.raise(t.start, E.ObsoleteAwaitStar),
                    this.scope.inFunction ||
                        this.options.allowAwaitOutsideFunction ||
                        (this.hasPrecedingLineBreak() ||
                        this.match(h.plusMin) ||
                        this.match(h.parenL) ||
                        this.match(h.bracketL) ||
                        this.match(h.backQuote) ||
                        this.match(h.regexp) ||
                        this.match(h.slash) ||
                        (this.hasPlugin("v8intrinsic") && this.match(h.modulo))
                            ? (this.ambiguousScriptDifferentAst = !0)
                            : (this.sawUnambiguousESM = !0)),
                    this.state.soloAwait ||
                        (t.argument = this.parseMaybeUnary()),
                    this.finishNode(t, "AwaitExpression")
                );
            }
            parseYield() {
                const t = this.startNode();
                return (
                    this.state.inParameters
                        ? this.raise(t.start, E.YieldInParameter)
                        : -1 === this.state.yieldPos &&
                          (this.state.yieldPos = t.start),
                    this.next(),
                    this.match(h.semi) ||
                    (!this.match(h.star) && !this.state.type.startsExpr) ||
                    this.hasPrecedingLineBreak()
                        ? ((t.delegate = !1), (t.argument = null))
                        : ((t.delegate = this.eat(h.star)),
                          (t.argument = this.parseMaybeAssign())),
                    this.finishNode(t, "YieldExpression")
                );
            }
            checkPipelineAtInfixOperator(t, e) {
                "smart" ===
                    this.getPluginOption("pipelineOperator", "proposal") &&
                    "SequenceExpression" === t.type &&
                    this.raise(e, E.PipelineHeadSequenceExpression);
            }
            parseSmartPipelineBody(t, e, n) {
                return (
                    this.checkSmartPipelineBodyEarlyErrors(t, e),
                    this.parseSmartPipelineBodyInStyle(t, e, n)
                );
            }
            checkSmartPipelineBodyEarlyErrors(t, e) {
                if (this.match(h.arrow))
                    throw this.raise(this.state.start, E.PipelineBodyNoArrow);
                "SequenceExpression" === t.type &&
                    this.raise(e, E.PipelineBodySequenceExpression);
            }
            parseSmartPipelineBodyInStyle(t, e, n) {
                const r = this.startNodeAt(e, n),
                    s = this.isSimpleReference(t);
                return (
                    s
                        ? (r.callee = t)
                        : (this.topicReferenceWasUsedInCurrentTopicContext() ||
                              this.raise(e, E.PipelineTopicUnused),
                          (r.expression = t)),
                    this.finishNode(
                        r,
                        s ? "PipelineBareFunction" : "PipelineTopicExpression"
                    )
                );
            }
            isSimpleReference(t) {
                switch (t.type) {
                    case "MemberExpression":
                        return !t.computed && this.isSimpleReference(t.object);
                    case "Identifier":
                        return !0;
                    default:
                        return !1;
                }
            }
            withTopicPermittingContext(t) {
                const e = this.state.topicContext;
                this.state.topicContext = {
                    maxNumOfResolvableTopics: 1,
                    maxTopicIndex: null,
                };
                try {
                    return t();
                } finally {
                    this.state.topicContext = e;
                }
            }
            withTopicForbiddingContext(t) {
                const e = this.state.topicContext;
                this.state.topicContext = {
                    maxNumOfResolvableTopics: 0,
                    maxTopicIndex: null,
                };
                try {
                    return t();
                } finally {
                    this.state.topicContext = e;
                }
            }
            withSoloAwaitPermittingContext(t) {
                const e = this.state.soloAwait;
                this.state.soloAwait = !0;
                try {
                    return t();
                } finally {
                    this.state.soloAwait = e;
                }
            }
            allowInAnd(t) {
                const e = this.prodParam.currentFlags();
                if (8 & ~e) {
                    this.prodParam.enter(8 | e);
                    try {
                        return t();
                    } finally {
                        this.prodParam.exit();
                    }
                }
                return t();
            }
            disallowInAnd(t) {
                const e = this.prodParam.currentFlags();
                if (8 & e) {
                    this.prodParam.enter(-9 & e);
                    try {
                        return t();
                    } finally {
                        this.prodParam.exit();
                    }
                }
                return t();
            }
            registerTopicReference() {
                this.state.topicContext.maxTopicIndex = 0;
            }
            primaryTopicReferenceIsAllowedInCurrentTopicContext() {
                return this.state.topicContext.maxNumOfResolvableTopics >= 1;
            }
            topicReferenceWasUsedInCurrentTopicContext() {
                return (
                    null != this.state.topicContext.maxTopicIndex &&
                    this.state.topicContext.maxTopicIndex >= 0
                );
            }
            parseFSharpPipelineBody(t) {
                const e = this.state.start,
                    n = this.state.startLoc;
                this.state.potentialArrowAt = this.state.start;
                const r = this.state.inFSharpPipelineDirectBody;
                this.state.inFSharpPipelineDirectBody = !0;
                const s = this.parseExprOp(this.parseMaybeUnary(), e, n, t);
                return (this.state.inFSharpPipelineDirectBody = r), s;
            }
        } {
            parseTopLevel(t, e) {
                if (
                    ((e.sourceType = this.options.sourceType),
                    (e.interpreter = this.parseInterpreterDirective()),
                    this.parseBlockBody(e, !0, !0, h.eof),
                    this.inModule &&
                        !this.options.allowUndeclaredExports &&
                        this.scope.undefinedExports.size > 0)
                )
                    for (
                        let t = 0, e = Array.from(this.scope.undefinedExports);
                        t < e.length;
                        t++
                    ) {
                        const [n] = e[t],
                            r = this.scope.undefinedExports.get(n);
                        this.raise(r, E.ModuleExportUndefined, n);
                    }
                return (
                    (t.program = this.finishNode(e, "Program")),
                    (t.comments = this.state.comments),
                    this.options.tokens && (t.tokens = this.tokens),
                    this.finishNode(t, "File")
                );
            }
            stmtToDirective(t) {
                const e = t.expression,
                    n = this.startNodeAt(e.start, e.loc.start),
                    r = this.startNodeAt(t.start, t.loc.start),
                    s = this.input.slice(e.start, e.end),
                    i = (n.value = s.slice(1, -1));
                return (
                    this.addExtra(n, "raw", s),
                    this.addExtra(n, "rawValue", i),
                    (r.value = this.finishNodeAt(
                        n,
                        "DirectiveLiteral",
                        e.end,
                        e.loc.end
                    )),
                    this.finishNodeAt(r, "Directive", t.end, t.loc.end)
                );
            }
            parseInterpreterDirective() {
                if (!this.match(h.interpreterDirective)) return null;
                const t = this.startNode();
                return (
                    (t.value = this.state.value),
                    this.next(),
                    this.finishNode(t, "InterpreterDirective")
                );
            }
            isLet(t) {
                if (!this.isContextual("let")) return !1;
                const e = this.nextTokenStart(),
                    n = this.input.charCodeAt(e);
                if (91 === n) return !0;
                if (t) return !1;
                if (123 === n) return !0;
                if (M(n)) {
                    let t = e + 1;
                    for (; R(this.input.charCodeAt(t)); ) ++t;
                    const n = this.input.slice(e, t);
                    if (!W.test(n)) return !0;
                }
                return !1;
            }
            parseStatement(t, e) {
                return (
                    this.match(h.at) && this.parseDecorators(!0),
                    this.parseStatementContent(t, e)
                );
            }
            parseStatementContent(t, e) {
                let n = this.state.type;
                const r = this.startNode();
                let s;
                switch ((this.isLet(t) && ((n = h._var), (s = "let")), n)) {
                    case h._break:
                    case h._continue:
                        return this.parseBreakContinueStatement(r, n.keyword);
                    case h._debugger:
                        return this.parseDebuggerStatement(r);
                    case h._do:
                        return this.parseDoStatement(r);
                    case h._for:
                        return this.parseForStatement(r);
                    case h._function:
                        if (46 === this.lookaheadCharCode()) break;
                        return (
                            t &&
                                (this.state.strict
                                    ? this.raise(
                                          this.state.start,
                                          E.StrictFunction
                                      )
                                    : "if" !== t &&
                                      "label" !== t &&
                                      this.raise(
                                          this.state.start,
                                          E.SloppyFunction
                                      )),
                            this.parseFunctionStatement(r, !1, !t)
                        );
                    case h._class:
                        return t && this.unexpected(), this.parseClass(r, !0);
                    case h._if:
                        return this.parseIfStatement(r);
                    case h._return:
                        return this.parseReturnStatement(r);
                    case h._switch:
                        return this.parseSwitchStatement(r);
                    case h._throw:
                        return this.parseThrowStatement(r);
                    case h._try:
                        return this.parseTryStatement(r);
                    case h._const:
                    case h._var:
                        return (
                            (s = s || this.state.value),
                            t &&
                                "var" !== s &&
                                this.raise(
                                    this.state.start,
                                    E.UnexpectedLexicalDeclaration
                                ),
                            this.parseVarStatement(r, s)
                        );
                    case h._while:
                        return this.parseWhileStatement(r);
                    case h._with:
                        return this.parseWithStatement(r);
                    case h.braceL:
                        return this.parseBlock();
                    case h.semi:
                        return this.parseEmptyStatement(r);
                    case h._import: {
                        const t = this.lookaheadCharCode();
                        if (40 === t || 46 === t) break;
                    }
                    case h._export: {
                        let t;
                        return (
                            this.options.allowImportExportEverywhere ||
                                e ||
                                this.raise(
                                    this.state.start,
                                    E.UnexpectedImportExport
                                ),
                            this.next(),
                            n === h._import
                                ? ((t = this.parseImport(r)),
                                  "ImportDeclaration" !== t.type ||
                                      (t.importKind &&
                                          "value" !== t.importKind) ||
                                      (this.sawUnambiguousESM = !0))
                                : ((t = this.parseExport(r)),
                                  (("ExportNamedDeclaration" !== t.type ||
                                      (t.exportKind &&
                                          "value" !== t.exportKind)) &&
                                      ("ExportAllDeclaration" !== t.type ||
                                          (t.exportKind &&
                                              "value" !== t.exportKind)) &&
                                      "ExportDefaultDeclaration" !== t.type) ||
                                      (this.sawUnambiguousESM = !0)),
                            this.assertModuleNodeAllowed(r),
                            t
                        );
                    }
                    default:
                        if (this.isAsyncFunction())
                            return (
                                t &&
                                    this.raise(
                                        this.state.start,
                                        E.AsyncFunctionInSingleStatementContext
                                    ),
                                this.next(),
                                this.parseFunctionStatement(r, !0, !t)
                            );
                }
                const i = this.state.value,
                    o = this.parseExpression();
                return n === h.name &&
                    "Identifier" === o.type &&
                    this.eat(h.colon)
                    ? this.parseLabeledStatement(r, i, o, t)
                    : this.parseExpressionStatement(r, o);
            }
            assertModuleNodeAllowed(t) {
                this.options.allowImportExportEverywhere ||
                    this.inModule ||
                    this.raiseWithData(
                        t.start,
                        { code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" },
                        E.ImportOutsideModule
                    );
            }
            takeDecorators(t) {
                const e =
                    this.state.decoratorStack[
                        this.state.decoratorStack.length - 1
                    ];
                e.length &&
                    ((t.decorators = e),
                    this.resetStartLocationFromNode(t, e[0]),
                    (this.state.decoratorStack[
                        this.state.decoratorStack.length - 1
                    ] = []));
            }
            canHaveLeadingDecorator() {
                return this.match(h._class);
            }
            parseDecorators(t) {
                const e =
                    this.state.decoratorStack[
                        this.state.decoratorStack.length - 1
                    ];
                for (; this.match(h.at); ) {
                    const t = this.parseDecorator();
                    e.push(t);
                }
                if (this.match(h._export))
                    t || this.unexpected(),
                        this.hasPlugin("decorators") &&
                            !this.getPluginOption(
                                "decorators",
                                "decoratorsBeforeExport"
                            ) &&
                            this.raise(
                                this.state.start,
                                E.DecoratorExportClass
                            );
                else if (!this.canHaveLeadingDecorator())
                    throw this.raise(
                        this.state.start,
                        E.UnexpectedLeadingDecorator
                    );
            }
            parseDecorator() {
                this.expectOnePlugin(["decorators-legacy", "decorators"]);
                const t = this.startNode();
                if ((this.next(), this.hasPlugin("decorators"))) {
                    this.state.decoratorStack.push([]);
                    const e = this.state.start,
                        n = this.state.startLoc;
                    let r;
                    if (this.eat(h.parenL))
                        (r = this.parseExpression()), this.expect(h.parenR);
                    else
                        for (r = this.parseIdentifier(!1); this.eat(h.dot); ) {
                            const t = this.startNodeAt(e, n);
                            (t.object = r),
                                (t.property = this.parseIdentifier(!0)),
                                (t.computed = !1),
                                (r = this.finishNode(t, "MemberExpression"));
                        }
                    (t.expression = this.parseMaybeDecoratorArguments(r)),
                        this.state.decoratorStack.pop();
                } else t.expression = this.parseExprSubscripts();
                return this.finishNode(t, "Decorator");
            }
            parseMaybeDecoratorArguments(t) {
                if (this.eat(h.parenL)) {
                    const e = this.startNodeAtNode(t);
                    return (
                        (e.callee = t),
                        (e.arguments = this.parseCallExpressionArguments(
                            h.parenR,
                            !1
                        )),
                        this.toReferencedList(e.arguments),
                        this.finishNode(e, "CallExpression")
                    );
                }
                return t;
            }
            parseBreakContinueStatement(t, e) {
                const n = "break" === e;
                return (
                    this.next(),
                    this.isLineTerminator()
                        ? (t.label = null)
                        : ((t.label = this.parseIdentifier()),
                          this.semicolon()),
                    this.verifyBreakContinue(t, e),
                    this.finishNode(
                        t,
                        n ? "BreakStatement" : "ContinueStatement"
                    )
                );
            }
            verifyBreakContinue(t, e) {
                const n = "break" === e;
                let r;
                for (r = 0; r < this.state.labels.length; ++r) {
                    const e = this.state.labels[r];
                    if (null == t.label || e.name === t.label.name) {
                        if (null != e.kind && (n || "loop" === e.kind)) break;
                        if (t.label && n) break;
                    }
                }
                r === this.state.labels.length &&
                    this.raise(t.start, E.IllegalBreakContinue, e);
            }
            parseDebuggerStatement(t) {
                return (
                    this.next(),
                    this.semicolon(),
                    this.finishNode(t, "DebuggerStatement")
                );
            }
            parseHeaderExpression() {
                this.expect(h.parenL);
                const t = this.parseExpression();
                return this.expect(h.parenR), t;
            }
            parseDoStatement(t) {
                return (
                    this.next(),
                    this.state.labels.push(_t),
                    (t.body = this.withTopicForbiddingContext(() =>
                        this.parseStatement("do")
                    )),
                    this.state.labels.pop(),
                    this.expect(h._while),
                    (t.test = this.parseHeaderExpression()),
                    this.eat(h.semi),
                    this.finishNode(t, "DoWhileStatement")
                );
            }
            parseForStatement(t) {
                this.next(), this.state.labels.push(_t);
                let e = -1;
                if (
                    (this.isAwaitAllowed() &&
                        this.eatContextual("await") &&
                        (e = this.state.lastTokStart),
                    this.scope.enter(0),
                    this.expect(h.parenL),
                    this.match(h.semi))
                )
                    return e > -1 && this.unexpected(e), this.parseFor(t, null);
                const n = this.isLet();
                if (this.match(h._var) || this.match(h._const) || n) {
                    const r = this.startNode(),
                        s = n ? "let" : this.state.value;
                    return (
                        this.next(),
                        this.parseVar(r, !0, s),
                        this.finishNode(r, "VariableDeclaration"),
                        (this.match(h._in) || this.isContextual("of")) &&
                        1 === r.declarations.length
                            ? this.parseForIn(t, r, e)
                            : (e > -1 && this.unexpected(e),
                              this.parseFor(t, r))
                    );
                }
                const r = new Ct(),
                    s = this.parseExpression(!0, r);
                if (this.match(h._in) || this.isContextual("of")) {
                    this.toAssignable(s);
                    const n = this.isContextual("of")
                        ? "for-of statement"
                        : "for-in statement";
                    return (
                        this.checkLVal(s, void 0, void 0, n),
                        this.parseForIn(t, s, e)
                    );
                }
                return (
                    this.checkExpressionErrors(r, !0),
                    e > -1 && this.unexpected(e),
                    this.parseFor(t, s)
                );
            }
            parseFunctionStatement(t, e, n) {
                return this.next(), this.parseFunction(t, 1 | (n ? 0 : 2), e);
            }
            parseIfStatement(t) {
                return (
                    this.next(),
                    (t.test = this.parseHeaderExpression()),
                    (t.consequent = this.parseStatement("if")),
                    (t.alternate = this.eat(h._else)
                        ? this.parseStatement("if")
                        : null),
                    this.finishNode(t, "IfStatement")
                );
            }
            parseReturnStatement(t) {
                return (
                    this.prodParam.hasReturn ||
                        this.options.allowReturnOutsideFunction ||
                        this.raise(this.state.start, E.IllegalReturn),
                    this.next(),
                    this.isLineTerminator()
                        ? (t.argument = null)
                        : ((t.argument = this.parseExpression()),
                          this.semicolon()),
                    this.finishNode(t, "ReturnStatement")
                );
            }
            parseSwitchStatement(t) {
                this.next(), (t.discriminant = this.parseHeaderExpression());
                const e = (t.cases = []);
                let n, r;
                for (
                    this.expect(h.braceL),
                        this.state.labels.push(Nt),
                        this.scope.enter(0);
                    !this.match(h.braceR);

                )
                    if (this.match(h._case) || this.match(h._default)) {
                        const t = this.match(h._case);
                        n && this.finishNode(n, "SwitchCase"),
                            e.push((n = this.startNode())),
                            (n.consequent = []),
                            this.next(),
                            t
                                ? (n.test = this.parseExpression())
                                : (r &&
                                      this.raise(
                                          this.state.lastTokStart,
                                          E.MultipleDefaultsInSwitch
                                      ),
                                  (r = !0),
                                  (n.test = null)),
                            this.expect(h.colon);
                    } else
                        n
                            ? n.consequent.push(this.parseStatement(null))
                            : this.unexpected();
                return (
                    this.scope.exit(),
                    n && this.finishNode(n, "SwitchCase"),
                    this.next(),
                    this.state.labels.pop(),
                    this.finishNode(t, "SwitchStatement")
                );
            }
            parseThrowStatement(t) {
                return (
                    this.next(),
                    this.hasPrecedingLineBreak() &&
                        this.raise(this.state.lastTokEnd, E.NewlineAfterThrow),
                    (t.argument = this.parseExpression()),
                    this.semicolon(),
                    this.finishNode(t, "ThrowStatement")
                );
            }
            parseCatchClauseParam() {
                const t = this.parseBindingAtom(),
                    e = "Identifier" === t.type;
                return (
                    this.scope.enter(e ? 8 : 0),
                    this.checkLVal(t, 9, null, "catch clause"),
                    t
                );
            }
            parseTryStatement(t) {
                if (
                    (this.next(),
                    (t.block = this.parseBlock()),
                    (t.handler = null),
                    this.match(h._catch))
                ) {
                    const e = this.startNode();
                    this.next(),
                        this.match(h.parenL)
                            ? (this.expect(h.parenL),
                              (e.param = this.parseCatchClauseParam()),
                              this.expect(h.parenR))
                            : ((e.param = null), this.scope.enter(0)),
                        (e.body = this.withTopicForbiddingContext(() =>
                            this.parseBlock(!1, !1)
                        )),
                        this.scope.exit(),
                        (t.handler = this.finishNode(e, "CatchClause"));
                }
                return (
                    (t.finalizer = this.eat(h._finally)
                        ? this.parseBlock()
                        : null),
                    t.handler ||
                        t.finalizer ||
                        this.raise(t.start, E.NoCatchOrFinally),
                    this.finishNode(t, "TryStatement")
                );
            }
            parseVarStatement(t, e) {
                return (
                    this.next(),
                    this.parseVar(t, !1, e),
                    this.semicolon(),
                    this.finishNode(t, "VariableDeclaration")
                );
            }
            parseWhileStatement(t) {
                return (
                    this.next(),
                    (t.test = this.parseHeaderExpression()),
                    this.state.labels.push(_t),
                    (t.body = this.withTopicForbiddingContext(() =>
                        this.parseStatement("while")
                    )),
                    this.state.labels.pop(),
                    this.finishNode(t, "WhileStatement")
                );
            }
            parseWithStatement(t) {
                return (
                    this.state.strict &&
                        this.raise(this.state.start, E.StrictWith),
                    this.next(),
                    (t.object = this.parseHeaderExpression()),
                    (t.body = this.withTopicForbiddingContext(() =>
                        this.parseStatement("with")
                    )),
                    this.finishNode(t, "WithStatement")
                );
            }
            parseEmptyStatement(t) {
                return this.next(), this.finishNode(t, "EmptyStatement");
            }
            parseLabeledStatement(t, e, n, r) {
                for (let t = 0, r = this.state.labels; t < r.length; t++) {
                    r[t].name === e &&
                        this.raise(n.start, E.LabelRedeclaration, e);
                }
                const s = this.state.type.isLoop
                    ? "loop"
                    : this.match(h._switch)
                    ? "switch"
                    : null;
                for (let e = this.state.labels.length - 1; e >= 0; e--) {
                    const n = this.state.labels[e];
                    if (n.statementStart !== t.start) break;
                    (n.statementStart = this.state.start), (n.kind = s);
                }
                return (
                    this.state.labels.push({
                        name: e,
                        kind: s,
                        statementStart: this.state.start,
                    }),
                    (t.body = this.parseStatement(
                        r
                            ? -1 === r.indexOf("label")
                                ? r + "label"
                                : r
                            : "label"
                    )),
                    this.state.labels.pop(),
                    (t.label = n),
                    this.finishNode(t, "LabeledStatement")
                );
            }
            parseExpressionStatement(t, e) {
                return (
                    (t.expression = e),
                    this.semicolon(),
                    this.finishNode(t, "ExpressionStatement")
                );
            }
            parseBlock(t = !1, e = !0, n) {
                const r = this.startNode();
                return (
                    this.expect(h.braceL),
                    e && this.scope.enter(0),
                    this.parseBlockBody(r, t, !1, h.braceR, n),
                    e && this.scope.exit(),
                    this.finishNode(r, "BlockStatement")
                );
            }
            isValidDirective(t) {
                return (
                    "ExpressionStatement" === t.type &&
                    "StringLiteral" === t.expression.type &&
                    !t.expression.extra.parenthesized
                );
            }
            parseBlockBody(t, e, n, r, s) {
                const i = (t.body = []),
                    o = (t.directives = []);
                this.parseBlockOrModuleBlockBody(i, e ? o : void 0, n, r, s);
            }
            parseBlockOrModuleBlockBody(t, e, n, r, s) {
                const i = [],
                    o = this.state.strict;
                let a = !1,
                    c = !1;
                for (; !this.match(r); ) {
                    !c &&
                        this.state.octalPositions.length &&
                        i.push(...this.state.octalPositions);
                    const r = this.parseStatement(null, n);
                    if (e && !c && this.isValidDirective(r)) {
                        const t = this.stmtToDirective(r);
                        e.push(t),
                            a ||
                                "use strict" !== t.value.value ||
                                ((a = !0), this.setStrict(!0));
                    } else (c = !0), t.push(r);
                }
                if (this.state.strict && i.length)
                    for (let t = 0; t < i.length; t++) {
                        const e = i[t];
                        this.raise(e, E.StrictOctalLiteral);
                    }
                s && s.call(this, a), o || this.setStrict(!1), this.next();
            }
            parseFor(t, e) {
                return (
                    (t.init = e),
                    this.expect(h.semi),
                    (t.test = this.match(h.semi)
                        ? null
                        : this.parseExpression()),
                    this.expect(h.semi),
                    (t.update = this.match(h.parenR)
                        ? null
                        : this.parseExpression()),
                    this.expect(h.parenR),
                    (t.body = this.withTopicForbiddingContext(() =>
                        this.parseStatement("for")
                    )),
                    this.scope.exit(),
                    this.state.labels.pop(),
                    this.finishNode(t, "ForStatement")
                );
            }
            parseForIn(t, e, n) {
                const r = this.match(h._in);
                return (
                    this.next(),
                    r ? n > -1 && this.unexpected(n) : (t.await = n > -1),
                    "VariableDeclaration" !== e.type ||
                    null == e.declarations[0].init ||
                    (r &&
                        !this.state.strict &&
                        "var" === e.kind &&
                        "Identifier" === e.declarations[0].id.type)
                        ? "AssignmentPattern" === e.type &&
                          this.raise(e.start, E.InvalidLhs, "for-loop")
                        : this.raise(
                              e.start,
                              E.ForInOfLoopInitializer,
                              r ? "for-in" : "for-of"
                          ),
                    (t.left = e),
                    (t.right = r
                        ? this.parseExpression()
                        : this.parseMaybeAssignAllowIn()),
                    this.expect(h.parenR),
                    (t.body = this.withTopicForbiddingContext(() =>
                        this.parseStatement("for")
                    )),
                    this.scope.exit(),
                    this.state.labels.pop(),
                    this.finishNode(t, r ? "ForInStatement" : "ForOfStatement")
                );
            }
            parseVar(t, e, n) {
                const r = (t.declarations = []),
                    s = this.hasPlugin("typescript");
                for (t.kind = n; ; ) {
                    const t = this.startNode();
                    if (
                        (this.parseVarId(t, n),
                        this.eat(h.eq)
                            ? (t.init = e
                                  ? this.parseMaybeAssignDisallowIn()
                                  : this.parseMaybeAssignAllowIn())
                            : ("const" !== n ||
                              this.match(h._in) ||
                              this.isContextual("of")
                                  ? "Identifier" === t.id.type ||
                                    (e &&
                                        (this.match(h._in) ||
                                            this.isContextual("of"))) ||
                                    this.raise(
                                        this.state.lastTokEnd,
                                        E.DeclarationMissingInitializer,
                                        "Complex binding patterns"
                                    )
                                  : s || this.unexpected(),
                              (t.init = null)),
                        r.push(this.finishNode(t, "VariableDeclarator")),
                        !this.eat(h.comma))
                    )
                        break;
                }
                return t;
            }
            parseVarId(t, e) {
                (t.id = this.parseBindingAtom()),
                    this.checkLVal(
                        t.id,
                        "var" === e ? 5 : 9,
                        void 0,
                        "variable declaration",
                        "var" !== e
                    );
            }
            parseFunction(t, e = 0, n = !1) {
                const r = 1 & e,
                    s = 2 & e,
                    i = !(!r || 4 & e);
                this.initFunction(t, n),
                    this.match(h.star) &&
                        s &&
                        this.raise(
                            this.state.start,
                            E.GeneratorInSingleStatementContext
                        ),
                    (t.generator = this.eat(h.star)),
                    r && (t.id = this.parseFunctionId(i));
                const o = this.state.maybeInArrowParameters,
                    a = this.state.yieldPos,
                    c = this.state.awaitPos;
                return (
                    (this.state.maybeInArrowParameters = !1),
                    (this.state.yieldPos = -1),
                    (this.state.awaitPos = -1),
                    this.scope.enter(2),
                    this.prodParam.enter(ut(n, t.generator)),
                    r || (t.id = this.parseFunctionId()),
                    this.parseFunctionParams(t),
                    this.withTopicForbiddingContext(() => {
                        this.parseFunctionBodyAndFinish(
                            t,
                            r ? "FunctionDeclaration" : "FunctionExpression"
                        );
                    }),
                    this.prodParam.exit(),
                    this.scope.exit(),
                    r && !s && this.registerFunctionStatementId(t),
                    (this.state.maybeInArrowParameters = o),
                    (this.state.yieldPos = a),
                    (this.state.awaitPos = c),
                    t
                );
            }
            parseFunctionId(t) {
                return t || this.match(h.name) ? this.parseIdentifier() : null;
            }
            parseFunctionParams(t, e) {
                const n = this.state.inParameters;
                (this.state.inParameters = !0),
                    this.expect(h.parenL),
                    (t.params = this.parseBindingList(h.parenR, 41, !1, e)),
                    (this.state.inParameters = n),
                    this.checkYieldAwaitInDefaultParams();
            }
            registerFunctionStatementId(t) {
                t.id &&
                    this.scope.declareName(
                        t.id.name,
                        this.state.strict || t.generator || t.async
                            ? this.scope.treatFunctionsAsVar
                                ? 5
                                : 9
                            : 17,
                        t.id.start
                    );
            }
            parseClass(t, e, n) {
                this.next(), this.takeDecorators(t);
                const r = this.state.strict;
                return (
                    (this.state.strict = !0),
                    this.parseClassId(t, e, n),
                    this.parseClassSuper(t),
                    (t.body = this.parseClassBody(!!t.superClass, r)),
                    this.finishNode(
                        t,
                        e ? "ClassDeclaration" : "ClassExpression"
                    )
                );
            }
            isClassProperty() {
                return (
                    this.match(h.eq) ||
                    this.match(h.semi) ||
                    this.match(h.braceR)
                );
            }
            isClassMethod() {
                return this.match(h.parenL);
            }
            isNonstaticConstructor(t) {
                return !(
                    t.computed ||
                    t.static ||
                    ("constructor" !== t.key.name &&
                        "constructor" !== t.key.value)
                );
            }
            parseClassBody(t, e) {
                this.classScope.enter();
                const n = { hadConstructor: !1 };
                let r = [];
                const s = this.startNode();
                if (
                    ((s.body = []),
                    this.expect(h.braceL),
                    this.withTopicForbiddingContext(() => {
                        for (; !this.match(h.braceR); ) {
                            if (this.eat(h.semi)) {
                                if (r.length > 0)
                                    throw this.raise(
                                        this.state.lastTokEnd,
                                        E.DecoratorSemicolon
                                    );
                                continue;
                            }
                            if (this.match(h.at)) {
                                r.push(this.parseDecorator());
                                continue;
                            }
                            const e = this.startNode();
                            r.length &&
                                ((e.decorators = r),
                                this.resetStartLocationFromNode(e, r[0]),
                                (r = [])),
                                this.parseClassMember(s, e, n, t),
                                "constructor" === e.kind &&
                                    e.decorators &&
                                    e.decorators.length > 0 &&
                                    this.raise(e.start, E.DecoratorConstructor);
                        }
                    }),
                    (this.state.strict = e),
                    this.next(),
                    r.length)
                )
                    throw this.raise(this.state.start, E.TrailingDecorator);
                return this.classScope.exit(), this.finishNode(s, "ClassBody");
            }
            parseClassMemberFromModifier(t, e) {
                const n = this.parseIdentifier(!0);
                if (this.isClassMethod()) {
                    const r = e;
                    return (
                        (r.kind = "method"),
                        (r.computed = !1),
                        (r.key = n),
                        (r.static = !1),
                        this.pushClassMethod(t, r, !1, !1, !1, !1),
                        !0
                    );
                }
                if (this.isClassProperty()) {
                    const r = e;
                    return (
                        (r.computed = !1),
                        (r.key = n),
                        (r.static = !1),
                        t.body.push(this.parseClassProperty(r)),
                        !0
                    );
                }
                return !1;
            }
            parseClassMember(t, e, n, r) {
                const s = this.isContextual("static");
                (s && this.parseClassMemberFromModifier(t, e)) ||
                    this.parseClassMemberWithIsStatic(t, e, n, s, r);
            }
            parseClassMemberWithIsStatic(t, e, n, r, s) {
                const i = e,
                    o = e,
                    a = e,
                    c = e,
                    l = i,
                    u = i;
                if (((e.static = r), this.eat(h.star)))
                    return (
                        (l.kind = "method"),
                        this.parseClassElementName(l),
                        "PrivateName" === l.key.type
                            ? void this.pushClassPrivateMethod(t, o, !0, !1)
                            : (this.isNonstaticConstructor(i) &&
                                  this.raise(
                                      i.key.start,
                                      E.ConstructorIsGenerator
                                  ),
                              void this.pushClassMethod(t, i, !0, !1, !1, !1))
                    );
                const p = this.state.containsEsc,
                    d = this.parseClassElementName(e),
                    f = "PrivateName" === d.type,
                    m = "Identifier" === d.type,
                    y = this.state.start;
                if (
                    (this.parsePostMemberNameModifiers(u), this.isClassMethod())
                ) {
                    if (((l.kind = "method"), f))
                        return void this.pushClassPrivateMethod(t, o, !1, !1);
                    const e = this.isNonstaticConstructor(i);
                    let r = !1;
                    e &&
                        ((i.kind = "constructor"),
                        n.hadConstructor &&
                            !this.hasPlugin("typescript") &&
                            this.raise(d.start, E.DuplicateConstructor),
                        (n.hadConstructor = !0),
                        (r = s)),
                        this.pushClassMethod(t, i, !1, !1, e, r);
                } else if (this.isClassProperty())
                    f
                        ? this.pushClassPrivateProperty(t, c)
                        : this.pushClassProperty(t, a);
                else if (
                    !m ||
                    "async" !== d.name ||
                    p ||
                    this.isLineTerminator()
                )
                    !m ||
                    ("get" !== d.name && "set" !== d.name) ||
                    p ||
                    (this.match(h.star) && this.isLineTerminator())
                        ? this.isLineTerminator()
                            ? f
                                ? this.pushClassPrivateProperty(t, c)
                                : this.pushClassProperty(t, a)
                            : this.unexpected()
                        : ((l.kind = d.name),
                          this.parseClassElementName(i),
                          "PrivateName" === l.key.type
                              ? this.pushClassPrivateMethod(t, o, !1, !1)
                              : (this.isNonstaticConstructor(i) &&
                                    this.raise(
                                        i.key.start,
                                        E.ConstructorIsAccessor
                                    ),
                                this.pushClassMethod(t, i, !1, !1, !1, !1)),
                          this.checkGetterSetterParams(i));
                else {
                    const e = this.eat(h.star);
                    u.optional && this.unexpected(y),
                        (l.kind = "method"),
                        this.parseClassElementName(l),
                        this.parsePostMemberNameModifiers(u),
                        "PrivateName" === l.key.type
                            ? this.pushClassPrivateMethod(t, o, e, !0)
                            : (this.isNonstaticConstructor(i) &&
                                  this.raise(i.key.start, E.ConstructorIsAsync),
                              this.pushClassMethod(t, i, e, !0, !1, !1));
                }
            }
            parseClassElementName(t) {
                const e = this.parsePropertyName(t, !0);
                return (
                    t.computed ||
                        !t.static ||
                        ("prototype" !== e.name && "prototype" !== e.value) ||
                        this.raise(e.start, E.StaticPrototype),
                    "PrivateName" === e.type &&
                        "constructor" === e.id.name &&
                        this.raise(e.start, E.ConstructorClassPrivateField),
                    e
                );
            }
            pushClassProperty(t, e) {
                e.computed ||
                    ("constructor" !== e.key.name &&
                        "constructor" !== e.key.value) ||
                    this.raise(e.key.start, E.ConstructorClassField),
                    t.body.push(this.parseClassProperty(e));
            }
            pushClassPrivateProperty(t, e) {
                this.expectPlugin("classPrivateProperties", e.key.start);
                const n = this.parseClassPrivateProperty(e);
                t.body.push(n),
                    this.classScope.declarePrivateName(
                        n.key.id.name,
                        0,
                        n.key.start
                    );
            }
            pushClassMethod(t, e, n, r, s, i) {
                t.body.push(this.parseMethod(e, n, r, s, i, "ClassMethod", !0));
            }
            pushClassPrivateMethod(t, e, n, r) {
                this.expectPlugin("classPrivateMethods", e.key.start);
                const s = this.parseMethod(
                    e,
                    n,
                    r,
                    !1,
                    !1,
                    "ClassPrivateMethod",
                    !0
                );
                t.body.push(s);
                const i =
                    "get" === s.kind
                        ? s.static
                            ? 6
                            : 2
                        : "set" === s.kind
                        ? s.static
                            ? 5
                            : 1
                        : 0;
                this.classScope.declarePrivateName(
                    s.key.id.name,
                    i,
                    s.key.start
                );
            }
            parsePostMemberNameModifiers(t) {}
            parseClassPrivateProperty(t) {
                return (
                    this.scope.enter(80),
                    this.prodParam.enter(0),
                    (t.value = this.eat(h.eq)
                        ? this.parseMaybeAssignAllowIn()
                        : null),
                    this.semicolon(),
                    this.prodParam.exit(),
                    this.scope.exit(),
                    this.finishNode(t, "ClassPrivateProperty")
                );
            }
            parseClassProperty(t) {
                return (
                    t.typeAnnotation || this.expectPlugin("classProperties"),
                    this.scope.enter(80),
                    this.prodParam.enter(0),
                    this.match(h.eq)
                        ? (this.expectPlugin("classProperties"),
                          this.next(),
                          (t.value = this.parseMaybeAssignAllowIn()))
                        : (t.value = null),
                    this.semicolon(),
                    this.prodParam.exit(),
                    this.scope.exit(),
                    this.finishNode(t, "ClassProperty")
                );
            }
            parseClassId(t, e, n, r = 139) {
                this.match(h.name)
                    ? ((t.id = this.parseIdentifier()),
                      e && this.checkLVal(t.id, r, void 0, "class name"))
                    : n || !e
                    ? (t.id = null)
                    : this.unexpected(null, E.MissingClassName);
            }
            parseClassSuper(t) {
                t.superClass = this.eat(h._extends)
                    ? this.parseExprSubscripts()
                    : null;
            }
            parseExport(t) {
                const e = this.maybeParseExportDefaultSpecifier(t),
                    n = !e || this.eat(h.comma),
                    r = n && this.eatExportStar(t),
                    s = r && this.maybeParseExportNamespaceSpecifier(t),
                    i = n && (!s || this.eat(h.comma)),
                    o = e || r;
                if (r && !s)
                    return (
                        e && this.unexpected(),
                        this.parseExportFrom(t, !0),
                        this.finishNode(t, "ExportAllDeclaration")
                    );
                const a = this.maybeParseExportNamedSpecifiers(t);
                if ((e && n && !r && !a) || (s && i && !a))
                    throw this.unexpected(null, h.braceL);
                let c;
                if (
                    (o || a
                        ? ((c = !1), this.parseExportFrom(t, o))
                        : (c = this.maybeParseExportDeclaration(t)),
                    o || a || c)
                )
                    return (
                        this.checkExport(t, !0, !1, !!t.source),
                        this.finishNode(t, "ExportNamedDeclaration")
                    );
                if (this.eat(h._default))
                    return (
                        (t.declaration = this.parseExportDefaultExpression()),
                        this.checkExport(t, !0, !0),
                        this.finishNode(t, "ExportDefaultDeclaration")
                    );
                throw this.unexpected(null, h.braceL);
            }
            eatExportStar(t) {
                return this.eat(h.star);
            }
            maybeParseExportDefaultSpecifier(t) {
                if (this.isExportDefaultSpecifier()) {
                    this.expectPlugin("exportDefaultFrom");
                    const e = this.startNode();
                    return (
                        (e.exported = this.parseIdentifier(!0)),
                        (t.specifiers = [
                            this.finishNode(e, "ExportDefaultSpecifier"),
                        ]),
                        !0
                    );
                }
                return !1;
            }
            maybeParseExportNamespaceSpecifier(t) {
                if (this.isContextual("as")) {
                    t.specifiers || (t.specifiers = []);
                    const e = this.startNodeAt(
                        this.state.lastTokStart,
                        this.state.lastTokStartLoc
                    );
                    return (
                        this.next(),
                        (e.exported = this.parseIdentifier(!0)),
                        t.specifiers.push(
                            this.finishNode(e, "ExportNamespaceSpecifier")
                        ),
                        !0
                    );
                }
                return !1;
            }
            maybeParseExportNamedSpecifiers(t) {
                return (
                    !!this.match(h.braceL) &&
                    (t.specifiers || (t.specifiers = []),
                    t.specifiers.push(...this.parseExportSpecifiers()),
                    (t.source = null),
                    (t.declaration = null),
                    !0)
                );
            }
            maybeParseExportDeclaration(t) {
                return (
                    !!this.shouldParseExportDeclaration() &&
                    ((t.specifiers = []),
                    (t.source = null),
                    (t.declaration = this.parseExportDeclaration(t)),
                    !0)
                );
            }
            isAsyncFunction() {
                if (!this.isContextual("async")) return !1;
                const t = this.nextTokenStart();
                return (
                    !y.test(this.input.slice(this.state.pos, t)) &&
                    this.isUnparsedContextual(t, "function")
                );
            }
            parseExportDefaultExpression() {
                const t = this.startNode(),
                    e = this.isAsyncFunction();
                if (this.match(h._function) || e)
                    return (
                        this.next(),
                        e && this.next(),
                        this.parseFunction(t, 5, e)
                    );
                if (this.match(h._class)) return this.parseClass(t, !0, !0);
                if (this.match(h.at))
                    return (
                        this.hasPlugin("decorators") &&
                            this.getPluginOption(
                                "decorators",
                                "decoratorsBeforeExport"
                            ) &&
                            this.raise(
                                this.state.start,
                                E.DecoratorBeforeExport
                            ),
                        this.parseDecorators(!1),
                        this.parseClass(t, !0, !0)
                    );
                if (this.match(h._const) || this.match(h._var) || this.isLet())
                    throw this.raise(
                        this.state.start,
                        E.UnsupportedDefaultExport
                    );
                {
                    const t = this.parseMaybeAssignAllowIn();
                    return this.semicolon(), t;
                }
            }
            parseExportDeclaration(t) {
                return this.parseStatement(null);
            }
            isExportDefaultSpecifier() {
                if (this.match(h.name)) {
                    const t = this.state.value;
                    if (
                        ("async" === t && !this.state.containsEsc) ||
                        "let" === t
                    )
                        return !1;
                    if (
                        ("type" === t || "interface" === t) &&
                        !this.state.containsEsc
                    ) {
                        const t = this.lookahead();
                        if (
                            (t.type === h.name && "from" !== t.value) ||
                            t.type === h.braceL
                        )
                            return (
                                this.expectOnePlugin(["flow", "typescript"]), !1
                            );
                    }
                } else if (!this.match(h._default)) return !1;
                const t = this.nextTokenStart(),
                    e = this.isUnparsedContextual(t, "from");
                if (
                    44 === this.input.charCodeAt(t) ||
                    (this.match(h.name) && e)
                )
                    return !0;
                if (this.match(h._default) && e) {
                    const e = this.input.charCodeAt(
                        this.nextTokenStartSince(t + 4)
                    );
                    return 34 === e || 39 === e;
                }
                return !1;
            }
            parseExportFrom(t, e) {
                this.eatContextual("from")
                    ? ((t.source = this.parseImportSource()),
                      this.checkExport(t))
                    : e
                    ? this.unexpected()
                    : (t.source = null),
                    this.semicolon();
            }
            shouldParseExportDeclaration() {
                if (
                    this.match(h.at) &&
                    (this.expectOnePlugin(["decorators", "decorators-legacy"]),
                    this.hasPlugin("decorators"))
                ) {
                    if (
                        !this.getPluginOption(
                            "decorators",
                            "decoratorsBeforeExport"
                        )
                    )
                        return !0;
                    this.unexpected(this.state.start, E.DecoratorBeforeExport);
                }
                return (
                    "var" === this.state.type.keyword ||
                    "const" === this.state.type.keyword ||
                    "function" === this.state.type.keyword ||
                    "class" === this.state.type.keyword ||
                    this.isLet() ||
                    this.isAsyncFunction()
                );
            }
            checkExport(t, e, n, r) {
                if (e)
                    if (n) {
                        if (
                            (this.checkDuplicateExports(t, "default"),
                            this.hasPlugin("exportDefaultFrom"))
                        ) {
                            var s;
                            const e = t.declaration;
                            "Identifier" !== e.type ||
                                "from" !== e.name ||
                                e.end - e.start != 4 ||
                                (null == (s = e.extra)
                                    ? void 0
                                    : s.parenthesized) ||
                                this.raise(
                                    e.start,
                                    E.ExportDefaultFromAsIdentifier
                                );
                        }
                    } else if (t.specifiers && t.specifiers.length)
                        for (let e = 0, n = t.specifiers; e < n.length; e++) {
                            const t = n[e];
                            this.checkDuplicateExports(t, t.exported.name),
                                !r &&
                                    t.local &&
                                    (this.checkReservedWord(
                                        t.local.name,
                                        t.local.start,
                                        !0,
                                        !1
                                    ),
                                    this.scope.checkLocalExport(t.local));
                        }
                    else if (t.declaration)
                        if (
                            "FunctionDeclaration" === t.declaration.type ||
                            "ClassDeclaration" === t.declaration.type
                        ) {
                            const e = t.declaration.id;
                            if (!e) throw new Error("Assertion failure");
                            this.checkDuplicateExports(t, e.name);
                        } else if ("VariableDeclaration" === t.declaration.type)
                            for (
                                let e = 0, n = t.declaration.declarations;
                                e < n.length;
                                e++
                            ) {
                                const t = n[e];
                                this.checkDeclaration(t.id);
                            }
                if (
                    this.state.decoratorStack[
                        this.state.decoratorStack.length - 1
                    ].length
                )
                    throw this.raise(t.start, E.UnsupportedDecoratorExport);
            }
            checkDeclaration(t) {
                if ("Identifier" === t.type)
                    this.checkDuplicateExports(t, t.name);
                else if ("ObjectPattern" === t.type)
                    for (let e = 0, n = t.properties; e < n.length; e++) {
                        const t = n[e];
                        this.checkDeclaration(t);
                    }
                else if ("ArrayPattern" === t.type)
                    for (let e = 0, n = t.elements; e < n.length; e++) {
                        const t = n[e];
                        t && this.checkDeclaration(t);
                    }
                else
                    "ObjectProperty" === t.type
                        ? this.checkDeclaration(t.value)
                        : "RestElement" === t.type
                        ? this.checkDeclaration(t.argument)
                        : "AssignmentPattern" === t.type &&
                          this.checkDeclaration(t.left);
            }
            checkDuplicateExports(t, e) {
                this.state.exportedIdentifiers.indexOf(e) > -1 &&
                    this.raise(
                        t.start,
                        "default" === e
                            ? E.DuplicateDefaultExport
                            : E.DuplicateExport,
                        e
                    ),
                    this.state.exportedIdentifiers.push(e);
            }
            parseExportSpecifiers() {
                const t = [];
                let e = !0;
                for (this.expect(h.braceL); !this.eat(h.braceR); ) {
                    if (e) e = !1;
                    else if ((this.expect(h.comma), this.eat(h.braceR))) break;
                    const n = this.startNode();
                    (n.local = this.parseIdentifier(!0)),
                        (n.exported = this.eatContextual("as")
                            ? this.parseIdentifier(!0)
                            : n.local.__clone()),
                        t.push(this.finishNode(n, "ExportSpecifier"));
                }
                return t;
            }
            parseImport(t) {
                if (((t.specifiers = []), !this.match(h.string))) {
                    const e =
                            !this.maybeParseDefaultImportSpecifier(t) ||
                            this.eat(h.comma),
                        n = e && this.maybeParseStarImportSpecifier(t);
                    e && !n && this.parseNamedImportSpecifiers(t),
                        this.expectContextual("from");
                }
                t.source = this.parseImportSource();
                const e = this.maybeParseModuleAttributes();
                return (
                    e && (t.attributes = e),
                    this.semicolon(),
                    this.finishNode(t, "ImportDeclaration")
                );
            }
            parseImportSource() {
                return (
                    this.match(h.string) || this.unexpected(),
                    this.parseExprAtom()
                );
            }
            shouldParseDefaultImport(t) {
                return this.match(h.name);
            }
            parseImportSpecifierLocal(t, e, n, r) {
                (e.local = this.parseIdentifier()),
                    this.checkLVal(e.local, 9, void 0, r),
                    t.specifiers.push(this.finishNode(e, n));
            }
            maybeParseModuleAttributes() {
                if (!this.match(h._with) || this.hasPrecedingLineBreak())
                    return this.hasPlugin("moduleAttributes") ? [] : null;
                this.expectPlugin("moduleAttributes"), this.next();
                const t = [],
                    e = new Set();
                do {
                    const n = this.startNode();
                    if (
                        ((n.key = this.parseIdentifier(!0)),
                        "type" !== n.key.name &&
                            this.raise(
                                n.key.start,
                                E.ModuleAttributeDifferentFromType,
                                n.key.name
                            ),
                        e.has(n.key.name) &&
                            this.raise(
                                n.key.start,
                                E.ModuleAttributesWithDuplicateKeys,
                                n.key.name
                            ),
                        e.add(n.key.name),
                        this.expect(h.colon),
                        !this.match(h.string))
                    )
                        throw this.unexpected(
                            this.state.start,
                            E.ModuleAttributeInvalidValue
                        );
                    (n.value = this.parseLiteral(
                        this.state.value,
                        "StringLiteral"
                    )),
                        this.finishNode(n, "ImportAttribute"),
                        t.push(n);
                } while (this.eat(h.comma));
                return t;
            }
            maybeParseDefaultImportSpecifier(t) {
                return (
                    !!this.shouldParseDefaultImport(t) &&
                    (this.parseImportSpecifierLocal(
                        t,
                        this.startNode(),
                        "ImportDefaultSpecifier",
                        "default import specifier"
                    ),
                    !0)
                );
            }
            maybeParseStarImportSpecifier(t) {
                if (this.match(h.star)) {
                    const e = this.startNode();
                    return (
                        this.next(),
                        this.expectContextual("as"),
                        this.parseImportSpecifierLocal(
                            t,
                            e,
                            "ImportNamespaceSpecifier",
                            "import namespace specifier"
                        ),
                        !0
                    );
                }
                return !1;
            }
            parseNamedImportSpecifiers(t) {
                let e = !0;
                for (this.expect(h.braceL); !this.eat(h.braceR); ) {
                    if (e) e = !1;
                    else {
                        if (this.eat(h.colon))
                            throw this.raise(
                                this.state.start,
                                E.DestructureNamedImport
                            );
                        if ((this.expect(h.comma), this.eat(h.braceR))) break;
                    }
                    this.parseImportSpecifier(t);
                }
            }
            parseImportSpecifier(t) {
                const e = this.startNode();
                (e.imported = this.parseIdentifier(!0)),
                    this.eatContextual("as")
                        ? (e.local = this.parseIdentifier())
                        : (this.checkReservedWord(
                              e.imported.name,
                              e.start,
                              !0,
                              !0
                          ),
                          (e.local = e.imported.__clone())),
                    this.checkLVal(e.local, 9, void 0, "import specifier"),
                    t.specifiers.push(this.finishNode(e, "ImportSpecifier"));
            }
        } {
            constructor(t, e) {
                super(
                    (t = (function (t) {
                        const e = {};
                        for (
                            let n = 0, r = Object.keys(xt);
                            n < r.length;
                            n++
                        ) {
                            const s = r[n];
                            e[s] = t && null != t[s] ? t[s] : xt[s];
                        }
                        return e;
                    })(t)),
                    e
                );
                const n = this.getScopeHandler();
                (this.options = t),
                    (this.inModule = "module" === this.options.sourceType),
                    (this.scope = new n(this.raise.bind(this), this.inModule)),
                    (this.prodParam = new lt()),
                    (this.classScope = new jt(this.raise.bind(this))),
                    (this.plugins = (function (t) {
                        const e = new Map();
                        for (let n = 0; n < t.length; n++) {
                            const r = t[n],
                                [s, i] = Array.isArray(r) ? r : [r, {}];
                            e.has(s) || e.set(s, i || {});
                        }
                        return e;
                    })(this.options.plugins)),
                    (this.filename = t.sourceFilename);
            }
            getScopeHandler() {
                return ot;
            }
            parse() {
                let t = 0;
                this.hasPlugin("topLevelAwait") && this.inModule && (t |= 2),
                    this.scope.enter(1),
                    this.prodParam.enter(t);
                const e = this.startNode(),
                    n = this.startNode();
                return (
                    this.nextToken(),
                    (e.errors = null),
                    this.parseTopLevel(e, n),
                    (e.errors = this.state.errors),
                    e
                );
            }
        }
        function Mt(t, e) {
            let n = Lt;
            return (
                (null == t ? void 0 : t.plugins) &&
                    (!(function (t) {
                        if (ft(t, "decorators")) {
                            if (ft(t, "decorators-legacy"))
                                throw new Error(
                                    "Cannot use the decorators and decorators-legacy plugin together"
                                );
                            const e = mt(
                                t,
                                "decorators",
                                "decoratorsBeforeExport"
                            );
                            if (null == e)
                                throw new Error(
                                    "The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'."
                                );
                            if ("boolean" != typeof e)
                                throw new Error(
                                    "'decoratorsBeforeExport' must be a boolean."
                                );
                        }
                        if (ft(t, "flow") && ft(t, "typescript"))
                            throw new Error(
                                "Cannot combine flow and typescript plugins."
                            );
                        if (ft(t, "placeholders") && ft(t, "v8intrinsic"))
                            throw new Error(
                                "Cannot combine placeholders and v8intrinsic plugins."
                            );
                        if (
                            ft(t, "pipelineOperator") &&
                            !yt.includes(mt(t, "pipelineOperator", "proposal"))
                        )
                            throw new Error(
                                "'pipelineOperator' requires 'proposal' option whose value should be one of: " +
                                    yt.map((t) => `'${t}'`).join(", ")
                            );
                        if (
                            ft(t, "moduleAttributes") &&
                            "may-2020" !== mt(t, "moduleAttributes", "version")
                        )
                            throw new Error(
                                "The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'."
                            );
                        if (
                            ft(t, "recordAndTuple") &&
                            !gt.includes(mt(t, "recordAndTuple", "syntaxType"))
                        )
                            throw new Error(
                                "'recordAndTuple' requires 'syntaxType' option whose value should be one of: " +
                                    gt.map((t) => `'${t}'`).join(", ")
                            );
                    })(t.plugins),
                    (n = (function (t) {
                        const e = bt.filter((e) => ft(t, e)),
                            n = e.join("/");
                        let r = Rt[n];
                        if (!r) {
                            r = Lt;
                            for (let t = 0; t < e.length; t++) {
                                const n = e[t];
                                r = vt[n](r);
                            }
                            Rt[n] = r;
                        }
                        return r;
                    })(t.plugins))),
                new n(t, e)
            );
        }
        const Rt = {};
        (e.parse = function (t, e) {
            var n;
            if ("unambiguous" !== (null == (n = e) ? void 0 : n.sourceType))
                return Mt(e, t).parse();
            e = Object.assign({}, e);
            try {
                e.sourceType = "module";
                const n = Mt(e, t),
                    r = n.parse();
                if (n.sawUnambiguousESM) return r;
                if (n.ambiguousScriptDifferentAst)
                    try {
                        return (e.sourceType = "script"), Mt(e, t).parse();
                    } catch (t) {}
                else r.program.sourceType = "script";
                return r;
            } catch (n) {
                try {
                    return (e.sourceType = "script"), Mt(e, t).parse();
                } catch (t) {}
                throw n;
            }
        }),
            (e.parseExpression = function (t, e) {
                const n = Mt(e, t);
                return (
                    n.options.strictMode && (n.state.strict = !0),
                    n.getExpression()
                );
            }),
            (e.tokTypes = h);
    },
    function (t, e, n) {
        "use strict";
        (function (t) {
            n.d(e, "a", function () {
                return m;
            });
            var r = n(1),
                s = "store";
            var i = (
                "undefined" != typeof window ? window : void 0 !== t ? t : {}
            ).__VUE_DEVTOOLS_GLOBAL_HOOK__;
            function o(t, e) {
                Object.keys(t).forEach(function (n) {
                    return e(t[n], n);
                });
            }
            function a(t) {
                return null !== t && "object" == typeof t;
            }
            function c(t, e) {
                if (!t) throw new Error("[vuex] " + e);
            }
            var l = function (t, e) {
                    (this.runtime = e),
                        (this._children = Object.create(null)),
                        (this._rawModule = t);
                    var n = t.state;
                    this.state = ("function" == typeof n ? n() : n) || {};
                },
                u = { namespaced: { configurable: !0 } };
            (u.namespaced.get = function () {
                return !!this._rawModule.namespaced;
            }),
                (l.prototype.addChild = function (t, e) {
                    this._children[t] = e;
                }),
                (l.prototype.removeChild = function (t) {
                    delete this._children[t];
                }),
                (l.prototype.getChild = function (t) {
                    return this._children[t];
                }),
                (l.prototype.hasChild = function (t) {
                    return t in this._children;
                }),
                (l.prototype.update = function (t) {
                    (this._rawModule.namespaced = t.namespaced),
                        t.actions && (this._rawModule.actions = t.actions),
                        t.mutations &&
                            (this._rawModule.mutations = t.mutations),
                        t.getters && (this._rawModule.getters = t.getters);
                }),
                (l.prototype.forEachChild = function (t) {
                    o(this._children, t);
                }),
                (l.prototype.forEachGetter = function (t) {
                    this._rawModule.getters && o(this._rawModule.getters, t);
                }),
                (l.prototype.forEachAction = function (t) {
                    this._rawModule.actions && o(this._rawModule.actions, t);
                }),
                (l.prototype.forEachMutation = function (t) {
                    this._rawModule.mutations &&
                        o(this._rawModule.mutations, t);
                }),
                Object.defineProperties(l.prototype, u);
            var h = function (t) {
                this.register([], t, !1);
            };
            (h.prototype.get = function (t) {
                return t.reduce(function (t, e) {
                    return t.getChild(e);
                }, this.root);
            }),
                (h.prototype.getNamespace = function (t) {
                    var e = this.root;
                    return t.reduce(function (t, n) {
                        return (
                            t + ((e = e.getChild(n)).namespaced ? n + "/" : "")
                        );
                    }, "");
                }),
                (h.prototype.update = function (t) {
                    !(function t(e, n, r) {
                        if ((f(e, r), n.update(r), r.modules))
                            for (var s in r.modules) {
                                if (!n.getChild(s))
                                    return void console.warn(
                                        "[vuex] trying to add a new module '" +
                                            s +
                                            "' on hot reloading, manual reload is needed"
                                    );
                                t(e.concat(s), n.getChild(s), r.modules[s]);
                            }
                    })([], this.root, t);
                }),
                (h.prototype.register = function (t, e, n) {
                    var r = this;
                    void 0 === n && (n = !0), f(t, e);
                    var s = new l(e, n);
                    0 === t.length
                        ? (this.root = s)
                        : this.get(t.slice(0, -1)).addChild(t[t.length - 1], s);
                    e.modules &&
                        o(e.modules, function (e, s) {
                            r.register(t.concat(s), e, n);
                        });
                }),
                (h.prototype.unregister = function (t) {
                    var e = this.get(t.slice(0, -1)),
                        n = t[t.length - 1],
                        r = e.getChild(n);
                    r
                        ? r.runtime && e.removeChild(n)
                        : console.warn(
                              "[vuex] trying to unregister module '" +
                                  n +
                                  "', which is not registered"
                          );
                }),
                (h.prototype.isRegistered = function (t) {
                    var e = this.get(t.slice(0, -1)),
                        n = t[t.length - 1];
                    return e.hasChild(n);
                });
            var p = {
                    assert: function (t) {
                        return "function" == typeof t;
                    },
                    expected: "function",
                },
                d = {
                    getters: p,
                    mutations: p,
                    actions: {
                        assert: function (t) {
                            return (
                                "function" == typeof t ||
                                ("object" == typeof t &&
                                    "function" == typeof t.handler)
                            );
                        },
                        expected: 'function or object with "handler" function',
                    },
                };
            function f(t, e) {
                Object.keys(d).forEach(function (n) {
                    if (e[n]) {
                        var r = d[n];
                        o(e[n], function (e, s) {
                            c(
                                r.assert(e),
                                (function (t, e, n, r, s) {
                                    var i =
                                        e +
                                        " should be " +
                                        s +
                                        ' but "' +
                                        e +
                                        "." +
                                        n +
                                        '"';
                                    t.length > 0 &&
                                        (i +=
                                            ' in module "' + t.join(".") + '"');
                                    return (i +=
                                        " is " + JSON.stringify(r) + ".");
                                })(t, n, s, e, r.expected)
                            );
                        });
                    }
                });
            }
            function m(t) {
                return new y(t);
            }
            var y = function t(e) {
                    var n = this;
                    void 0 === e && (e = {}),
                        c(
                            "undefined" != typeof Promise,
                            "vuex requires a Promise polyfill in this browser."
                        ),
                        c(
                            this instanceof t,
                            "store must be called with the new operator."
                        );
                    var r = e.plugins;
                    void 0 === r && (r = []);
                    var s = e.strict;
                    void 0 === s && (s = !1),
                        (this._committing = !1),
                        (this._actions = Object.create(null)),
                        (this._actionSubscribers = []),
                        (this._mutations = Object.create(null)),
                        (this._wrappedGetters = Object.create(null)),
                        (this._modules = new h(e)),
                        (this._modulesNamespaceMap = Object.create(null)),
                        (this._subscribers = []),
                        (this._makeLocalGettersCache = Object.create(null));
                    var o = this,
                        a = this.dispatch,
                        l = this.commit;
                    (this.dispatch = function (t, e) {
                        return a.call(o, t, e);
                    }),
                        (this.commit = function (t, e, n) {
                            return l.call(o, t, e, n);
                        }),
                        (this.strict = s);
                    var u = this._modules.root.state;
                    w(this, u, [], this._modules.root),
                        x(this, u),
                        r.forEach(function (t) {
                            return t(n);
                        }),
                        (void 0 === e.devtools || e.devtools) &&
                            (function (t) {
                                i &&
                                    ((t._devtoolHook = i),
                                    i.emit("vuex:init", t),
                                    i.on("vuex:travel-to-state", function (e) {
                                        t.replaceState(e);
                                    }),
                                    t.subscribe(
                                        function (t, e) {
                                            i.emit("vuex:mutation", t, e);
                                        },
                                        { prepend: !0 }
                                    ),
                                    t.subscribeAction(
                                        function (t, e) {
                                            i.emit("vuex:action", t, e);
                                        },
                                        { prepend: !0 }
                                    ));
                            })(this);
                },
                g = { state: { configurable: !0 } };
            function v(t, e, n) {
                return (
                    e.indexOf(t) < 0 &&
                        (n && n.prepend ? e.unshift(t) : e.push(t)),
                    function () {
                        var n = e.indexOf(t);
                        n > -1 && e.splice(n, 1);
                    }
                );
            }
            function b(t, e) {
                (t._actions = Object.create(null)),
                    (t._mutations = Object.create(null)),
                    (t._wrappedGetters = Object.create(null)),
                    (t._modulesNamespaceMap = Object.create(null));
                var n = t.state;
                w(t, n, [], t._modules.root, !0), x(t, n, e);
            }
            function x(t, e, n) {
                var s = t._state;
                (t.getters = {}),
                    (t._makeLocalGettersCache = Object.create(null));
                var i = t._wrappedGetters,
                    a = {};
                o(i, function (e, n) {
                    (a[n] = (function (t, e) {
                        return function () {
                            return t(e);
                        };
                    })(e, t)),
                        Object.defineProperty(t.getters, n, {
                            get: function () {
                                return Object(r.a)(function () {
                                    return a[n]();
                                }).value;
                            },
                            enumerable: !0,
                        });
                }),
                    (t._state = Object(r.m)({ data: e })),
                    t.strict &&
                        (function (t) {
                            Object(r.s)(
                                function () {
                                    return t._state.data;
                                },
                                function () {
                                    c(
                                        t._committing,
                                        "do not mutate vuex store state outside mutation handlers."
                                    );
                                },
                                { deep: !0, flush: "sync" }
                            );
                        })(t),
                    s &&
                        n &&
                        t._withCommit(function () {
                            s.data = null;
                        });
            }
            function w(t, e, n, r, s) {
                var i = !n.length,
                    o = t._modules.getNamespace(n);
                if (
                    (r.namespaced &&
                        (t._modulesNamespaceMap[o] &&
                            console.error(
                                "[vuex] duplicate namespace " +
                                    o +
                                    " for the namespaced module " +
                                    n.join("/")
                            ),
                        (t._modulesNamespaceMap[o] = r)),
                    !i && !s)
                ) {
                    var a = P(e, n.slice(0, -1)),
                        c = n[n.length - 1];
                    t._withCommit(function () {
                        c in a &&
                            console.warn(
                                '[vuex] state field "' +
                                    c +
                                    '" was overridden by a module with the same name at "' +
                                    n.join(".") +
                                    '"'
                            ),
                            (a[c] = r.state);
                    });
                }
                var l = (r.context = (function (t, e, n) {
                    var r = "" === e,
                        s = {
                            dispatch: r
                                ? t.dispatch
                                : function (n, r, s) {
                                      var i = A(n, r, s),
                                          o = i.payload,
                                          a = i.options,
                                          c = i.type;
                                      if (
                                          (a && a.root) ||
                                          ((c = e + c), t._actions[c])
                                      )
                                          return t.dispatch(c, o);
                                      console.error(
                                          "[vuex] unknown local action type: " +
                                              i.type +
                                              ", global type: " +
                                              c
                                      );
                                  },
                            commit: r
                                ? t.commit
                                : function (n, r, s) {
                                      var i = A(n, r, s),
                                          o = i.payload,
                                          a = i.options,
                                          c = i.type;
                                      (a && a.root) ||
                                      ((c = e + c), t._mutations[c])
                                          ? t.commit(c, o, a)
                                          : console.error(
                                                "[vuex] unknown local mutation type: " +
                                                    i.type +
                                                    ", global type: " +
                                                    c
                                            );
                                  },
                        };
                    return (
                        Object.defineProperties(s, {
                            getters: {
                                get: r
                                    ? function () {
                                          return t.getters;
                                      }
                                    : function () {
                                          return (function (t, e) {
                                              if (
                                                  !t._makeLocalGettersCache[e]
                                              ) {
                                                  var n = {},
                                                      r = e.length;
                                                  Object.keys(
                                                      t.getters
                                                  ).forEach(function (s) {
                                                      if (s.slice(0, r) === e) {
                                                          var i = s.slice(r);
                                                          Object.defineProperty(
                                                              n,
                                                              i,
                                                              {
                                                                  get: function () {
                                                                      return t
                                                                          .getters[
                                                                          s
                                                                      ];
                                                                  },
                                                                  enumerable:
                                                                      !0,
                                                              }
                                                          );
                                                      }
                                                  }),
                                                      (t._makeLocalGettersCache[
                                                          e
                                                      ] = n);
                                              }
                                              return t._makeLocalGettersCache[
                                                  e
                                              ];
                                          })(t, e);
                                      },
                            },
                            state: {
                                get: function () {
                                    return P(t.state, n);
                                },
                            },
                        }),
                        s
                    );
                })(t, o, n));
                r.forEachMutation(function (e, n) {
                    !(function (t, e, n, r) {
                        (t._mutations[e] || (t._mutations[e] = [])).push(
                            function (e) {
                                n.call(t, r.state, e);
                            }
                        );
                    })(t, o + n, e, l);
                }),
                    r.forEachAction(function (e, n) {
                        var r = e.root ? n : o + n,
                            s = e.handler || e;
                        !(function (t, e, n, r) {
                            (t._actions[e] || (t._actions[e] = [])).push(
                                function (e) {
                                    var s,
                                        i = n.call(
                                            t,
                                            {
                                                dispatch: r.dispatch,
                                                commit: r.commit,
                                                getters: r.getters,
                                                state: r.state,
                                                rootGetters: t.getters,
                                                rootState: t.state,
                                            },
                                            e
                                        );
                                    return (
                                        ((s = i) &&
                                            "function" == typeof s.then) ||
                                            (i = Promise.resolve(i)),
                                        t._devtoolHook
                                            ? i.catch(function (e) {
                                                  throw (
                                                      (t._devtoolHook.emit(
                                                          "vuex:error",
                                                          e
                                                      ),
                                                      e)
                                                  );
                                              })
                                            : i
                                    );
                                }
                            );
                        })(t, r, s, l);
                    }),
                    r.forEachGetter(function (e, n) {
                        !(function (t, e, n, r) {
                            if (t._wrappedGetters[e])
                                return void console.error(
                                    "[vuex] duplicate getter key: " + e
                                );
                            t._wrappedGetters[e] = function (t) {
                                return n(
                                    r.state,
                                    r.getters,
                                    t.state,
                                    t.getters
                                );
                            };
                        })(t, o + n, e, l);
                    }),
                    r.forEachChild(function (r, i) {
                        w(t, e, n.concat(i), r, s);
                    });
            }
            function P(t, e) {
                return e.reduce(function (t, e) {
                    return t[e];
                }, t);
            }
            function A(t, e, n) {
                return (
                    a(t) && t.type && ((n = e), (e = t), (t = t.type)),
                    c(
                        "string" == typeof t,
                        "expects string as the type, but found " +
                            typeof t +
                            "."
                    ),
                    { type: t, payload: e, options: n }
                );
            }
            (y.prototype.install = function (t, e) {
                t.provide(e || s, this),
                    (t.config.globalProperties.$store = this);
            }),
                (g.state.get = function () {
                    return this._state.data;
                }),
                (g.state.set = function (t) {
                    c(
                        !1,
                        "use store.replaceState() to explicit replace store state."
                    );
                }),
                (y.prototype.commit = function (t, e, n) {
                    var r = this,
                        s = A(t, e, n),
                        i = s.type,
                        o = s.payload,
                        a = s.options,
                        c = { type: i, payload: o },
                        l = this._mutations[i];
                    l
                        ? (this._withCommit(function () {
                              l.forEach(function (t) {
                                  t(o);
                              });
                          }),
                          this._subscribers.slice().forEach(function (t) {
                              return t(c, r.state);
                          }),
                          a &&
                              a.silent &&
                              console.warn(
                                  "[vuex] mutation type: " +
                                      i +
                                      ". Silent option has been removed. Use the filter functionality in the vue-devtools"
                              ))
                        : console.error("[vuex] unknown mutation type: " + i);
                }),
                (y.prototype.dispatch = function (t, e) {
                    var n = this,
                        r = A(t, e),
                        s = r.type,
                        i = r.payload,
                        o = { type: s, payload: i },
                        a = this._actions[s];
                    if (a) {
                        try {
                            this._actionSubscribers
                                .slice()
                                .filter(function (t) {
                                    return t.before;
                                })
                                .forEach(function (t) {
                                    return t.before(o, n.state);
                                });
                        } catch (t) {
                            console.warn(
                                "[vuex] error in before action subscribers: "
                            ),
                                console.error(t);
                        }
                        var c =
                            a.length > 1
                                ? Promise.all(
                                      a.map(function (t) {
                                          return t(i);
                                      })
                                  )
                                : a[0](i);
                        return new Promise(function (t, e) {
                            c.then(
                                function (e) {
                                    try {
                                        n._actionSubscribers
                                            .filter(function (t) {
                                                return t.after;
                                            })
                                            .forEach(function (t) {
                                                return t.after(o, n.state);
                                            });
                                    } catch (t) {
                                        console.warn(
                                            "[vuex] error in after action subscribers: "
                                        ),
                                            console.error(t);
                                    }
                                    t(e);
                                },
                                function (t) {
                                    try {
                                        n._actionSubscribers
                                            .filter(function (t) {
                                                return t.error;
                                            })
                                            .forEach(function (e) {
                                                return e.error(o, n.state, t);
                                            });
                                    } catch (t) {
                                        console.warn(
                                            "[vuex] error in error action subscribers: "
                                        ),
                                            console.error(t);
                                    }
                                    e(t);
                                }
                            );
                        });
                    }
                    console.error("[vuex] unknown action type: " + s);
                }),
                (y.prototype.subscribe = function (t, e) {
                    return v(t, this._subscribers, e);
                }),
                (y.prototype.subscribeAction = function (t, e) {
                    return v(
                        "function" == typeof t ? { before: t } : t,
                        this._actionSubscribers,
                        e
                    );
                }),
                (y.prototype.watch = function (t, e, n) {
                    var s = this;
                    return (
                        c(
                            "function" == typeof t,
                            "store.watch only accepts a function."
                        ),
                        Object(r.s)(
                            function () {
                                return t(s.state, s.getters);
                            },
                            e,
                            Object.assign({}, n)
                        )
                    );
                }),
                (y.prototype.replaceState = function (t) {
                    var e = this;
                    this._withCommit(function () {
                        e._state.data = t;
                    });
                }),
                (y.prototype.registerModule = function (t, e, n) {
                    void 0 === n && (n = {}),
                        "string" == typeof t && (t = [t]),
                        c(
                            Array.isArray(t),
                            "module path must be a string or an Array."
                        ),
                        c(
                            t.length > 0,
                            "cannot register the root module by using registerModule."
                        ),
                        this._modules.register(t, e),
                        w(
                            this,
                            this.state,
                            t,
                            this._modules.get(t),
                            n.preserveState
                        ),
                        x(this, this.state);
                }),
                (y.prototype.unregisterModule = function (t) {
                    var e = this;
                    "string" == typeof t && (t = [t]),
                        c(
                            Array.isArray(t),
                            "module path must be a string or an Array."
                        ),
                        this._modules.unregister(t),
                        this._withCommit(function () {
                            delete P(e.state, t.slice(0, -1))[t[t.length - 1]];
                        }),
                        b(this);
                }),
                (y.prototype.hasModule = function (t) {
                    return (
                        "string" == typeof t && (t = [t]),
                        c(
                            Array.isArray(t),
                            "module path must be a string or an Array."
                        ),
                        this._modules.isRegistered(t)
                    );
                }),
                (y.prototype.hotUpdate = function (t) {
                    this._modules.update(t), b(this, !0);
                }),
                (y.prototype._withCommit = function (t) {
                    var e = this._committing;
                    (this._committing = !0), t(), (this._committing = e);
                }),
                Object.defineProperties(y.prototype, g);
            S(function (t, e) {
                var n = {};
                return (
                    T(e) ||
                        console.error(
                            "[vuex] mapState: mapper parameter must be either an Array or an Object"
                        ),
                    E(e).forEach(function (e) {
                        var r = e.key,
                            s = e.val;
                        (n[r] = function () {
                            var e = this.$store.state,
                                n = this.$store.getters;
                            if (t) {
                                var r = C(this.$store, "mapState", t);
                                if (!r) return;
                                (e = r.context.state), (n = r.context.getters);
                            }
                            return "function" == typeof s
                                ? s.call(this, e, n)
                                : e[s];
                        }),
                            (n[r].vuex = !0);
                    }),
                    n
                );
            }),
                S(function (t, e) {
                    var n = {};
                    return (
                        T(e) ||
                            console.error(
                                "[vuex] mapMutations: mapper parameter must be either an Array or an Object"
                            ),
                        E(e).forEach(function (e) {
                            var r = e.key,
                                s = e.val;
                            n[r] = function () {
                                for (var e = [], n = arguments.length; n--; )
                                    e[n] = arguments[n];
                                var r = this.$store.commit;
                                if (t) {
                                    var i = C(this.$store, "mapMutations", t);
                                    if (!i) return;
                                    r = i.context.commit;
                                }
                                return "function" == typeof s
                                    ? s.apply(this, [r].concat(e))
                                    : r.apply(this.$store, [s].concat(e));
                            };
                        }),
                        n
                    );
                }),
                S(function (t, e) {
                    var n = {};
                    return (
                        T(e) ||
                            console.error(
                                "[vuex] mapGetters: mapper parameter must be either an Array or an Object"
                            ),
                        E(e).forEach(function (e) {
                            var r = e.key,
                                s = e.val;
                            (s = t + s),
                                (n[r] = function () {
                                    if (!t || C(this.$store, "mapGetters", t)) {
                                        if (s in this.$store.getters)
                                            return this.$store.getters[s];
                                        console.error(
                                            "[vuex] unknown getter: " + s
                                        );
                                    }
                                }),
                                (n[r].vuex = !0);
                        }),
                        n
                    );
                }),
                S(function (t, e) {
                    var n = {};
                    return (
                        T(e) ||
                            console.error(
                                "[vuex] mapActions: mapper parameter must be either an Array or an Object"
                            ),
                        E(e).forEach(function (e) {
                            var r = e.key,
                                s = e.val;
                            n[r] = function () {
                                for (var e = [], n = arguments.length; n--; )
                                    e[n] = arguments[n];
                                var r = this.$store.dispatch;
                                if (t) {
                                    var i = C(this.$store, "mapActions", t);
                                    if (!i) return;
                                    r = i.context.dispatch;
                                }
                                return "function" == typeof s
                                    ? s.apply(this, [r].concat(e))
                                    : r.apply(this.$store, [s].concat(e));
                            };
                        }),
                        n
                    );
                });
            function E(t) {
                return T(t)
                    ? Array.isArray(t)
                        ? t.map(function (t) {
                              return { key: t, val: t };
                          })
                        : Object.keys(t).map(function (e) {
                              return { key: e, val: t[e] };
                          })
                    : [];
            }
            function T(t) {
                return Array.isArray(t) || a(t);
            }
            function S(t) {
                return function (e, n) {
                    return (
                        "string" != typeof e
                            ? ((n = e), (e = ""))
                            : "/" !== e.charAt(e.length - 1) && (e += "/"),
                        t(e, n)
                    );
                };
            }
            function C(t, e, n) {
                var r = t._modulesNamespaceMap[n];
                return (
                    r ||
                        console.error(
                            "[vuex] module namespace not found in " +
                                e +
                                "(): " +
                                n
                        ),
                    r
                );
            }
        }.call(this, n(126)));
    },
    function (t, e, n) {
        "use strict";
        n.d(e, "a", function () {
            return En;
        });
        var r,
            s,
            i = n(1),
            o = n(166),
            a = n(42),
            c = n.n(a);
        function l(t, e, n) {
            return (
                e in t
                    ? Object.defineProperty(t, e, {
                          value: n,
                          enumerable: !0,
                          configurable: !0,
                          writable: !0,
                      })
                    : (t[e] = n),
                t
            );
        }
        function u(t) {
            return (
                (function (t) {
                    if (Array.isArray(t)) return h(t);
                })(t) ||
                (function (t) {
                    if (
                        "undefined" != typeof Symbol &&
                        Symbol.iterator in Object(t)
                    )
                        return Array.from(t);
                })(t) ||
                (function (t, e) {
                    if (!t) return;
                    if ("string" == typeof t) return h(t, e);
                    var n = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === n && t.constructor && (n = t.constructor.name);
                    if ("Map" === n || "Set" === n) return Array.from(t);
                    if (
                        "Arguments" === n ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                    )
                        return h(t, e);
                })(t) ||
                (function () {
                    throw new TypeError(
                        "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                    );
                })()
            );
        }
        function h(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
            return r;
        }
        !(function (t) {
            (t.CLEAR_FILES = "CLEAR_FILES"),
                (t.UPDATE_FILES = "UPDATE_FILES"),
                (t.SET_SEARCHED_FILES = "SET_SEARCHED_FILES"),
                (t.UPDATE_SEARCHED_FILES = "UPDATE_SEARCHED_FILES"),
                (t.CLEAR_SEARCHED_FILES = "CLEAR_SEARCHED_FILES");
        })(s || (s = {}));
        var p,
            d =
                (l((r = {}), s.CLEAR_FILES, function (t) {
                    t.files = [];
                }),
                l(r, s.CLEAR_SEARCHED_FILES, function (t) {
                    t.searched = [];
                }),
                l(r, s.UPDATE_FILES, function (t, e) {
                    var n;
                    (n = t.files).push.apply(n, u(e));
                }),
                l(r, s.SET_SEARCHED_FILES, function (t, e) {
                    t.searched = e;
                }),
                l(r, s.UPDATE_SEARCHED_FILES, function (t, e) {
                    var n;
                    (n = t.files).push.apply(n, u(e));
                }),
                r);
        function f(t, e, n) {
            return (
                e in t
                    ? Object.defineProperty(t, e, {
                          value: n,
                          enumerable: !0,
                          configurable: !0,
                          writable: !0,
                      })
                    : (t[e] = n),
                t
            );
        }
        var m,
            y = function (t, e, n, r) {
                return new (n || (n = Promise))(function (s, i) {
                    function o(t) {
                        try {
                            c(r.next(t));
                        } catch (t) {
                            i(t);
                        }
                    }
                    function a(t) {
                        try {
                            c(r.throw(t));
                        } catch (t) {
                            i(t);
                        }
                    }
                    function c(t) {
                        var e;
                        t.done
                            ? s(t.value)
                            : ((e = t.value),
                              e instanceof n
                                  ? e
                                  : new n(function (t) {
                                        t(e);
                                    })).then(o, a);
                    }
                    c((r = r.apply(t, e || [])).next());
                });
            };
        !(function (t) {
            (t.GET_FILES = "GET_FILES"), (t.SEARCH_FILES = "SEARCH_FILES");
        })(m || (m = {}));
        var g =
            (f((p = {}), m.GET_FILES, function (t, e) {
                var n = t.commit;
                return y(
                    this,
                    void 0,
                    void 0,
                    regeneratorRuntime.mark(function t() {
                        var r, i;
                        return regeneratorRuntime.wrap(
                            function (t) {
                                for (;;)
                                    switch ((t.prev = t.next)) {
                                        case 0:
                                            return (
                                                (t.prev = 0),
                                                (t.next = 3),
                                                c()({
                                                    method: "GET",
                                                    url: "/admin/mmanager/location",
                                                    params: {
                                                        path: e.location,
                                                        skip: e.skip || 0,
                                                    },
                                                })
                                            );
                                        case 3:
                                            return (
                                                (r = t.sent),
                                                (i = r.data.result).length >
                                                    0 && n(s.UPDATE_FILES, i),
                                                t.abrupt("return", i)
                                            );
                                        case 9:
                                            return (
                                                (t.prev = 9),
                                                (t.t0 = t.catch(0)),
                                                t.abrupt("return", [])
                                            );
                                        case 12:
                                        case "end":
                                            return t.stop();
                                    }
                            },
                            t,
                            null,
                            [[0, 9]]
                        );
                    })
                );
            }),
            f(p, m.SEARCH_FILES, function (t, e) {
                var n = t.commit;
                return y(
                    this,
                    void 0,
                    void 0,
                    regeneratorRuntime.mark(function t() {
                        return regeneratorRuntime.wrap(function (t) {
                            for (;;)
                                switch ((t.prev = t.next)) {
                                    case 0:
                                        return t.abrupt(
                                            "return",
                                            c()({
                                                method: "GET",
                                                url: "/admin/mmanager/search",
                                                params: {
                                                    path: e.location,
                                                    q: e.q,
                                                },
                                            })
                                                .then(function (t) {
                                                    var e = t.data;
                                                    if ("string" == typeof e) {
                                                        var r = JSON.parse(
                                                            "[" +
                                                                e
                                                                    .trim()
                                                                    .slice(
                                                                        0,
                                                                        -1
                                                                    ) +
                                                                "]"
                                                        );
                                                        (e = null),
                                                            r
                                                                .sort(function (
                                                                    t,
                                                                    e
                                                                ) {
                                                                    return (
                                                                        t.mtime -
                                                                        e.mtime
                                                                    );
                                                                })
                                                                .sort(function (
                                                                    t,
                                                                    e
                                                                ) {
                                                                    return (
                                                                        Number(
                                                                            e.isdir
                                                                        ) -
                                                                        Number(
                                                                            t.isdir
                                                                        )
                                                                    );
                                                                }),
                                                            n(
                                                                s.SET_SEARCHED_FILES,
                                                                r
                                                            );
                                                    }
                                                })
                                                .catch(function (t) {
                                                    console.log(t);
                                                })
                                        );
                                    case 1:
                                    case "end":
                                        return t.stop();
                                }
                        }, t);
                    })
                );
            }),
            p);
        var v = Object(o.a)({
            state: {
                files: [],
                searched: [],
                searcheValue: "",
                loading: !1,
                atend: !1,
            },
            mutations: d,
            actions: g,
            getters: {
                getfiles: function (t) {
                    return t.files;
                },
                getsearched: function (t) {
                    return t.searched;
                },
            },
            plugins: [],
        });
        function b() {
            return v;
        }
        var x = v;
        const w =
                "function" == typeof Symbol &&
                "symbol" == typeof Symbol.toStringTag,
            P = (t) =>
                w ? Symbol("[vue-router]: " + t) : "[vue-router]: " + t,
            A = P("router view location matched"),
            E = P("router view depth"),
            T = P("router"),
            S = P("route location"),
            C = "undefined" != typeof window;
        const O = Object.assign;
        function k(t, e) {
            const n = {};
            for (const r in e) {
                const s = e[r];
                n[r] = Array.isArray(s) ? s.map(t) : t(s);
            }
            return n;
        }
        let _ = () => {};
        function N(t, ...e) {
            console.warn("[Vue Router warn]: " + t, ...e);
        }
        const I = /\/$/;
        function j(t, e, n = "/") {
            let r,
                s = {},
                i = "",
                o = "";
            const a = e.indexOf("?"),
                c = e.indexOf("#", a > -1 ? a : 0);
            return (
                a > -1 &&
                    ((r = e.slice(0, a)),
                    (i = e.slice(a + 1, c > -1 ? c : e.length)),
                    (s = t(i))),
                c > -1 &&
                    ((r = r || e.slice(0, c)), (o = e.slice(c, e.length))),
                (r = (function (t, e) {
                    if (t.startsWith("/")) return t;
                    if (!e.startsWith("/"))
                        return (
                            N(
                                `Cannot resolve a relative location without an absolute path. Trying to resolve "${t}" from "${e}". It should look like "/${e}".`
                            ),
                            t
                        );
                    if (!t) return e;
                    const n = e.split("/"),
                        r = t.split("/");
                    let s,
                        i,
                        o = n.length - 1;
                    for (s = 0; s < r.length; s++)
                        if (((i = r[s]), 1 !== o && "." !== i)) {
                            if (".." !== i) break;
                            o--;
                        }
                    return (
                        n.slice(0, o).join("/") +
                        "/" +
                        r.slice(s - (s === r.length ? 1 : 0)).join("/")
                    );
                })(null != r ? r : e, n)),
                { fullPath: r + (i && "?") + i + o, path: r, query: s, hash: o }
            );
        }
        function L(t, e) {
            return !e || t.toLowerCase().indexOf(e.toLowerCase())
                ? t
                : t.slice(e.length) || "/";
        }
        function M(t, e, n) {
            let r = e.matched.length - 1,
                s = n.matched.length - 1;
            return (
                r > -1 &&
                r === s &&
                R(e.matched[r], n.matched[s]) &&
                D(e.params, n.params) &&
                t(e.query) === t(n.query) &&
                e.hash === n.hash
            );
        }
        function R(t, e) {
            return (t.aliasOf || t) === (e.aliasOf || e);
        }
        function D(t, e) {
            if (Object.keys(t).length !== Object.keys(e).length) return !1;
            for (let n in t) if (!F(t[n], e[n])) return !1;
            return !0;
        }
        function F(t, e) {
            return Array.isArray(t)
                ? B(t, e)
                : Array.isArray(e)
                ? B(e, t)
                : t === e;
        }
        function B(t, e) {
            return Array.isArray(e)
                ? t.length === e.length && t.every((t, n) => t === e[n])
                : 1 === t.length && t[0] === e;
        }
        var U, V;
        !(function (t) {
            (t.pop = "pop"), (t.push = "push");
        })(U || (U = {})),
            (function (t) {
                (t.back = "back"), (t.forward = "forward"), (t.unknown = "");
            })(V || (V = {}));
        function q(t) {
            if (!t)
                if (C) {
                    const e = document.querySelector("base");
                    t = (t = (e && e.getAttribute("href")) || "/").replace(
                        /^\w+:\/\/[^\/]+/,
                        ""
                    );
                } else t = "/";
            return (
                "/" !== t[0] && "#" !== t[0] && (t = "/" + t), t.replace(I, "")
            );
        }
        const $ = /^[^#]+#/;
        function z(t, e) {
            return t.replace($, "#") + e;
        }
        const H = () => ({ left: window.pageXOffset, top: window.pageYOffset });
        function W(t) {
            let e;
            if ("el" in t) {
                let n = t.el;
                const r = "string" == typeof n && n.startsWith("#");
                if (
                    !(
                        "string" != typeof t.el ||
                        (r && document.getElementById(t.el.slice(1)))
                    )
                )
                    try {
                        let e = document.querySelector(t.el);
                        if (r && e)
                            return void N(
                                `The selector "${t.el}" should be passed as "el: document.querySelector('${t.el}')" because it starts with "#".`
                            );
                    } catch (e) {
                        return void N(
                            `The selector "${t.el}" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`
                        );
                    }
                const s =
                    "string" == typeof n
                        ? r
                            ? document.getElementById(n.slice(1))
                            : document.querySelector(n)
                        : n;
                if (!s)
                    return void N(
                        `Couldn't find element using selector "${t.el}"`
                    );
                e = (function (t, e) {
                    const n = document.documentElement.getBoundingClientRect(),
                        r = t.getBoundingClientRect();
                    return {
                        behavior: e.behavior,
                        left: r.left - n.left - (e.left || 0),
                        top: r.top - n.top - (e.top || 0),
                    };
                })(s, t);
            } else e = t;
            "scrollBehavior" in document.documentElement.style
                ? window.scrollTo(e)
                : window.scrollTo(
                      null != e.left ? e.left : window.pageXOffset,
                      null != e.top ? e.top : window.pageYOffset
                  );
        }
        function G(t, e) {
            return (history.state ? history.state.position - e : -1) + t;
        }
        const K = new Map();
        let J = () => location.protocol + "//" + location.host;
        function X(t, e) {
            const { pathname: n, search: r, hash: s } = e;
            if (t.indexOf("#") > -1) {
                let t = s.slice(1);
                return "/" !== t[0] && (t = "/" + t), L(t, "");
            }
            return L(n, t) + r + s;
        }
        function Y(t, e, n, r = !1, s = !1) {
            return {
                back: t,
                current: e,
                forward: n,
                replaced: r,
                position: window.history.length,
                scroll: s ? H() : null,
            };
        }
        function Q(t) {
            const e = (function (t) {
                    const { history: e, location: n } = window;
                    let r = { value: X(t, n) },
                        s = { value: e.state };
                    function i(r, i, o) {
                        const a =
                            J() +
                            (t.indexOf("#") > -1 && n.search
                                ? n.pathname + n.search + "#"
                                : t) +
                            r;
                        try {
                            e[o ? "replaceState" : "pushState"](i, "", a),
                                (s.value = i);
                        } catch (t) {
                            N("Error with push/replace State", t),
                                n[o ? "replace" : "assign"](a);
                        }
                    }
                    return (
                        s.value ||
                            i(
                                r.value,
                                {
                                    back: null,
                                    current: r.value,
                                    forward: null,
                                    position: e.length - 1,
                                    replaced: !0,
                                    scroll: null,
                                },
                                !0
                            ),
                        {
                            location: r,
                            state: s,
                            push: function (t, n) {
                                const s = O({}, e.state, {
                                    forward: t,
                                    scroll: H(),
                                });
                                i(s.current, s, !0),
                                    i(
                                        t,
                                        O(
                                            {},
                                            Y(r.value, t, null),
                                            { position: s.position + 1 },
                                            n
                                        ),
                                        !1
                                    ),
                                    (r.value = t);
                            },
                            replace: function (t, n) {
                                i(
                                    t,
                                    O(
                                        {},
                                        e.state,
                                        Y(s.value.back, t, s.value.forward, !0),
                                        n,
                                        { position: s.value.position }
                                    ),
                                    !0
                                ),
                                    (r.value = t);
                            },
                        }
                    );
                })((t = q(t))),
                n = (function (t, e, n, r) {
                    let s = [],
                        i = [],
                        o = null;
                    const a = ({ state: i }) => {
                        const a = X(t, location),
                            c = n.value,
                            l = e.value;
                        let u = 0;
                        if (i) {
                            if (((n.value = a), (e.value = i), o && o === c))
                                return void (o = null);
                            u = l ? i.position - l.position : 0;
                        } else r(a);
                        s.forEach((t) => {
                            t(n.value, c, {
                                delta: u,
                                type: U.pop,
                                direction: u
                                    ? u > 0
                                        ? V.forward
                                        : V.back
                                    : V.unknown,
                            });
                        });
                    };
                    function c() {
                        const { history: t } = window;
                        t.state &&
                            t.replaceState(O({}, t.state, { scroll: H() }), "");
                    }
                    return (
                        window.addEventListener("popstate", a),
                        window.addEventListener("beforeunload", c),
                        {
                            pauseListeners: function () {
                                o = n.value;
                            },
                            listen: function (t) {
                                s.push(t);
                                const e = () => {
                                    const e = s.indexOf(t);
                                    e > -1 && s.splice(e, 1);
                                };
                                return i.push(e), e;
                            },
                            destroy: function () {
                                for (const t of i) t();
                                (i = []),
                                    window.removeEventListener("popstate", a),
                                    window.removeEventListener(
                                        "beforeunload",
                                        c
                                    );
                            },
                        }
                    );
                })(t, e.state, e.location, e.replace);
            const r = O(
                {
                    location: "",
                    base: t,
                    go: function (t, e = !0) {
                        e || n.pauseListeners(), history.go(t);
                    },
                    createHref: z.bind(null, t),
                },
                e,
                n
            );
            return (
                Object.defineProperty(r, "location", {
                    get: () => e.location.value,
                }),
                Object.defineProperty(r, "state", { get: () => e.state.value }),
                r
            );
        }
        function Z(t) {
            return "string" == typeof t || "symbol" == typeof t;
        }
        const tt = {
                path: "/",
                name: void 0,
                params: {},
                query: {},
                hash: "",
                fullPath: "/",
                matched: [],
                meta: {},
                redirectedFrom: void 0,
            },
            et = P("navigation failure");
        var nt;
        !(function (t) {
            (t[(t.aborted = 4)] = "aborted"),
                (t[(t.cancelled = 8)] = "cancelled"),
                (t[(t.duplicated = 16)] = "duplicated");
        })(nt || (nt = {}));
        const rt = {
            1: ({ location: t, currentLocation: e }) =>
                `No match for\n ${JSON.stringify(t)}${
                    e ? "\nwhile being at\n" + JSON.stringify(e) : ""
                }`,
            2: ({ from: t, to: e }) =>
                `Redirected from "${t.fullPath}" to "${(function (t) {
                    if ("string" == typeof t) return t;
                    if ("path" in t) return t.path;
                    const e = {};
                    for (const n of ot) n in t && (e[n] = t[n]);
                    return JSON.stringify(e, null, 2);
                })(e)}" via a navigation guard.`,
            4: ({ from: t, to: e }) =>
                `Navigation aborted from "${t.fullPath}" to "${e.fullPath}" via a navigation guard.`,
            8: ({ from: t, to: e }) =>
                `Navigation cancelled from "${t.fullPath}" to "${e.fullPath}" with a new navigation.`,
            16: ({ from: t, to: e }) =>
                `Avoided redundant navigation to current location: "${t.fullPath}".`,
        };
        function st(t, e) {
            return O(new Error(rt[t](e)), { type: t, [et]: !0 }, e);
        }
        function it(t, e) {
            return (
                t instanceof Error && et in t && (null == e || !!(t.type & e))
            );
        }
        const ot = ["params", "query", "hash"];
        const at = "[^/]+?",
            ct = { sensitive: !1, strict: !1, start: !0, end: !0 },
            lt = /[.+*?^${}()[\]/\\]/g;
        function ut(t, e) {
            let n = 0;
            for (; n < t.length && n < e.length; ) {
                const r = e[n] - t[n];
                if (r) return r;
                n++;
            }
            return t.length < e.length
                ? 1 === t.length && 80 === t[0]
                    ? -1
                    : 1
                : t.length > e.length
                ? 1 === e.length && 80 === e[0]
                    ? 1
                    : -1
                : 0;
        }
        function ht(t, e) {
            let n = 0;
            const r = t.score,
                s = e.score;
            for (; n < r.length && n < s.length; ) {
                const t = ut(r[n], s[n]);
                if (t) return t;
                n++;
            }
            return s.length - r.length;
        }
        const pt = { type: 0, value: "" },
            dt = /[a-zA-Z0-9_]/;
        function ft(t, e, n) {
            const r = (function (t, e) {
                const n = O({}, ct, e);
                let r = [],
                    s = n.start ? "^" : "";
                const i = [];
                for (const e of t) {
                    const t = e.length ? [] : [90];
                    n.strict && !e.length && (s += "/");
                    for (let r = 0; r < e.length; r++) {
                        const o = e[r];
                        let a = 40 + (n.sensitive ? 0.25 : 0);
                        if (0 === o.type)
                            r || (s += "/"),
                                (s += o.value.replace(lt, "\\$&")),
                                (a += 40);
                        else if (1 === o.type) {
                            const {
                                value: t,
                                repeatable: e,
                                optional: n,
                                regexp: c,
                            } = o;
                            i.push({ name: t, repeatable: e, optional: n });
                            const l = c || at;
                            if (l !== at) {
                                a += 10;
                                try {
                                    new RegExp(`(${l})`);
                                } catch (e) {
                                    throw new Error(
                                        `Invalid custom RegExp for param "${t}" (${l}): ` +
                                            e.message
                                    );
                                }
                            }
                            let u = e ? `((?:${l})(?:/(?:${l}))*)` : `(${l})`;
                            r || (u = n ? `(?:/${u})` : "/" + u),
                                n && (u += "?"),
                                (s += u),
                                (a += 20),
                                n && (a += -8),
                                e && (a += -20),
                                ".*" === l && (a += -50);
                        }
                        t.push(a);
                    }
                    r.push(t);
                }
                if (n.strict && n.end) {
                    const t = r.length - 1;
                    r[t][r[t].length - 1] += 0.7000000000000001;
                }
                n.strict || (s += "/?"),
                    n.end ? (s += "$") : n.strict && (s += "(?:/|$)");
                const o = new RegExp(s, n.sensitive ? "" : "i");
                return {
                    re: o,
                    score: r,
                    keys: i,
                    parse: function (t) {
                        const e = t.match(o),
                            n = {};
                        if (!e) return null;
                        for (let t = 1; t < e.length; t++) {
                            const r = e[t] || "",
                                s = i[t - 1];
                            n[s.name] = r && s.repeatable ? r.split("/") : r;
                        }
                        return n;
                    },
                    stringify: function (e) {
                        let n = "",
                            r = !1;
                        for (const s of t) {
                            (r && n.endsWith("/")) || (n += "/"), (r = !1);
                            for (const t of s)
                                if (0 === t.type) n += t.value;
                                else if (1 === t.type) {
                                    const {
                                            value: s,
                                            repeatable: i,
                                            optional: o,
                                        } = t,
                                        a = s in e ? e[s] : "";
                                    if (Array.isArray(a) && !i)
                                        throw new Error(
                                            `Provided param "${s}" is an array but it is not repeatable (* or + modifiers)`
                                        );
                                    const c = Array.isArray(a)
                                        ? a.join("/")
                                        : a;
                                    if (!c) {
                                        if (!o)
                                            throw new Error(
                                                `Missing required param "${s}"`
                                            );
                                        n.endsWith("/")
                                            ? (n = n.slice(0, -1))
                                            : (r = !0);
                                    }
                                    n += c;
                                }
                        }
                        return n;
                    },
                };
            })(
                (function (t) {
                    if (!t) return [[]];
                    if ("/" === t) return [[pt]];
                    if ("/" !== t[0])
                        throw new Error('A non-empty path must start with "/"');
                    function e(t) {
                        throw new Error(`ERR (${n})/"${l}": ${t}`);
                    }
                    let n = 0,
                        r = n;
                    const s = [];
                    let i;
                    function o() {
                        i && s.push(i), (i = []);
                    }
                    let a,
                        c = 0,
                        l = "",
                        u = "";
                    function h() {
                        l &&
                            (0 === n
                                ? i.push({ type: 0, value: l })
                                : 1 === n || 2 === n || 3 === n
                                ? (i.length > 1 &&
                                      ("*" === a || "+" === a) &&
                                      e(
                                          `A repeatable param (${l}) must be alone in its segment. eg: '/:ids+.`
                                      ),
                                  i.push({
                                      type: 1,
                                      value: l,
                                      regexp: u,
                                      repeatable: "*" === a || "+" === a,
                                      optional: "*" === a || "?" === a,
                                  }))
                                : e("Invalid state to consume buffer"),
                            (l = ""));
                    }
                    function p() {
                        l += a;
                    }
                    for (; c < t.length; )
                        if (((a = t[c++]), "\\" !== a || 2 === n))
                            switch (n) {
                                case 0:
                                    "/" === a
                                        ? (l && h(), o())
                                        : ":" === a
                                        ? (h(), (n = 1))
                                        : p();
                                    break;
                                case 4:
                                    p(), (n = r);
                                    break;
                                case 1:
                                    "(" === a
                                        ? ((n = 2), (u = ""))
                                        : dt.test(a)
                                        ? p()
                                        : (h(),
                                          (n = 0),
                                          "*" !== a &&
                                              "?" !== a &&
                                              "+" !== a &&
                                              c--);
                                    break;
                                case 2:
                                    ")" === a
                                        ? "\\" == u[u.length - 1]
                                            ? (u = u.slice(0, -1) + a)
                                            : (n = 3)
                                        : (u += a);
                                    break;
                                case 3:
                                    h(),
                                        (n = 0),
                                        "*" !== a &&
                                            "?" !== a &&
                                            "+" !== a &&
                                            c--;
                                    break;
                                default:
                                    e("Unknown state");
                            }
                        else (r = n), (n = 4);
                    return (
                        2 === n &&
                            e(`Unfinished custom RegExp for param "${l}"`),
                        h(),
                        o(),
                        s
                    );
                })(t.path),
                n
            );
            {
                const e = new Set();
                for (const n of r.keys)
                    e.has(n.name) &&
                        N(
                            `Found duplicated params with name "${n.name}" for path "${t.path}". Only the last one will be available on "$route.params".`
                        ),
                        e.add(n.name);
            }
            const s = O(r, { record: t, parent: e, children: [], alias: [] });
            return (
                e &&
                    !s.record.aliasOf == !e.record.aliasOf &&
                    e.children.push(s),
                s
            );
        }
        function mt(t, e) {
            const n = [],
                r = new Map();
            function s(t, n, r) {
                let a = !r,
                    c = (function (t) {
                        return {
                            path: t.path,
                            redirect: t.redirect,
                            name: t.name,
                            meta: t.meta || {},
                            aliasOf: void 0,
                            beforeEnter: t.beforeEnter,
                            props: yt(t),
                            children: t.children || [],
                            instances: {},
                            leaveGuards: [],
                            updateGuards: [],
                            enterCallbacks: {},
                            components:
                                "components" in t
                                    ? t.components || {}
                                    : { default: t.component },
                        };
                    })(t);
                c.aliasOf = r && r.record;
                const l = bt(e, t),
                    u = [c];
                if ("alias" in t) {
                    const e = "string" == typeof t.alias ? [t.alias] : t.alias;
                    for (const t of e)
                        u.push(
                            O({}, c, {
                                components: r
                                    ? r.record.components
                                    : c.components,
                                path: t,
                                aliasOf: r ? r.record : c,
                            })
                        );
                }
                let h, p;
                for (const e of u) {
                    let { path: u } = e;
                    if (n && "/" !== u[0]) {
                        let t = n.record.path,
                            r = "/" === t[t.length - 1] ? "" : "/";
                        e.path = n.record.path + (u && r + u);
                    }
                    if (
                        ((h = ft(e, n, l)),
                        n && "/" === u[0] && Pt(h, n),
                        r
                            ? (r.alias.push(h), wt(r, h))
                            : ((p = p || h),
                              p !== h && p.alias.push(h),
                              a && t.name && !gt(h) && i(t.name)),
                        "children" in c)
                    ) {
                        let t = c.children;
                        for (let e = 0; e < t.length; e++)
                            s(t[e], h, r && r.children[e]);
                    }
                    (r = r || h), o(h);
                }
                return p
                    ? () => {
                          i(p);
                      }
                    : _;
            }
            function i(t) {
                if (Z(t)) {
                    const e = r.get(t);
                    e &&
                        (r.delete(t),
                        n.splice(n.indexOf(e), 1),
                        e.children.forEach(i),
                        e.alias.forEach(i));
                } else {
                    let e = n.indexOf(t);
                    e > -1 &&
                        (n.splice(e, 1),
                        t.record.name && r.delete(t.record.name),
                        t.children.forEach(i),
                        t.alias.forEach(i));
                }
            }
            function o(t) {
                let e = 0;
                for (; e < n.length && ht(t, n[e]) >= 0; ) e++;
                n.splice(e, 0, t),
                    t.record.name && !gt(t) && r.set(t.record.name, t);
            }
            return (
                (e = bt({ strict: !1, end: !0, sensitive: !1 }, e)),
                t.forEach((t) => s(t)),
                {
                    addRoute: s,
                    resolve: function (t, e) {
                        let s,
                            i,
                            o,
                            a = {};
                        if ("name" in t && t.name) {
                            if (((s = r.get(t.name)), !s))
                                throw st(1, { location: t });
                            (o = s.record.name),
                                (a = O(
                                    (function (t, e) {
                                        let n = {};
                                        for (let r of e)
                                            r in t && (n[r] = t[r]);
                                        return n;
                                    })(
                                        e.params,
                                        s.keys
                                            .filter((t) => !t.optional)
                                            .map((t) => t.name)
                                    ),
                                    t.params
                                )),
                                (i = s.stringify(a));
                        } else if ("path" in t)
                            (i = t.path),
                                "/" !== i[0] &&
                                    N(
                                        `The Matcher cannot resolve relative paths but received "${i}". Unless you directly called \`matcher.resolve("${i}")\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-router-next.`
                                    ),
                                (s = n.find((t) => t.re.test(i))),
                                s && ((a = s.parse(i)), (o = s.record.name));
                        else {
                            if (
                                ((s = e.name
                                    ? r.get(e.name)
                                    : n.find((t) => t.re.test(e.path))),
                                !s)
                            )
                                throw st(1, {
                                    location: t,
                                    currentLocation: e,
                                });
                            (o = s.record.name),
                                (a = O({}, e.params, t.params)),
                                (i = s.stringify(a));
                        }
                        const c = [];
                        let l = s;
                        for (; l; ) c.unshift(l.record), (l = l.parent);
                        return {
                            name: o,
                            path: i,
                            params: a,
                            matched: c,
                            meta: vt(c),
                        };
                    },
                    removeRoute: i,
                    getRoutes: function () {
                        return n;
                    },
                    getRecordMatcher: function (t) {
                        return r.get(t);
                    },
                }
            );
        }
        function yt(t) {
            const e = {},
                n = t.props || !1;
            if ("component" in t) e.default = n;
            else
                for (let r in t.components)
                    e[r] = "boolean" == typeof n ? n : n[r];
            return e;
        }
        function gt(t) {
            for (; t; ) {
                if (t.record.aliasOf) return !0;
                t = t.parent;
            }
            return !1;
        }
        function vt(t) {
            return t.reduce((t, e) => O(t, e.meta), {});
        }
        function bt(t, e) {
            let n = {};
            for (let r in t) n[r] = r in e ? e[r] : t[r];
            return n;
        }
        function xt(t, e) {
            return (
                t.name === e.name &&
                t.optional === e.optional &&
                t.repeatable === e.repeatable
            );
        }
        function wt(t, e) {
            for (let n of t.keys)
                if (!e.keys.find(xt.bind(null, n)))
                    return N(
                        `Alias "${e.record.path}" and the original record: "${t.record.path}" should have the exact same param named "${n.name}"`
                    );
            for (let n of e.keys)
                if (!t.keys.find(xt.bind(null, n)))
                    return N(
                        `Alias "${e.record.path}" and the original record: "${t.record.path}" should have the exact same param named "${n.name}"`
                    );
        }
        function Pt(t, e) {
            for (let n of e.keys)
                if (!t.keys.find(xt.bind(null, n)))
                    return N(
                        `Absolute path "${t.record.path}" should have the exact same param named "${n.name}" as its parent "${e.record.path}".`
                    );
        }
        const At = /#/g,
            Et = /&/g,
            Tt = /\//g,
            St = /=/g,
            Ct = /\?/g,
            Ot = /%5B/g,
            kt = /%5D/g,
            _t = /%5E/g,
            Nt = /%60/g,
            It = /%7B/g,
            jt = /%7C/g,
            Lt = /%7D/g;
        function Mt(t) {
            return encodeURI("" + t)
                .replace(jt, "|")
                .replace(Ot, "[")
                .replace(kt, "]");
        }
        function Rt(t) {
            return Mt(t)
                .replace(At, "%23")
                .replace(Et, "%26")
                .replace(St, "%3D")
                .replace(Nt, "`")
                .replace(It, "{")
                .replace(Lt, "}")
                .replace(_t, "^");
        }
        function Dt(t) {
            return (function (t) {
                return Mt(t).replace(At, "%23").replace(Ct, "%3F");
            })(t).replace(Tt, "%2F");
        }
        function Ft(t) {
            try {
                return decodeURIComponent("" + t);
            } catch (e) {
                N(`Error decoding "${t}". Using original value`);
            }
            return "" + t;
        }
        function Bt(t) {
            const e = {};
            if ("" === t || "?" === t) return e;
            const n = ("?" === t[0] ? t.slice(1) : t).split("&");
            for (let t = 0; t < n.length; ++t) {
                let [r, s] = n[t].split("=");
                r = Ft(r);
                let i = null == s ? null : Ft(s);
                if (r in e) {
                    let t = e[r];
                    Array.isArray(t) || (t = e[r] = [t]), t.push(i);
                } else e[r] = i;
            }
            return e;
        }
        function Ut(t) {
            let e = "";
            for (let n in t) {
                e.length && (e += "&");
                const r = t[n];
                if (((n = Rt(n)), null == r)) {
                    void 0 !== r && (e += n);
                    continue;
                }
                let s = Array.isArray(r)
                    ? r.map((t) => t && Rt(t))
                    : [r && Rt(r)];
                for (let t = 0; t < s.length; t++)
                    (e += (t ? "&" : "") + n),
                        null != s[t] && (e += "=" + s[t]);
            }
            return e;
        }
        function Vt(t) {
            const e = {};
            for (let n in t) {
                let r = t[n];
                void 0 !== r &&
                    (e[n] = Array.isArray(r)
                        ? r.map((t) => (null == t ? null : "" + t))
                        : null == r
                        ? r
                        : "" + r);
            }
            return e;
        }
        function qt() {
            let t = [];
            return {
                add: function (e) {
                    return (
                        t.push(e),
                        () => {
                            const n = t.indexOf(e);
                            n > -1 && t.splice(n, 1);
                        }
                    );
                },
                list: () => t,
                reset: function () {
                    t = [];
                },
            };
        }
        function $t(t, e, n, r, s) {
            const o = r && (r.enterCallbacks[s] = r.enterCallbacks[s] || []);
            return () =>
                new Promise((a, c) => {
                    const l = (t) => {
                        var i;
                        !1 === t
                            ? c(st(4, { from: n, to: e }))
                            : t instanceof Error
                            ? c(t)
                            : "string" == typeof (i = t) ||
                              (i && "object" == typeof i)
                            ? c(st(2, { from: e, to: t }))
                            : (o &&
                                  r.enterCallbacks[s] === o &&
                                  "function" == typeof t &&
                                  o.push(t),
                              a());
                    };
                    let u = Promise.resolve(
                        t.call(
                            r && r.instances[s],
                            e,
                            n,
                            (function (t, e, n) {
                                let r = 0;
                                return function () {
                                    1 == r++ &&
                                        Object(i.r)(
                                            `The "next" callback was called more than once in one navigation guard when going from "${n.fullPath}" to "${e.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`
                                        ),
                                        (t._called = !0),
                                        1 === r && t.apply(null, arguments);
                                };
                            })(l, e, n)
                        )
                    );
                    t.length < 3 && (u = u.then(l)),
                        t.length > 2 &&
                            (u = u.then(
                                () => (
                                    l._called ||
                                        Object(i.r)(
                                            `The "next" callback was never called inside of ${
                                                t.name ? '"' + t.name + '"' : ""
                                            }:\n${t.toString()}\n. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`
                                        ),
                                    Promise.reject(
                                        new Error("Invalid navigation guard")
                                    )
                                )
                            )),
                        u.catch((t) => c(t));
                });
        }
        function zt(t, e, n, r) {
            const s = [];
            for (const a of t)
                for (const t in a.components) {
                    let c = a.components[t];
                    if ("then" in c) {
                        Object(i.r)(
                            `Component "${t}" in record with path "${a.path}" is a Promise instead of a function that returns a Promise. Did you write "import('./MyPage.vue')" instead of "() => import('./MyPage.vue')"? This will break in production if not fixed.`
                        );
                        let e = c;
                        c = () => e;
                    }
                    if ("beforeRouteEnter" === e || a.instances[t])
                        if (
                            "object" == typeof (o = c) ||
                            "displayName" in o ||
                            "props" in o ||
                            "__vccOpts" in o
                        ) {
                            const i = (c.__vccOpts || c)[e];
                            i && s.push($t(i, n, r, a, t));
                        } else {
                            let o = c();
                            "catch" in o
                                ? (o = o.catch(() => null))
                                : (Object(i.r)(
                                      `Component "${t}" in record with path "${a.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`
                                  ),
                                  (o = Promise.resolve(o))),
                                s.push(() =>
                                    o.then((s) => {
                                        if (!s)
                                            return Promise.reject(
                                                new Error(
                                                    `Couldn't resolve component "${t}" for the following record with path "${a.path}"`
                                                )
                                            );
                                        const i =
                                            (o = s).__esModule ||
                                            (w &&
                                                "Module" ===
                                                    o[Symbol.toStringTag])
                                                ? s.default
                                                : s;
                                        var o;
                                        a.components[t] = i;
                                        const c = i[e];
                                        return c && $t(c, n, r, a, t)();
                                    })
                                );
                        }
                }
            var o;
            return s;
        }
        function Ht(t) {
            const e = Object(i.h)(T),
                n = Object(i.h)(S),
                r = Object(i.a)(() => e.resolve(Object(i.q)(t.to))),
                s = Object(i.a)(() => {
                    let { matched: t } = r.value,
                        { length: e } = t;
                    const s = t[e - 1];
                    let i = n.matched;
                    if (!s || !i.length) return -1;
                    let o = i.findIndex(R.bind(null, s));
                    if (o > -1) return o;
                    let a = Gt(t[e - 2]);
                    return e > 1 && Gt(s) === a && i[i.length - 1].path !== a
                        ? i.findIndex(R.bind(null, t[e - 2]))
                        : o;
                }),
                o = Object(i.a)(
                    () =>
                        s.value > -1 &&
                        (function (t, e) {
                            for (let n in e) {
                                let r = e[n],
                                    s = t[n];
                                if ("string" == typeof r) {
                                    if (r !== s) return !1;
                                } else if (
                                    !Array.isArray(s) ||
                                    s.length !== r.length ||
                                    r.some((t, e) => t !== s[e])
                                )
                                    return !1;
                            }
                            return !0;
                        })(n.params, r.value.params)
                ),
                a = Object(i.a)(
                    () =>
                        s.value > -1 &&
                        s.value === n.matched.length - 1 &&
                        D(n.params, r.value.params)
                );
            return {
                route: r,
                href: Object(i.a)(() => r.value.href),
                isActive: o,
                isExactActive: a,
                navigate: function (n = {}) {
                    return (function (t) {
                        if (t.metaKey || t.altKey || t.ctrlKey || t.shiftKey)
                            return;
                        if (t.defaultPrevented) return;
                        if (void 0 !== t.button && 0 !== t.button) return;
                        if (t.currentTarget && t.currentTarget.getAttribute) {
                            const e = t.currentTarget.getAttribute("target");
                            if (/\b_blank\b/i.test(e)) return;
                        }
                        t.preventDefault && t.preventDefault();
                        return !0;
                    })(n)
                        ? e[Object(i.q)(t.replace) ? "replace" : "push"](
                              Object(i.q)(t.to)
                          )
                        : Promise.resolve();
                },
            };
        }
        const Wt = Object(i.e)({
            name: "RouterLink",
            props: {
                to: { type: [String, Object], required: !0 },
                activeClass: String,
                exactActiveClass: String,
                custom: Boolean,
                ariaCurrentValue: { type: String, default: "page" },
            },
            setup(t, { slots: e, attrs: n }) {
                const r = Object(i.m)(Ht(t)),
                    { options: s } = Object(i.h)(T),
                    o = Object(i.a)(() => ({
                        [Kt(
                            t.activeClass,
                            s.linkActiveClass,
                            "router-link-active"
                        )]: r.isActive,
                        [Kt(
                            t.exactActiveClass,
                            s.linkExactActiveClass,
                            "router-link-exact-active"
                        )]: r.isExactActive,
                    }));
                return () => {
                    const s = e.default && e.default(r);
                    return t.custom
                        ? s
                        : Object(i.g)(
                              "a",
                              O(
                                  {
                                      "aria-current": r.isExactActive
                                          ? t.ariaCurrentValue
                                          : null,
                                      onClick: r.navigate,
                                      href: r.href,
                                  },
                                  n,
                                  { class: o.value }
                              ),
                              s
                          );
                };
            },
        });
        function Gt(t) {
            return t ? (t.aliasOf ? t.aliasOf.path : t.path) : "";
        }
        let Kt = (t, e, n) => (null != t ? t : null != e ? e : n);
        const Jt = Object(i.e)({
            name: "RouterView",
            props: {
                name: { type: String, default: "default" },
                route: Object,
            },
            setup(t, { attrs: e, slots: n }) {
                !(function () {
                    const t = Object(i.f)(),
                        e = t.parent && t.parent.type.name;
                    if (e && ("KeepAlive" === e || e.includes("Transition"))) {
                        const t =
                            "KeepAlive" === e ? "keep-alive" : "transition";
                        N(
                            `<router-view> can no longer be used directly inside <transition> or <keep-alive>.\nUse slot props instead:\n\n<router-view v-slot="{ Component }">\n  <${t}>\n    <component :is="Component" />\n  </${t}>\n</router-view>`
                        );
                    }
                })();
                const r = Object(i.h)(S),
                    s = Object(i.h)(E, 0),
                    o = Object(i.a)(() => (t.route || r).matched[s]);
                Object(i.l)(E, s + 1), Object(i.l)(A, o);
                const a = Object(i.n)();
                return () => {
                    const s = t.route || r,
                        c = o.value,
                        l = c && c.components[t.name];
                    if (!l)
                        return n.default
                            ? n.default({ Component: l, route: s })
                            : null;
                    const u = c.props[t.name],
                        h = u
                            ? !0 === u
                                ? s.params
                                : "function" == typeof u
                                ? u(s)
                                : u
                            : null,
                        p = t.name,
                        d = Object(i.g)(
                            l,
                            O({}, h, e, {
                                onVnodeMounted: () => {
                                    (c.instances[p] = a.value),
                                        (c.enterCallbacks[p] || []).forEach(
                                            (t) => t(a.value)
                                        );
                                },
                                onVnodeUnmounted: () => {
                                    c.instances[p] = null;
                                },
                                ref: a,
                            })
                        );
                    return n.default
                        ? n.default({ Component: d, route: s })
                        : d;
                };
            },
        });
        function Xt(t) {
            return t.reduce((t, e) => t.then(() => e()), Promise.resolve());
        }
        function Yt(t, e) {
            const n = [],
                r = [],
                s = [],
                i = Math.max(e.matched.length, t.matched.length);
            for (let o = 0; o < i; o++) {
                const i = e.matched[o];
                i && (t.matched.indexOf(i) < 0 ? n.push(i) : r.push(i));
                const a = t.matched[o];
                a && e.matched.indexOf(a) < 0 && s.push(a);
            }
            return [n, r, s];
        }
        var Qt = function (t, e, n, r) {
                return new (n || (n = Promise))(function (s, i) {
                    function o(t) {
                        try {
                            c(r.next(t));
                        } catch (t) {
                            i(t);
                        }
                    }
                    function a(t) {
                        try {
                            c(r.throw(t));
                        } catch (t) {
                            i(t);
                        }
                    }
                    function c(t) {
                        var e;
                        t.done
                            ? s(t.value)
                            : ((e = t.value),
                              e instanceof n
                                  ? e
                                  : new n(function (t) {
                                        t(e);
                                    })).then(o, a);
                    }
                    c((r = r.apply(t, e || [])).next());
                });
            },
            Zt = function (t) {
                t.commit(s.CLEAR_FILES);
            },
            te = function () {
                var t = xn.currentRoute.value;
                return "/" + String(t.params.path);
            },
            ee = function (t, e) {
                return Qt(
                    this,
                    void 0,
                    void 0,
                    regeneratorRuntime.mark(function n() {
                        var r;
                        return regeneratorRuntime.wrap(function (n) {
                            for (;;)
                                switch ((n.prev = n.next)) {
                                    case 0:
                                        if (
                                            "search" !==
                                            xn.currentRoute.value.name
                                        ) {
                                            n.next = 10;
                                            break;
                                        }
                                        return (
                                            (t.state.loading = !0),
                                            (r = t.getters.getfiles.length),
                                            30,
                                            t.commit(
                                                s.UPDATE_FILES,
                                                t.getters.getsearched.slice(
                                                    r,
                                                    r + 30
                                                )
                                            ),
                                            (t.state.loading = !1),
                                            t.getters.getsearched.length ===
                                                r && (t.state.atend = !0),
                                            n.abrupt("return", !0)
                                        );
                                    case 10:
                                        if (
                                            !t.state.loading &&
                                            !t.state.atend
                                        ) {
                                            n.next = 12;
                                            break;
                                        }
                                        return n.abrupt("return");
                                    case 12:
                                        return (
                                            (t.state.loading = !0),
                                            n.abrupt(
                                                "return",
                                                t
                                                    .dispatch(m.GET_FILES, {
                                                        location: e,
                                                        skip: t.state.files
                                                            .length,
                                                    })
                                                    .then(function (e) {
                                                        (t.state.loading = !1),
                                                            0 == e.length &&
                                                                (t.state.atend =
                                                                    !0);
                                                    })
                                            )
                                        );
                                    case 14:
                                    case "end":
                                        return n.stop();
                                }
                        }, n);
                    })
                );
            };
        function ne(t) {
            window.dispatchEvent(
                new CustomEvent("export-files", { detail: t })
            );
        }
        const re = "transitionend",
            se = (t) => {
                let e = t.getAttribute("data-target");
                if (!e || "#" === e) {
                    const n = t.getAttribute("href");
                    e = n && "#" !== n ? n.trim() : null;
                }
                return e;
            },
            ie = (t) => {
                if (!t) return 0;
                let { transitionDuration: e, transitionDelay: n } =
                    window.getComputedStyle(t);
                const r = parseFloat(e),
                    s = parseFloat(n);
                return r || s
                    ? ((e = e.split(",")[0]),
                      (n = n.split(",")[0]),
                      1e3 * (parseFloat(e) + parseFloat(n)))
                    : 0;
            },
            oe = (t, e) => {
                let n = !1;
                const r = e + 5;
                t.addEventListener(re, function e() {
                    (n = !0), t.removeEventListener(re, e);
                }),
                    setTimeout(() => {
                        n ||
                            ((t) => {
                                t.dispatchEvent(new Event(re));
                            })(t);
                    }, r);
            },
            ae = (t) => t.offsetHeight,
            ce = () => {
                const { jQuery: t } = window;
                return t && !document.body.hasAttribute("data-no-jquery")
                    ? t
                    : null;
            },
            le = (() => {
                const t = {};
                let e = 1;
                return {
                    set(n, r, s) {
                        void 0 === n.key && ((n.key = { key: r, id: e }), e++),
                            (t[n.key.id] = s);
                    },
                    get(e, n) {
                        if (!e || void 0 === e.key) return null;
                        const r = e.key;
                        return r.key === n ? t[r.id] : null;
                    },
                    delete(e, n) {
                        if (void 0 === e.key) return;
                        const r = e.key;
                        r.key === n && (delete t[r.id], delete e.key);
                    },
                };
            })();
        var ue = {
            setData(t, e, n) {
                le.set(t, e, n);
            },
            getData: (t, e) => le.get(t, e),
            removeData(t, e) {
                le.delete(t, e);
            },
        };
        let he = Element.prototype.querySelectorAll,
            pe = Element.prototype.querySelector;
        const de = (() => {
                const t = new CustomEvent("Bootstrap", { cancelable: !0 }),
                    e = document.createElement("div");
                return (
                    e.addEventListener("Bootstrap", () => null),
                    t.preventDefault(),
                    e.dispatchEvent(t),
                    t.defaultPrevented
                );
            })(),
            fe = /:scope\b/;
        (() => {
            const t = document.createElement("div");
            try {
                t.querySelectorAll(":scope *");
            } catch (t) {
                return !1;
            }
            return !0;
        })() ||
            ((he = function (t) {
                if (!fe.test(t)) return this.querySelectorAll(t);
                const e = Boolean(this.id);
                e ||
                    (this.id = ((t) => {
                        do {
                            t += Math.floor(1e6 * Math.random());
                        } while (document.getElementById(t));
                        return t;
                    })("scope"));
                let n = null;
                try {
                    (t = t.replace(fe, "#" + this.id)),
                        (n = this.querySelectorAll(t));
                } finally {
                    e || this.removeAttribute("id");
                }
                return n;
            }),
            (pe = function (t) {
                if (!fe.test(t)) return this.querySelector(t);
                const e = he.call(this, t);
                return void 0 !== e[0] ? e[0] : null;
            }));
        const me = ce(),
            ye = /[^.]*(?=\..*)\.|.*/,
            ge = /\..*/,
            ve = /::\d+$/,
            be = {};
        let xe = 1;
        const we = { mouseenter: "mouseover", mouseleave: "mouseout" },
            Pe = [
                "click",
                "dblclick",
                "mouseup",
                "mousedown",
                "contextmenu",
                "mousewheel",
                "DOMMouseScroll",
                "mouseover",
                "mouseout",
                "mousemove",
                "selectstart",
                "selectend",
                "keydown",
                "keypress",
                "keyup",
                "orientationchange",
                "touchstart",
                "touchmove",
                "touchend",
                "touchcancel",
                "pointerdown",
                "pointermove",
                "pointerup",
                "pointerleave",
                "pointercancel",
                "gesturestart",
                "gesturechange",
                "gestureend",
                "focus",
                "blur",
                "change",
                "reset",
                "select",
                "submit",
                "focusin",
                "focusout",
                "load",
                "unload",
                "beforeunload",
                "resize",
                "move",
                "DOMContentLoaded",
                "readystatechange",
                "error",
                "abort",
                "scroll",
            ];
        function Ae(t, e) {
            return (e && `${e}::${xe++}`) || t.uidEvent || xe++;
        }
        function Ee(t) {
            const e = Ae(t);
            return (t.uidEvent = e), (be[e] = be[e] || {}), be[e];
        }
        function Te(t, e, n = null) {
            const r = Object.keys(t);
            for (let s = 0, i = r.length; s < i; s++) {
                const i = t[r[s]];
                if (i.originalHandler === e && i.delegationSelector === n)
                    return i;
            }
            return null;
        }
        function Se(t, e, n) {
            const r = "string" == typeof e,
                s = r ? n : e;
            let i = t.replace(ge, "");
            const o = we[i];
            o && (i = o);
            return Pe.indexOf(i) > -1 || (i = t), [r, s, i];
        }
        function Ce(t, e, n, r, s) {
            if ("string" != typeof e || !t) return;
            n || ((n = r), (r = null));
            const [i, o, a] = Se(e, n, r),
                c = Ee(t),
                l = c[a] || (c[a] = {}),
                u = Te(l, o, i ? n : null);
            if (u) return void (u.oneOff = u.oneOff && s);
            const h = Ae(o, e.replace(ye, "")),
                p = i
                    ? (function (t, e, n) {
                          return function r(s) {
                              const i = t.querySelectorAll(e);
                              for (
                                  let { target: e } = s;
                                  e && e !== this;
                                  e = e.parentNode
                              )
                                  for (let o = i.length; o--; )
                                      if (i[o] === e)
                                          return (
                                              r.oneOff && ke.off(t, s.type, n),
                                              n.apply(e, [s])
                                          );
                              return null;
                          };
                      })(t, n, r)
                    : (function (t, e) {
                          return function n(r) {
                              return (
                                  n.oneOff && ke.off(t, r.type, e),
                                  e.apply(t, [r])
                              );
                          };
                      })(t, n);
            (p.delegationSelector = i ? n : null),
                (p.originalHandler = o),
                (p.oneOff = s),
                (p.uidEvent = h),
                (l[h] = p),
                t.addEventListener(a, p, i);
        }
        function Oe(t, e, n, r, s) {
            const i = Te(e[n], r, s);
            i &&
                (t.removeEventListener(n, i, Boolean(s)),
                delete e[n][i.uidEvent]);
        }
        const ke = {
            on(t, e, n, r) {
                Ce(t, e, n, r, !1);
            },
            one(t, e, n, r) {
                Ce(t, e, n, r, !0);
            },
            off(t, e, n, r) {
                if ("string" != typeof e || !t) return;
                const [s, i, o] = Se(e, n, r),
                    a = o !== e,
                    c = Ee(t),
                    l = "." === e.charAt(0);
                if (void 0 !== i) {
                    if (!c || !c[o]) return;
                    return void Oe(t, c, o, i, s ? n : null);
                }
                l &&
                    Object.keys(c).forEach((n) => {
                        !(function (t, e, n, r) {
                            const s = e[n] || {};
                            Object.keys(s).forEach((i) => {
                                if (i.indexOf(r) > -1) {
                                    const r = s[i];
                                    Oe(
                                        t,
                                        e,
                                        n,
                                        r.originalHandler,
                                        r.delegationSelector
                                    );
                                }
                            });
                        })(t, c, n, e.slice(1));
                    });
                const u = c[o] || {};
                Object.keys(u).forEach((n) => {
                    const r = n.replace(ve, "");
                    if (!a || e.indexOf(r) > -1) {
                        const e = u[n];
                        Oe(t, c, o, e.originalHandler, e.delegationSelector);
                    }
                });
            },
            trigger(t, e, n) {
                if ("string" != typeof e || !t) return null;
                const r = e.replace(ge, ""),
                    s = e !== r,
                    i = Pe.indexOf(r) > -1;
                let o,
                    a = !0,
                    c = !0,
                    l = !1,
                    u = null;
                return (
                    s &&
                        me &&
                        ((o = me.Event(e, n)),
                        me(t).trigger(o),
                        (a = !o.isPropagationStopped()),
                        (c = !o.isImmediatePropagationStopped()),
                        (l = o.isDefaultPrevented())),
                    i
                        ? ((u = document.createEvent("HTMLEvents")),
                          u.initEvent(r, a, !0))
                        : (u = new CustomEvent(e, {
                              bubbles: a,
                              cancelable: !0,
                          })),
                    void 0 !== n &&
                        Object.keys(n).forEach((t) => {
                            Object.defineProperty(u, t, { get: () => n[t] });
                        }),
                    l &&
                        (u.preventDefault(),
                        de ||
                            Object.defineProperty(u, "defaultPrevented", {
                                get: () => !0,
                            })),
                    c && t.dispatchEvent(u),
                    u.defaultPrevented && void 0 !== o && o.preventDefault(),
                    u
                );
            },
        };
        var _e = ke;
        function Ne(t) {
            return (
                "true" === t ||
                ("false" !== t &&
                    (t === Number(t).toString()
                        ? Number(t)
                        : "" === t || "null" === t
                        ? null
                        : t))
            );
        }
        function Ie(t) {
            return t.replace(/[A-Z]/g, (t) => "-" + t.toLowerCase());
        }
        var je = {
            setDataAttribute(t, e, n) {
                t.setAttribute("data-" + Ie(e), n);
            },
            removeDataAttribute(t, e) {
                t.removeAttribute("data-" + Ie(e));
            },
            getDataAttributes(t) {
                if (!t) return {};
                const e = { ...t.dataset };
                return (
                    Object.keys(e).forEach((t) => {
                        e[t] = Ne(e[t]);
                    }),
                    e
                );
            },
            getDataAttribute: (t, e) => Ne(t.getAttribute("data-" + Ie(e))),
            offset(t) {
                const e = t.getBoundingClientRect();
                return {
                    top: e.top + document.body.scrollTop,
                    left: e.left + document.body.scrollLeft,
                };
            },
            position: (t) => ({ top: t.offsetTop, left: t.offsetLeft }),
            toggleClass(t, e) {
                t &&
                    (t.classList.contains(e)
                        ? t.classList.remove(e)
                        : t.classList.add(e));
            },
        };
        var Le = {
            matches: (t, e) => t.matches(e),
            find: (t, e = document.documentElement) =>
                [].concat(...he.call(e, t)),
            findOne: (t, e = document.documentElement) => pe.call(e, t),
            children: (t, e) =>
                [].concat(...t.children).filter((t) => t.matches(e)),
            parents(t, e) {
                const n = [];
                let r = t.parentNode;
                for (
                    ;
                    r && r.nodeType === Node.ELEMENT_NODE && 3 !== r.nodeType;

                )
                    this.matches(r, e) && n.push(r), (r = r.parentNode);
                return n;
            },
            prev(t, e) {
                let n = t.previousElementSibling;
                for (; n; ) {
                    if (n.matches(e)) return [n];
                    n = n.previousElementSibling;
                }
                return [];
            },
            next(t, e) {
                let n = t.nextElementSibling;
                for (; n; ) {
                    if (this.matches(n, e)) return [n];
                    n = n.nextElementSibling;
                }
                return [];
            },
        };
        const Me = "modal",
            Re = "bs.modal",
            De = ".bs.modal",
            Fe = "Escape",
            Be = { backdrop: !0, keyboard: !0, focus: !0, show: !0 },
            Ue = {
                backdrop: "(boolean|string)",
                keyboard: "boolean",
                focus: "boolean",
                show: "boolean",
            },
            Ve = "hidden.bs.modal",
            qe = "show.bs.modal",
            $e = "focusin.bs.modal",
            ze = "resize.bs.modal",
            He = "click.dismiss.bs.modal",
            We = "keydown.dismiss.bs.modal",
            Ge = "mousedown.dismiss.bs.modal",
            Ke = "modal-open",
            Je = "fade",
            Xe = "show",
            Ye = "modal-static",
            Qe = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
            Ze = ".sticky-top";
        class tn {
            constructor(t, e) {
                (this._config = this._getConfig(e)),
                    (this._element = t),
                    (this._dialog = Le.findOne(".modal-dialog", t)),
                    (this._backdrop = null),
                    (this._isShown = !1),
                    (this._isBodyOverflowing = !1),
                    (this._ignoreBackdropClick = !1),
                    (this._isTransitioning = !1),
                    (this._scrollbarWidth = 0),
                    ue.setData(t, Re, this);
            }
            static get VERSION() {
                return "5.0.0-alpha1";
            }
            static get Default() {
                return Be;
            }
            toggle(t) {
                return this._isShown ? this.hide() : this.show(t);
            }
            show(t) {
                if (this._isShown || this._isTransitioning) return;
                this._element.classList.contains(Je) &&
                    (this._isTransitioning = !0);
                const e = _e.trigger(this._element, qe, { relatedTarget: t });
                this._isShown ||
                    e.defaultPrevented ||
                    ((this._isShown = !0),
                    this._checkScrollbar(),
                    this._setScrollbar(),
                    this._adjustDialog(),
                    this._setEscapeEvent(),
                    this._setResizeEvent(),
                    _e.on(this._element, He, '[data-dismiss="modal"]', (t) =>
                        this.hide(t)
                    ),
                    _e.on(this._dialog, Ge, () => {
                        _e.one(
                            this._element,
                            "mouseup.dismiss.bs.modal",
                            (t) => {
                                t.target === this._element &&
                                    (this._ignoreBackdropClick = !0);
                            }
                        );
                    }),
                    this._showBackdrop(() => this._showElement(t)));
            }
            hide(t) {
                if (
                    (t && t.preventDefault(),
                    !this._isShown || this._isTransitioning)
                )
                    return;
                if (_e.trigger(this._element, "hide.bs.modal").defaultPrevented)
                    return;
                this._isShown = !1;
                const e = this._element.classList.contains(Je);
                if (
                    (e && (this._isTransitioning = !0),
                    this._setEscapeEvent(),
                    this._setResizeEvent(),
                    _e.off(document, $e),
                    this._element.classList.remove(Xe),
                    _e.off(this._element, He),
                    _e.off(this._dialog, Ge),
                    e)
                ) {
                    const t = ie(this._element);
                    _e.one(this._element, re, (t) => this._hideModal(t)),
                        oe(this._element, t);
                } else this._hideModal();
            }
            dispose() {
                [window, this._element, this._dialog].forEach((t) =>
                    _e.off(t, De)
                ),
                    _e.off(document, $e),
                    ue.removeData(this._element, Re),
                    (this._config = null),
                    (this._element = null),
                    (this._dialog = null),
                    (this._backdrop = null),
                    (this._isShown = null),
                    (this._isBodyOverflowing = null),
                    (this._ignoreBackdropClick = null),
                    (this._isTransitioning = null),
                    (this._scrollbarWidth = null);
            }
            handleUpdate() {
                this._adjustDialog();
            }
            _getConfig(t) {
                return (
                    (t = { ...Be, ...t }),
                    ((t, e, n) => {
                        Object.keys(n).forEach((r) => {
                            const s = n[r],
                                i = e[r],
                                o =
                                    i && ((a = i)[0] || a).nodeType
                                        ? "element"
                                        : ((t) =>
                                              null == t
                                                  ? "" + t
                                                  : {}.toString
                                                        .call(t)
                                                        .match(/\s([a-z]+)/i)[1]
                                                        .toLowerCase())(i);
                            var a;
                            if (!new RegExp(s).test(o))
                                throw new Error(
                                    t.toUpperCase() +
                                        ": " +
                                        `Option "${r}" provided type "${o}" ` +
                                        `but expected type "${s}".`
                                );
                        });
                    })(Me, t, Ue),
                    t
                );
            }
            _showElement(t) {
                const e = this._element.classList.contains(Je),
                    n = Le.findOne(".modal-body", this._dialog);
                (this._element.parentNode &&
                    this._element.parentNode.nodeType === Node.ELEMENT_NODE) ||
                    document.body.appendChild(this._element),
                    (this._element.style.display = "block"),
                    this._element.removeAttribute("aria-hidden"),
                    this._element.setAttribute("aria-modal", !0),
                    this._element.setAttribute("role", "dialog"),
                    (this._element.scrollTop = 0),
                    n && (n.scrollTop = 0),
                    e && ae(this._element),
                    this._element.classList.add(Xe),
                    this._config.focus && this._enforceFocus();
                const r = () => {
                    this._config.focus && this._element.focus(),
                        (this._isTransitioning = !1),
                        _e.trigger(this._element, "shown.bs.modal", {
                            relatedTarget: t,
                        });
                };
                if (e) {
                    const t = ie(this._dialog);
                    _e.one(this._dialog, re, r), oe(this._dialog, t);
                } else r();
            }
            _enforceFocus() {
                _e.off(document, $e),
                    _e.on(document, $e, (t) => {
                        document === t.target ||
                            this._element === t.target ||
                            this._element.contains(t.target) ||
                            this._element.focus();
                    });
            }
            _setEscapeEvent() {
                this._isShown
                    ? _e.on(this._element, We, (t) => {
                          this._config.keyboard && t.key === Fe
                              ? (t.preventDefault(), this.hide())
                              : this._config.keyboard ||
                                t.key !== Fe ||
                                this._triggerBackdropTransition();
                      })
                    : _e.off(this._element, We);
            }
            _setResizeEvent() {
                this._isShown
                    ? _e.on(window, ze, () => this._adjustDialog())
                    : _e.off(window, ze);
            }
            _hideModal() {
                (this._element.style.display = "none"),
                    this._element.setAttribute("aria-hidden", !0),
                    this._element.removeAttribute("aria-modal"),
                    this._element.removeAttribute("role"),
                    (this._isTransitioning = !1),
                    this._showBackdrop(() => {
                        document.body.classList.remove(Ke),
                            this._resetAdjustments(),
                            this._resetScrollbar(),
                            _e.trigger(this._element, Ve);
                    });
            }
            _removeBackdrop() {
                this._backdrop.parentNode.removeChild(this._backdrop),
                    (this._backdrop = null);
            }
            _showBackdrop(t) {
                const e = this._element.classList.contains(Je) ? Je : "";
                if (this._isShown && this._config.backdrop) {
                    if (
                        ((this._backdrop = document.createElement("div")),
                        (this._backdrop.className = "modal-backdrop"),
                        e && this._backdrop.classList.add(e),
                        document.body.appendChild(this._backdrop),
                        _e.on(this._element, He, (t) => {
                            this._ignoreBackdropClick
                                ? (this._ignoreBackdropClick = !1)
                                : t.target === t.currentTarget &&
                                  this._triggerBackdropTransition();
                        }),
                        e && ae(this._backdrop),
                        this._backdrop.classList.add(Xe),
                        !e)
                    )
                        return void t();
                    const n = ie(this._backdrop);
                    _e.one(this._backdrop, re, t), oe(this._backdrop, n);
                } else if (!this._isShown && this._backdrop) {
                    this._backdrop.classList.remove(Xe);
                    const e = () => {
                        this._removeBackdrop(), t();
                    };
                    if (this._element.classList.contains(Je)) {
                        const t = ie(this._backdrop);
                        _e.one(this._backdrop, re, e), oe(this._backdrop, t);
                    } else e();
                } else t();
            }
            _triggerBackdropTransition() {
                if ("static" === this._config.backdrop) {
                    if (
                        _e.trigger(this._element, "hidePrevented.bs.modal")
                            .defaultPrevented
                    )
                        return;
                    this._element.classList.add(Ye);
                    const t = ie(this._element);
                    _e.one(this._element, re, () => {
                        this._element.classList.remove(Ye);
                    }),
                        oe(this._element, t),
                        this._element.focus();
                } else this.hide();
            }
            _adjustDialog() {
                const t =
                    this._element.scrollHeight >
                    document.documentElement.clientHeight;
                !this._isBodyOverflowing &&
                    t &&
                    (this._element.style.paddingLeft =
                        this._scrollbarWidth + "px"),
                    this._isBodyOverflowing &&
                        !t &&
                        (this._element.style.paddingRight =
                            this._scrollbarWidth + "px");
            }
            _resetAdjustments() {
                (this._element.style.paddingLeft = ""),
                    (this._element.style.paddingRight = "");
            }
            _checkScrollbar() {
                const t = document.body.getBoundingClientRect();
                (this._isBodyOverflowing =
                    Math.round(t.left + t.right) < window.innerWidth),
                    (this._scrollbarWidth = this._getScrollbarWidth());
            }
            _setScrollbar() {
                if (this._isBodyOverflowing) {
                    Le.find(Qe).forEach((t) => {
                        const e = t.style.paddingRight,
                            n = window.getComputedStyle(t)["padding-right"];
                        je.setDataAttribute(t, "padding-right", e),
                            (t.style.paddingRight =
                                parseFloat(n) + this._scrollbarWidth + "px");
                    }),
                        Le.find(Ze).forEach((t) => {
                            const e = t.style.marginRight,
                                n = window.getComputedStyle(t)["margin-right"];
                            je.setDataAttribute(t, "margin-right", e),
                                (t.style.marginRight =
                                    parseFloat(n) -
                                    this._scrollbarWidth +
                                    "px");
                        });
                    const t = document.body.style.paddingRight,
                        e = window.getComputedStyle(document.body)[
                            "padding-right"
                        ];
                    je.setDataAttribute(document.body, "padding-right", t),
                        (document.body.style.paddingRight =
                            parseFloat(e) + this._scrollbarWidth + "px");
                }
                document.body.classList.add(Ke);
            }
            _resetScrollbar() {
                Le.find(Qe).forEach((t) => {
                    const e = je.getDataAttribute(t, "padding-right");
                    void 0 !== e &&
                        (je.removeDataAttribute(t, "padding-right"),
                        (t.style.paddingRight = e));
                }),
                    Le.find(".sticky-top").forEach((t) => {
                        const e = je.getDataAttribute(t, "margin-right");
                        void 0 !== e &&
                            (je.removeDataAttribute(t, "margin-right"),
                            (t.style.marginRight = e));
                    });
                const t = je.getDataAttribute(document.body, "padding-right");
                void 0 === t
                    ? (document.body.style.paddingRight = "")
                    : (je.removeDataAttribute(document.body, "padding-right"),
                      (document.body.style.paddingRight = t));
            }
            _getScrollbarWidth() {
                const t = document.createElement("div");
                (t.className = "modal-scrollbar-measure"),
                    document.body.appendChild(t);
                const e = t.getBoundingClientRect().width - t.clientWidth;
                return document.body.removeChild(t), e;
            }
            static jQueryInterface(t, e) {
                return this.each(function () {
                    let n = ue.getData(this, Re);
                    const r = {
                        ...Be,
                        ...je.getDataAttributes(this),
                        ...("object" == typeof t && t ? t : {}),
                    };
                    if ((n || (n = new tn(this, r)), "string" == typeof t)) {
                        if (void 0 === n[t])
                            throw new TypeError(`No method named "${t}"`);
                        n[t](e);
                    } else r.show && n.show(e);
                });
            }
            static getInstance(t) {
                return ue.getData(t, Re);
            }
        }
        _e.on(
            document,
            "click.bs.modal.data-api",
            '[data-toggle="modal"]',
            function (t) {
                const e = ((t) => {
                    const e = se(t);
                    return e ? document.querySelector(e) : null;
                })(this);
                ("A" !== this.tagName && "AREA" !== this.tagName) ||
                    t.preventDefault(),
                    _e.one(e, qe, (t) => {
                        t.defaultPrevented ||
                            _e.one(e, Ve, () => {
                                ((t) => {
                                    if (!t) return !1;
                                    if (
                                        t.style &&
                                        t.parentNode &&
                                        t.parentNode.style
                                    ) {
                                        const e = getComputedStyle(t),
                                            n = getComputedStyle(t.parentNode);
                                        return (
                                            "none" !== e.display &&
                                            "none" !== n.display &&
                                            "hidden" !== e.visibility
                                        );
                                    }
                                    return !1;
                                })(this) && this.focus();
                            });
                    });
                let n = ue.getData(e, Re);
                if (!n) {
                    const t = {
                        ...je.getDataAttributes(e),
                        ...je.getDataAttributes(this),
                    };
                    n = new tn(e, t);
                }
                n.show(this);
            }
        );
        const en = ce();
        if (en) {
            const t = en.fn.modal;
            (en.fn.modal = tn.jQueryInterface),
                (en.fn.modal.Constructor = tn),
                (en.fn.modal.noConflict = () => (
                    (en.fn.modal = t), tn.jQueryInterface
                ));
        }
        var nn = tn,
            rn = Object(i.e)({
                props: { selector: { type: String, required: !0 } },
                setup: function (t) {
                    var e = t.selector,
                        n = Object(i.n)(null),
                        r = null,
                        s = null,
                        o = null,
                        a = e.slice(1) + "-modal",
                        l = function () {
                            n.value.reset();
                        };
                    return (
                        Object(i.k)(function () {
                            ((r = document.querySelector(e)).dataset.target =
                                e + "-modal"),
                                (r.dataset.toggle = "modal"),
                                (o = document.querySelector(r.dataset.target)),
                                (s = new nn(o)),
                                (r.onclick = function () {
                                    return s.show();
                                }),
                                o.addEventListener("hidden.bs.modal", l);
                        }),
                        Object(i.j)(function () {
                            s.dispose(),
                                o.removeEventListener("hidden.bs.modal", l);
                        }),
                        {
                            modal_id: a,
                            form: n,
                            createDirectory: function (t) {
                                t.preventDefault();
                                var e = new FormData(n.value);
                                e.append(
                                    "location",
                                    "/" + xn.currentRoute.value.params.path
                                ),
                                    c()({
                                        url: "/admin/mmanager/create-directory/",
                                        method: "POST",
                                        data: e,
                                    })
                                        .then(function (t) {
                                            xn.push(
                                                "/location" + t.data.location
                                            );
                                        })
                                        .catch(function (t) {
                                            console.log(t);
                                        })
                                        .finally(function () {
                                            s.hide();
                                        });
                            },
                        }
                    );
                },
                render: function () {
                    return Object(i.d)(
                        "div",
                        {
                            class: "modal fade",
                            id: this.modal_id,
                            tabindex: -1,
                        },
                        [
                            Object(i.d)("div", { class: "modal-dialog" }, [
                                Object(i.d)("div", { class: "modal-content" }, [
                                    Object(i.d)(
                                        "div",
                                        { class: "modal-header" },
                                        [
                                            Object(i.d)(
                                                "h5",
                                                {
                                                    class: "modal-title arial-caps",
                                                },
                                                [Object(i.c)(" ")]
                                            ),
                                            Object(i.d)(
                                                "button",
                                                {
                                                    type: "button",
                                                    class: "close outline-none",
                                                    "data-dismiss": "modal",
                                                },
                                                [
                                                    Object(i.d)(
                                                        "span",
                                                        {
                                                            "aria-hidden":
                                                                "true",
                                                        },
                                                        [Object(i.c)("")]
                                                    ),
                                                ]
                                            ),
                                        ]
                                    ),
                                    Object(i.d)(
                                        "form",
                                        {
                                            ref: "form",
                                            onSubmit: this.createDirectory,
                                        },
                                        [
                                            Object(i.d)(
                                                "div",
                                                { class: "modal-body" },
                                                [
                                                    Object(i.d)(
                                                        "input",
                                                        {
                                                            autocomplete: "off",
                                                            name: "name",
                                                            type: "text",
                                                            required: !0,
                                                            placeholder:
                                                                "",
                                                            class: "arial form-control",
                                                        },
                                                        null
                                                    ),
                                                ]
                                            ),
                                            Object(i.d)(
                                                "div",
                                                { class: "modal-footer" },
                                                [
                                                    Object(i.d)(
                                                        "button",
                                                        {
                                                            type: "button",
                                                            class: "btn btn-light arial-caps",
                                                            "data-dismiss":
                                                                "modal",
                                                        },
                                                        [
                                                            Object(i.c)(
                                                                ""
                                                            ),
                                                        ]
                                                    ),
                                                    Object(i.d)(
                                                        "button",
                                                        {
                                                            type: "submit",
                                                            class: "btn btn-primary arial-caps",
                                                        },
                                                        [Object(i.c)("")]
                                                    ),
                                                ]
                                            ),
                                        ]
                                    ),
                                ]),
                            ]),
                        ]
                    );
                },
            });
        function sn(t) {
            return (
                (function (t) {
                    if (Array.isArray(t)) return on(t);
                })(t) ||
                (function (t) {
                    if (
                        "undefined" != typeof Symbol &&
                        Symbol.iterator in Object(t)
                    )
                        return Array.from(t);
                })(t) ||
                (function (t, e) {
                    if (!t) return;
                    if ("string" == typeof t) return on(t, e);
                    var n = Object.prototype.toString.call(t).slice(8, -1);
                    "Object" === n && t.constructor && (n = t.constructor.name);
                    if ("Map" === n || "Set" === n) return Array.from(t);
                    if (
                        "Arguments" === n ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                    )
                        return on(t, e);
                })(t) ||
                (function () {
                    throw new TypeError(
                        "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                    );
                })()
            );
        }
        function on(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
            return r;
        }
        function an(t) {
            t.stopPropagation(), t.preventDefault();
        }
        function cn(t) {
            var e,
                n = null;
            void 0 !== t.dataTransfer
                ? (an(t), (n = t.dataTransfer.files))
                : (n = t.target.files);
            var r = Array.from(n).map(function (t) {
                return {
                    f: t,
                    name: t.name,
                    size: t.size,
                    url: URL.createObjectURL(t),
                };
            });
            (e = this.state.files).push.apply(e, sn(r));
        }
        var ln = Object(i.e)({
                props: { selector: { type: String, required: !0 } },
                setup: function (t) {
                    var e = t.selector,
                        n = Object(i.n)(null),
                        r = Object(i.m)({ files: [], loading: !1 }),
                        s = null,
                        o = null,
                        a = null,
                        l = e.slice(1) + "-modal",
                        u = function () {
                            n.value.reset(), (r.files = []);
                        };
                    return (
                        Object(i.k)(function () {
                            ((s = document.querySelector(e)).dataset.target =
                                e + "-modal"),
                                (s.dataset.toggle = "modal"),
                                (a = document.querySelector(s.dataset.target)),
                                (o = new nn(a, { backdrop: "static" })),
                                (s.onclick = function () {
                                    return o.show();
                                }),
                                a.addEventListener("hidden.bs.modal", u);
                        }),
                        Object(i.j)(function () {
                            o.dispose(),
                                a.removeEventListener("hidden.bs.modal", u);
                        }),
                        {
                            modal_id: l,
                            form: n,
                            state: r,
                            isImg: function (t) {
                                return /\.(jpg|png|gif|svg)$/.test(t);
                            },
                            uploadFiles: function (t) {
                                t.preventDefault();
                                var e = new FormData(n.value);
                                e.append(
                                    "location",
                                    "/" + xn.currentRoute.value.params.path
                                ),
                                    r.files.forEach(function (t) {
                                        e.append("upload_files", t.f);
                                    }),
                                    (r.loading = !0),
                                    c()({
                                        url: "/admin/mmanager/upload-file/",
                                        method: "POST",
                                        data: e,
                                    })
                                        .then(function (t) {
                                            var n = t.data.files,
                                                r = t.data.location,
                                                s =
                                                    (t.data.msg,
                                                    "on" ==
                                                        e.get(
                                                            "upload_in_current_dir"
                                                        ));
                                            ne(n),
                                                s
                                                    ? window.dispatchEvent(
                                                          new Event(
                                                              "update-files"
                                                          )
                                                      )
                                                    : xn.push("/location" + r);
                                        })
                                        .catch(function (t) {
                                            console.log(t);
                                        })
                                        .finally(function () {
                                            (r.loading = !1), o.hide();
                                        });
                            },
                        }
                    );
                },
                render: function () {
                    var t = this;
                    return Object(i.d)(
                        "div",
                        {
                            class: "modal fade",
                            id: this.modal_id,
                            tabindex: -1,
                        },
                        [
                            Object(i.d)(
                                "div",
                                { class: "modal-dialog modal-lg" },
                                [
                                    Object(i.d)(
                                        "div",
                                        { class: "modal-content" },
                                        [
                                            Object(i.d)(
                                                "div",
                                                { class: "modal-header" },
                                                [
                                                    Object(i.d)(
                                                        "h5",
                                                        {
                                                            class: "modal-title arial-caps",
                                                        },
                                                        [
                                                            Object(i.c)(
                                                                " "
                                                            ),
                                                        ]
                                                    ),
                                                    Object(i.d)(
                                                        "button",
                                                        {
                                                            type: "button",
                                                            class: "close outline-none",
                                                            "data-dismiss":
                                                                "modal",
                                                        },
                                                        [
                                                            Object(i.d)(
                                                                "span",
                                                                {
                                                                    "aria-hidden":
                                                                        "true",
                                                                },
                                                                [
                                                                    Object(i.c)(
                                                                        ""
                                                                    ),
                                                                ]
                                                            ),
                                                        ]
                                                    ),
                                                ]
                                            ),
                                            Object(i.d)(
                                                "form",
                                                {
                                                    ref: "form",
                                                    onSubmit: this.uploadFiles,
                                                    onDragenter: an,
                                                    onDragstart: an,
                                                    onDragend: an,
                                                    onDragleave: an,
                                                    onDragover: an,
                                                    onDrag: an,
                                                    onDrop: cn.bind(this),
                                                },
                                                [
                                                    Object(i.d)(
                                                        "div",
                                                        { class: "modal-body" },
                                                        [
                                                            Object(i.d)(
                                                                "div",
                                                                {
                                                                    class: "upload-zone-items",
                                                                },
                                                                [
                                                                    t.state.files.map(
                                                                        function (
                                                                            e
                                                                        ) {
                                                                            var n;
                                                                            return (
                                                                                (n =
                                                                                    t.isImg(
                                                                                        e.name
                                                                                    )
                                                                                        ? Object(
                                                                                              i.d
                                                                                          )(
                                                                                              "img",
                                                                                              {
                                                                                                  src: e.url,
                                                                                                  alt: e.name,
                                                                                                  title: e.name,
                                                                                              },
                                                                                              null
                                                                                          )
                                                                                        : Object(
                                                                                              i.d
                                                                                          )(
                                                                                              Object(
                                                                                                  i.o
                                                                                              )(
                                                                                                  "v-icon"
                                                                                              ),
                                                                                              {
                                                                                                  name: /\.pdf$/.test(
                                                                                                      e.name
                                                                                                  )
                                                                                                      ? "types/pdf"
                                                                                                      : "types/file",
                                                                                                  class: "text-primary media-item-icon--inner",
                                                                                                  style: "width: 60%",
                                                                                              },
                                                                                              null
                                                                                          )),
                                                                                Object(
                                                                                    i.d
                                                                                )(
                                                                                    "div",
                                                                                    {
                                                                                        class: "upload-zone-item",
                                                                                    },
                                                                                    [
                                                                                        Object(
                                                                                            i.d
                                                                                        )(
                                                                                            "div",
                                                                                            {
                                                                                                class: "upload-zone-preview",
                                                                                            },
                                                                                            [
                                                                                                n,
                                                                                            ]
                                                                                        ),
                                                                                    ]
                                                                                )
                                                                            );
                                                                        }
                                                                    ),
                                                                ]
                                                            ),
                                                            Object(i.d)(
                                                                "div",
                                                                {
                                                                    class: "upload-zone",
                                                                },
                                                                [
                                                                    Object(i.d)(
                                                                        "input",
                                                                        {
                                                                            id: "file",
                                                                            hidden: !0,
                                                                            type: "file",
                                                                            multiple:
                                                                                !0,
                                                                            onChange:
                                                                                cn.bind(
                                                                                    this
                                                                                ),
                                                                        },
                                                                        null
                                                                    ),
                                                                    Object(i.d)(
                                                                        "label",
                                                                        {
                                                                            for: "file",
                                                                            class: "w-100",
                                                                        },
                                                                        [
                                                                            Object(
                                                                                i.d
                                                                            )(
                                                                                "div",
                                                                                {
                                                                                    class: "upload-zone-area ".concat(
                                                                                        this
                                                                                            .state
                                                                                            .loading &&
                                                                                            "loading"
                                                                                    ),
                                                                                },
                                                                                [
                                                                                    Object(
                                                                                        i.d
                                                                                    )(
                                                                                        Object(
                                                                                            i.o
                                                                                        )(
                                                                                            "v-icon"
                                                                                        ),
                                                                                        {
                                                                                            name: "actions/upload-cloud",
                                                                                            style: "width: 90px; margin: auto",
                                                                                        },
                                                                                        null
                                                                                    ),
                                                                                    Object(
                                                                                        i.d
                                                                                    )(
                                                                                        "div",
                                                                                        {
                                                                                            class: "spinner-border",
                                                                                            style: "width: 80px; height: 80px; margin: auto",
                                                                                            role: "status",
                                                                                        },
                                                                                        [
                                                                                            Object(
                                                                                                i.d
                                                                                            )(
                                                                                                "span",
                                                                                                {
                                                                                                    class: "sr-only",
                                                                                                },
                                                                                                [
                                                                                                    Object(
                                                                                                        i.c
                                                                                                    )(
                                                                                                        "Loading..."
                                                                                                    ),
                                                                                                ]
                                                                                            ),
                                                                                        ]
                                                                                    ),
                                                                                ]
                                                                            ),
                                                                        ]
                                                                    ),
                                                                ]
                                                            ),
                                                            Object(i.d)(
                                                                "div",
                                                                {
                                                                    class: "form-check mt-3",
                                                                },
                                                                [
                                                                    Object(i.d)(
                                                                        "input",
                                                                        {
                                                                            class: "form-check-input",
                                                                            type: "checkbox",
                                                                            id: "upload_in_current_dir",
                                                                            name: "upload_in_current_dir",
                                                                        },
                                                                        null
                                                                    ),
                                                                    Object(i.d)(
                                                                        "label",
                                                                        {
                                                                            class: "form-check-label arial text-muted",
                                                                            for: "upload_in_current_dir",
                                                                        },
                                                                        [
                                                                            Object(
                                                                                i.c
                                                                            )(
                                                                                " "
                                                                            ),
                                                                        ]
                                                                    ),
                                                                ]
                                                            ),
                                                        ]
                                                    ),
                                                    Object(i.d)(
                                                        "div",
                                                        {
                                                            class: "modal-footer",
                                                        },
                                                        [
                                                            Object(i.d)(
                                                                "small",
                                                                {
                                                                    class: "text-muted arial upload-count",
                                                                },
                                                                [
                                                                    Object(i.c)(
                                                                        ": "
                                                                    ),
                                                                    this.state
                                                                        .files
                                                                        .length,
                                                                ]
                                                            ),
                                                            Object(i.d)(
                                                                "button",
                                                                {
                                                                    type: "button",
                                                                    class: "btn btn-light arial-caps",
                                                                    "data-dismiss":
                                                                        "modal",
                                                                },
                                                                [
                                                                    Object(i.c)(
                                                                        ""
                                                                    ),
                                                                ]
                                                            ),
                                                            Object(i.d)(
                                                                "button",
                                                                {
                                                                    type: "submit",
                                                                    class: "btn btn-primary arial-caps",
                                                                },
                                                                [
                                                                    Object(i.c)(
                                                                        ""
                                                                    ),
                                                                ]
                                                            ),
                                                        ]
                                                    ),
                                                ]
                                            ),
                                        ]
                                    ),
                                ]
                            ),
                        ]
                    );
                },
            }),
            un = Object(i.e)({
                setup: function () {
                    var t = Object(i.n)(null),
                        e = Object(i.n)(null),
                        n = Object(i.n)(""),
                        r = b();
                    return {
                        onSearch: function () {
                            var t;
                            n.value.length < 3 ||
                                ((e.value.disabled = !0),
                                Zt(r),
                                (function (t) {
                                    t.commit(s.CLEAR_SEARCHED_FILES);
                                })(r),
                                xn.push(
                                    "/search/" +
                                        xn.currentRoute.value.params.path
                                ),
                                r
                                    .dispatch(m.SEARCH_FILES, {
                                        location:
                                            ((t = xn.currentRoute.value),
                                            "/" + String(t.params.path)),
                                        q: n.value,
                                    })
                                    .then(function () {
                                        (e.value.disabled = !1),
                                            (r.state.atend = !1),
                                            ee(r, "");
                                    }));
                        },
                        onInput: function () {
                            n.value = t.value.value;
                        },
                        searchBtn: e,
                        searchInput: t,
                        searchValue: n,
                    };
                },
                render: function () {
                    var t = this;
                    return Object(i.d)("div", { class: "row g-2" }, [
                        Object(i.d)(
                            "div",
                            { class: "col-md-4 col-lg-3 col-xl-3" },
                            [
                                Object(i.d)("div", null, [
                                    Object(i.d)(
                                        "a",
                                        { href: "/", class: "text-dark" },
                                        [
                                            Object(i.d)(
                                                Object(i.o)("v-icon"),
                                                {
                                                    name: "types/folder",
                                                    class: "text-primary float-left mr-2",
                                                    style: "width: 38px",
                                                },
                                                null
                                            ),
                                            Object(i.d)(
                                                "span",
                                                {
                                                    class: "arial-caps d-block float-left mt-2",
                                                },
                                                [Object(i.c)(" ")]
                                            ),
                                        ]
                                    ),
                                ]),
                            ]
                        ),
                        Object(i.d)(
                            "div",
                            { class: "col-md-5 col-lg-6 col-xl-7" },
                            [
                                Object(i.d)(
                                    "div",
                                    { class: "input-group mx-auto" },
                                    [
                                        Object(i.d)(
                                            "input",
                                            {
                                                type: "search",
                                                placeholder: "",
                                                class: "arial form-control py-0 px-2",
                                                ref: "searchInput",
                                                onInput: this.onInput,
                                                onKeyup: function (e) {
                                                    "Enter" == e.key &&
                                                        t.onSearch();
                                                },
                                            },
                                            null
                                        ),
                                        Object(i.d)(
                                            "button",
                                            {
                                                type: "button",
                                                class: "btn btn-primary",
                                                onClick: this.onSearch,
                                                ref: "searchBtn",
                                            },
                                            [
                                                Object(i.d)(
                                                    Object(i.o)("v-icon"),
                                                    {
                                                        name: "actions/search",
                                                        class: "text-white",
                                                        style: "width: 21px",
                                                    },
                                                    null
                                                ),
                                            ]
                                        ),
                                    ]
                                ),
                            ]
                        ),
                        Object(i.d)(
                            "div",
                            { class: "col-md-3 col-lg-3 col-xl-2 text-right" },
                            [
                                Object(i.d)(
                                    "button",
                                    {
                                        id: "btn-upload",
                                        type: "button",
                                        class: "btn btn-primary mr-2",
                                    },
                                    [
                                        Object(i.d)(
                                            Object(i.o)("v-icon"),
                                            {
                                                name: "actions/upload-cloud",
                                                class: "mx-3",
                                                style: "width: 23px",
                                            },
                                            null
                                        ),
                                    ]
                                ),
                                Object(i.d)(
                                    "button",
                                    {
                                        id: "btn-create-directory",
                                        type: "button",
                                        class: "btn btn-outline-primary border-style-dashed",
                                    },
                                    [
                                        Object(i.d)(
                                            Object(i.o)("v-icon"),
                                            {
                                                name: "actions/create-folder",
                                                class: "mx-3",
                                                style: "width: 23px",
                                            },
                                            null
                                        ),
                                    ]
                                ),
                            ]
                        ),
                        Object(i.d)(
                            rn,
                            { selector: "#btn-create-directory" },
                            null
                        ),
                        Object(i.d)(ln, { selector: "#btn-upload" }, null),
                    ]);
                },
            }),
            hn = n(19);
        function pn() {
            var t = this.file;
            t.isdir ? xn.push("/location" + t.path) : ne([t]);
        }
        var dn,
            fn = Object(i.e)({
                props: { file: { type: Object, required: !0 } },
                setup: function (t) {
                    var e = t.file,
                        n = hn.metaTag.get("media-url").content,
                        r = hn.metaTag.get("thumb-url").content,
                        s = (function (t) {
                            if (!t) return "";
                            var e = t.split(".").slice(-1)[0];
                            return e != t ? e : "";
                        })(e.name),
                        o = Object(i.n)(""),
                        a = (function (t) {
                            if (t.isdir) return "types/folder";
                            var e = t.content_type,
                                n = t.name.split(".").slice(-1)[0];
                            return e.startsWith("image")
                                ? "types/image"
                                : "pdf" == n
                                ? "types/pdf"
                                : "types/file";
                        })(e),
                        c =
                            !!e.content_type &&
                            /\.(jpg|png|gif|svg)$/.test(e.name);
                    if (c) {
                        var l = window.webpSupported ? "webp" : "jpg";
                        o.value = r + e.path.slice(1).replace(s, l);
                    }
                    return {
                        content_type_icon: a,
                        on_file_click: pn,
                        onError: function () {
                            o.value.startsWith(r.content) &&
                            o.value.endsWith(".webp")
                                ? (o.value = o.value.replace(".webp", ".jpg"))
                                : (o.value = n + e.path.slice(1));
                        },
                        ext: s,
                        isimg: c,
                        url: o,
                    };
                },
                render: function () {
                    var t = this;
                    return Object(i.d)("div", { class: "card media-item" }, [
                        Object(i.d)(
                            "div",
                            {
                                class: "media-item-head",
                                onClick: this.on_file_click.bind(this),
                            },
                            [
                                Object(i.d)(
                                    "div",
                                    { class: "media-item-icon" },
                                    [
                                        t.isimg
                                            ? Object(i.d)(
                                                  "img",
                                                  {
                                                      src: t.url,
                                                      onError: t.onError,
                                                  },
                                                  null
                                              )
                                            : Object(i.d)(
                                                  Object(i.o)("v-icon"),
                                                  {
                                                      name: t.content_type_icon,
                                                      class: "text-primary media-item-icon--inner",
                                                  },
                                                  null
                                              ),
                                    ]
                                ),
                                (function () {
                                    if (!t.isimg)
                                        return Object(i.d)(
                                            "div",
                                            {
                                                class: "position-absolute text-muted text-uppercase",
                                                style: "top: 0; right: 10px;",
                                            },
                                            [
                                                Object(i.d)("small", null, [
                                                    t.ext,
                                                ]),
                                            ]
                                        );
                                })(),
                                Object(i.d)(
                                    "div",
                                    {
                                        class: "media-item-overlay",
                                        "data-path": this.file.path,
                                        "data-type": this.file.content_type,
                                        "data-name": this.file.name,
                                    },
                                    null
                                ),
                            ]
                        ),
                        Object(i.d)(
                            "div",
                            { class: "card-body", title: this.file.name },
                            [
                                Object(i.d)(
                                    "p",
                                    { class: "card-text line-clamp-3" },
                                    [this.file.name]
                                ),
                            ]
                        ),
                    ]);
                },
            }),
            mn = function (t) {
                var e =
                        !(arguments.length > 1 && void 0 !== arguments[1]) ||
                        arguments[1],
                    n = hn.metaTag.get("media-url").content,
                    r = ""
                        .concat(window.location.protocol, "//")
                        .concat(window.location.host);
                return (
                    n.startsWith("/") && (n = "".concat(n).concat(t)),
                    e && (n = "".concat(r).concat(n)),
                    n.replace(/\/{2,}/g, "/")
                );
            },
            yn = Object(i.e)({
                setup: function () {
                    var t = Object(i.m)({
                            active: !1,
                            x: 0,
                            y: 0,
                            dataset: {},
                            menu: [
                                {
                                    check: function () {
                                        return !!t.dataset.type;
                                    },
                                    icon: "actions/copy",
                                    text: " ",
                                    action: function () {
                                        var e = mn(t.dataset.path);
                                        Object(hn.copytoClipboard)(e);
                                    },
                                },
                                {
                                    check: function () {
                                        return hn.donwloadUrl, !!t.dataset.type;
                                    },
                                    icon: "actions/download",
                                    text: "",
                                    action: function () {
                                        var e = t.dataset.name,
                                            n = mn(t.dataset.path, !1);
                                        Object(hn.donwloadUrl)(n, e);
                                    },
                                },
                            ],
                        }),
                        e = function (e) {
                            var n = e.target;
                            n.classList.contains("media-item-overlay") &&
                                (e.preventDefault(),
                                (t.dataset = Object.assign({}, n.dataset)),
                                (t.y = e.clientY),
                                (t.x = e.clientX),
                                (t.active = !0));
                        },
                        n = function () {
                            t.active = !1;
                        };
                    return (
                        Object(i.k)(function () {
                            window.addEventListener("contextmenu", e),
                                window.addEventListener("click", n);
                        }),
                        Object(i.j)(function () {
                            window.removeEventListener("contextmenu", e),
                                window.removeEventListener("click", n);
                        }),
                        { state: t }
                    );
                },
                render: function () {
                    var t = this;
                    return Object(i.d)(
                        "div",
                        {
                            class: {
                                "arial card card-context-menu": !0,
                                active: this.state.active,
                            },
                            style: {
                                top: this.state.y + "px",
                                left: this.state.x + "px",
                            },
                        },
                        [
                            Object(i.d)(
                                function () {
                                    return t.state.menu
                                        .filter(function (t) {
                                            return !t.check || t.check();
                                        })
                                        .map(function (t) {
                                            return Object(i.d)(
                                                "div",
                                                {
                                                    class: "item",
                                                    onClick: t.action,
                                                },
                                                [
                                                    Object(i.d)(
                                                        Object(i.o)("v-icon"),
                                                        {
                                                            name: t.icon,
                                                            class: "item-icon",
                                                        },
                                                        null
                                                    ),
                                                    Object(i.d)("span", null, [
                                                        t.text,
                                                    ]),
                                                ]
                                            );
                                        });
                                },
                                null,
                                null
                            ),
                        ]
                    );
                },
            }),
            gn = function (t) {
                var e = t.loading,
                    n = t.length;
                if (!e && 0 == n)
                    return Object(i.d)(
                        "p",
                        { class: "h3 text-muted arial text-center" },
                        [Object(i.c)(" ")]
                    );
            },
            vn = function (t) {
                if (t.loading)
                    return Object(i.d)("div", { class: "loader" }, [
                        Object(i.d)(
                            Object(i.o)("v-icon"),
                            {
                                name: "gears",
                                class: "text-primary media-item-icon--inner",
                            },
                            null
                        ),
                    ]);
            },
            bn = Object(i.e)({
                setup: function () {
                    var t = b(),
                        e = Object(i.m)({
                            files: Object(i.a)(function () {
                                return t.getters.getfiles;
                            }),
                            searched: Object(i.a)(function () {
                                return t.getters.getsearched;
                            }),
                            loading: Object(i.a)({
                                get: function () {
                                    return t.state.loading;
                                },
                                set: function (e) {
                                    t.state.loading = e;
                                },
                            }),
                            atend: Object(i.a)({
                                get: function () {
                                    return t.state.atend;
                                },
                                set: function (e) {
                                    t.state.atend = e;
                                },
                            }),
                        }),
                        n = Object(i.n)(null),
                        r = Object(i.a)(function () {
                            var t = xn.currentRoute.value;
                            if (!t) return [];
                            var e = String(t.params.path)
                                .split("/")
                                .filter(function (t) {
                                    return 0 != t.length;
                                });
                            return e.map(function (t, n) {
                                return {
                                    name: t,
                                    url:
                                        "/location/" +
                                        e.slice(0, n + 1).join("/"),
                                };
                            });
                        }),
                        s = function () {
                            (e.atend = !1), Zt(t), ee(t, te());
                        },
                        o = function () {
                            n.value.scrollHeight -
                                (n.value.clientHeight + n.value.scrollTop) <
                                250 && ee(t, te());
                        };
                    return (
                        Object(i.k)(function () {
                            ee(t, te()),
                                (n.value.onscroll = function () {
                                    Object(hn.debounce)(o, 100);
                                }),
                                window.addEventListener("update-files", s);
                        }),
                        Object(i.j)(function () {
                            (n.value.onscroll = null),
                                window.removeEventListener("update-files", s);
                        }),
                        Object(i.s)(
                            function () {
                                return xn.currentRoute.value;
                            },
                            function (n, r) {
                                (r.name == n.name &&
                                    r.params.path == n.params.path) ||
                                    ((e.atend = !1),
                                    Zt(t),
                                    ee(t, "/" + n.params.path));
                            }
                        ),
                        { appContent: n, breadcrumbs: r, state: e }
                    );
                },
                render: function () {
                    return Object(i.d)("div", { class: "app-wrapper" }, [
                        Object(i.d)(yn, null, null),
                        Object(i.d)(
                            "div",
                            { class: "app-toolbar border-bottom" },
                            [Object(i.d)(un, null, null)]
                        ),
                        Object(i.d)(
                            "div",
                            { class: "app-menu border-bottom" },
                            [
                                Object(i.d)("small", { class: "m-0 p-0" }, [
                                    Object(i.d)(
                                        "ol",
                                        { class: "d-flex m-0 p-0" },
                                        [
                                            Object(i.d)(
                                                "li",
                                                { class: "breadcrumb-item" },
                                                [
                                                    Object(i.d)(
                                                        Wt,
                                                        {
                                                            to: {
                                                                name: "home",
                                                            },
                                                        },
                                                        {
                                                            default:
                                                                function () {
                                                                    return [
                                                                        Object(
                                                                            i.c
                                                                        )(
                                                                            "Media"
                                                                        ),
                                                                    ];
                                                                },
                                                        }
                                                    ),
                                                ]
                                            ),
                                            this.breadcrumbs
                                                .slice(0, -1)
                                                .map(function (t) {
                                                    return Object(i.d)(
                                                        "li",
                                                        {
                                                            class: "breadcrumb-item",
                                                        },
                                                        [
                                                            Object(i.d)(
                                                                Wt,
                                                                { to: t.url },
                                                                {
                                                                    default:
                                                                        function () {
                                                                            return [
                                                                                t.name,
                                                                            ];
                                                                        },
                                                                }
                                                            ),
                                                        ]
                                                    );
                                                }),
                                            this.breadcrumbs
                                                .slice(-1)
                                                .map(function (t) {
                                                    return Object(i.d)(
                                                        "li",
                                                        {
                                                            class: "breadcrumb-item active",
                                                            "aria-current":
                                                                "page",
                                                        },
                                                        [t.name]
                                                    );
                                                }),
                                        ]
                                    ),
                                ]),
                            ]
                        ),
                        Object(i.d)(
                            "div",
                            { class: "app-content", ref: "appContent" },
                            [
                                Object(i.d)(
                                    gn,
                                    {
                                        loading: this.state.loading,
                                        length: this.state.files.length,
                                    },
                                    null
                                ),
                                Object(i.d)("div", { class: "media-items" }, [
                                    this.state.files.map(function (t) {
                                        return Object(i.d)(
                                            fn,
                                            { file: t },
                                            null
                                        );
                                    }),
                                ]),
                                Object(i.d)(
                                    vn,
                                    { loading: this.state.loading },
                                    null
                                ),
                            ]
                        ),
                    ]);
                },
            }),
            xn = (function (t) {
                const e = mt(t.routes, t);
                let n = t.parseQuery || Bt,
                    r = t.stringifyQuery || Ut,
                    { scrollBehavior: s } = t,
                    o = t.history;
                const a = qt(),
                    c = qt(),
                    l = qt(),
                    u = Object(i.p)(tt);
                let h = tt;
                C &&
                    s &&
                    "scrollRestoration" in history &&
                    (history.scrollRestoration = "manual");
                const p = k.bind(null, (t) => "" + t),
                    d = k.bind(null, Dt),
                    f = k.bind(null, Ft);
                function m(t, s) {
                    if (((s = { ...(s || u.value) }), "string" == typeof t)) {
                        let r = j(n, t, s.path),
                            i = e.resolve({ path: r.path }, s),
                            a = o.createHref(r.fullPath);
                        return (
                            a.startsWith("//")
                                ? N(
                                      `Location "${t}" resolved to "${a}". A resolved location cannot start with multiple slashes.`
                                  )
                                : i.matched.length ||
                                  N(
                                      `No match found for location with path "${t}"`
                                  ),
                            O(r, i, {
                                params: f(i.params),
                                redirectedFrom: void 0,
                                href: a,
                            })
                        );
                    }
                    let i;
                    "path" in t
                        ? ("params" in t &&
                              !("name" in t) &&
                              Object.keys(t.params).length &&
                              N(
                                  `Path "${t.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`
                              ),
                          (i = O({}, t, { path: j(n, t.path, s.path).path })))
                        : ((i = O({}, t, { params: d(t.params) })),
                          (s.params = d(s.params)));
                    let a = e.resolve(i, s);
                    const c = Mt(t.hash || "")
                        .replace(It, "{")
                        .replace(Lt, "}")
                        .replace(_t, "^");
                    c &&
                        !c.startsWith("#") &&
                        N(
                            `A \`hash\` should always start with the character "#". Replace "${c}" with "#${c}".`
                        ),
                        (a.params = p(f(a.params)));
                    const l = (function (t, e) {
                        let n = e.query ? t(e.query) : "";
                        return e.path + (n && "?") + n + (e.hash || "");
                    })(r, O({}, t, { hash: c, path: a.path }));
                    let h = o.createHref(l);
                    return (
                        h.startsWith("//")
                            ? N(
                                  `Location "${t}" resolved to "${h}". A resolved location cannot start with multiple slashes.`
                              )
                            : a.matched.length ||
                              N(
                                  `No match found for location with path "${
                                      "path" in t ? t.path : t
                                  }"`
                              ),
                        O(
                            {
                                fullPath: l,
                                hash: c,
                                query: r === Ut ? Vt(t.query) : t.query,
                            },
                            a,
                            { redirectedFrom: void 0, href: h }
                        )
                    );
                }
                function y(t) {
                    return "string" == typeof t ? { path: t } : O({}, t);
                }
                function g(t, e) {
                    if (h !== t) return st(8, { from: e, to: t });
                }
                function v(t) {
                    return b(t);
                }
                function b(t, e) {
                    const n = (h = m(t)),
                        s = u.value,
                        i = t.state,
                        o = t.force,
                        a = !0 === t.replace,
                        c = n.matched[n.matched.length - 1];
                    if (c && c.redirect) {
                        const { redirect: t } = c;
                        let r = y("function" == typeof t ? t(n) : t);
                        return "path" in r || "name" in r
                            ? b(
                                  O(
                                      {
                                          query: n.query,
                                          hash: n.hash,
                                          params: n.params,
                                      },
                                      r,
                                      { state: i, force: o, replace: a }
                                  ),
                                  e || n
                              )
                            : (N(
                                  `Invalid redirect found:\n${JSON.stringify(
                                      r,
                                      null,
                                      2
                                  )}\n when navigating to "${
                                      n.fullPath
                                  }". A redirect must contain a name or path. This will break in production.`
                              ),
                              Promise.reject(new Error("Invalid redirect")));
                    }
                    const l = n;
                    let p;
                    return (
                        (l.redirectedFrom = e),
                        !o &&
                            M(r, s, n) &&
                            ((p = st(16, { to: l, from: s })), V(s, s, !0, !1)),
                        (p ? Promise.resolve(p) : w(l, s))
                            .catch((t) => (it(t, 14) ? t : B(t)))
                            .then((t) => {
                                if (t) {
                                    if (it(t, 2))
                                        return M(r, m(t.to), l) &&
                                            e &&
                                            (e._count = e._count
                                                ? e._count + 1
                                                : 1) > 10
                                            ? (N(
                                                  `Detected an infinite redirection in a navigation guard when going from "${s.fullPath}" to "${l.fullPath}". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`
                                              ),
                                              Promise.reject(
                                                  new Error(
                                                      "Infinite redirect in navigation guard"
                                                  )
                                              ))
                                            : b(
                                                  O(y(t.to), {
                                                      state: i,
                                                      force: o,
                                                      replace: a,
                                                  }),
                                                  e || l
                                              );
                                } else t = A(l, s, !0, a, i);
                                return P(l, s, t), t;
                            })
                    );
                }
                function x(t, e) {
                    const n = g(t, e);
                    return n ? Promise.reject(n) : Promise.resolve();
                }
                function w(t, e) {
                    let n;
                    n = zt(
                        e.matched
                            .filter((e) => t.matched.indexOf(e) < 0)
                            .reverse(),
                        "beforeRouteLeave",
                        t,
                        e
                    );
                    const [r, s] = Yt(t, e);
                    for (const s of r)
                        for (const r of s.leaveGuards) n.push($t(r, t, e));
                    const i = x.bind(null, t, e);
                    return (
                        n.push(i),
                        Xt(n)
                            .then(() => {
                                n = [];
                                for (const r of a.list()) n.push($t(r, t, e));
                                return n.push(i), Xt(n);
                            })
                            .then(() => {
                                n = zt(
                                    t.matched.filter(
                                        (t) => e.matched.indexOf(t) > -1
                                    ),
                                    "beforeRouteUpdate",
                                    t,
                                    e
                                );
                                for (const r of s)
                                    for (const s of r.updateGuards)
                                        n.push($t(s, t, e));
                                return n.push(i), Xt(n);
                            })
                            .then(() => {
                                n = [];
                                for (const r of t.matched)
                                    if (
                                        r.beforeEnter &&
                                        e.matched.indexOf(r) < 0
                                    )
                                        if (Array.isArray(r.beforeEnter))
                                            for (const s of r.beforeEnter)
                                                n.push($t(s, t, e));
                                        else n.push($t(r.beforeEnter, t, e));
                                return n.push(i), Xt(n);
                            })
                            .then(
                                () => (
                                    t.matched.forEach(
                                        (t) => (t.enterCallbacks = {})
                                    ),
                                    (n = zt(
                                        t.matched.filter(
                                            (t) => e.matched.indexOf(t) < 0
                                        ),
                                        "beforeRouteEnter",
                                        t,
                                        e
                                    )),
                                    n.push(i),
                                    Xt(n)
                                )
                            )
                            .then(() => {
                                n = [];
                                for (const r of c.list()) n.push($t(r, t, e));
                                return n.push(i), Xt(n);
                            })
                            .catch((t) => (it(t, 8) ? t : Promise.reject(t)))
                    );
                }
                function P(t, e, n) {
                    for (const r of l.list()) r(t, e, n);
                }
                function A(t, e, n, r, s) {
                    const i = g(t, e);
                    if (i) return i;
                    const [a] = Yt(t, e);
                    for (const t of a)
                        (t.leaveGuards = []),
                            (t.updateGuards = []),
                            (t.instances = {}),
                            (t.enterCallbacks = {});
                    const c = e === tt,
                        l = C ? history.state : {};
                    n &&
                        (r || c
                            ? o.replace(
                                  t.fullPath,
                                  O({ scroll: c && l && l.scroll }, s)
                              )
                            : o.push(t.fullPath, s)),
                        (u.value = t),
                        V(t, e, n, c),
                        U();
                }
                let E;
                function I() {
                    E = o.listen((t, e, n) => {
                        const r = m(t);
                        h = r;
                        const s = u.value;
                        var i, a;
                        C &&
                            ((i = G(s.fullPath, n.delta)),
                            (a = H()),
                            K.set(i, a)),
                            w(r, s)
                                .catch((t) =>
                                    it(t, 12)
                                        ? t
                                        : it(t, 2)
                                        ? (n.delta && o.go(-n.delta, !1),
                                          b(t.to, r).catch(_),
                                          Promise.reject())
                                        : (n.delta && o.go(-n.delta, !1), B(t))
                                )
                                .then((t) => {
                                    (t = t || A(r, s, !1)) &&
                                        n.delta &&
                                        o.go(-n.delta, !1),
                                        P(r, s, t);
                                })
                                .catch(_);
                    });
                }
                let L,
                    R,
                    D = qt(),
                    F = qt();
                function B(t) {
                    return (
                        U(t), F.list().forEach((e) => e(t)), Promise.reject(t)
                    );
                }
                function U(t) {
                    L ||
                        ((L = !0),
                        I(),
                        D.list().forEach(([e, n]) => (t ? n(t) : e())),
                        D.reset());
                }
                function V(t, e, n, r) {
                    if (!C || !s) return Promise.resolve();
                    let o =
                        (!n &&
                            (function (t) {
                                const e = K.get(t);
                                return K.delete(t), e;
                            })(G(t.fullPath, 0))) ||
                        ((r || !n) && history.state && history.state.scroll) ||
                        null;
                    return Object(i.i)()
                        .then(() => s(t, e, o))
                        .then((t) => t && W(t))
                        .catch(B);
                }
                function q(t) {
                    return new Promise((e, n) => {
                        let r = F.add((t) => {
                                r(), s(), n(t);
                            }),
                            s = l.add((t, n, i) => {
                                r(), s(), e(i);
                            });
                        o.go(t);
                    });
                }
                const $ = new Set();
                return {
                    currentRoute: u,
                    addRoute: function (t, n) {
                        let r, s;
                        return (
                            Z(t)
                                ? ((r = e.getRecordMatcher(t)), (s = n))
                                : (s = t),
                            e.addRoute(s, r)
                        );
                    },
                    removeRoute: function (t) {
                        let n = e.getRecordMatcher(t);
                        n
                            ? e.removeRoute(n)
                            : N(
                                  `Cannot remove non-existent route "${String(
                                      t
                                  )}"`
                              );
                    },
                    hasRoute: function (t) {
                        return !!e.getRecordMatcher(t);
                    },
                    getRoutes: function () {
                        return e.getRoutes().map((t) => t.record);
                    },
                    resolve: m,
                    options: t,
                    push: v,
                    replace: function (t) {
                        return v(O(y(t), { replace: !0 }));
                    },
                    go: q,
                    back: () => q(-1),
                    forward: () => q(1),
                    beforeEach: a.add,
                    beforeResolve: c.add,
                    afterEach: l.add,
                    onError: F.add,
                    isReady: function () {
                        return L && u.value !== tt
                            ? Promise.resolve()
                            : new Promise((t, e) => {
                                  D.add([t, e]);
                              });
                    },
                    install(t) {
                        t.component("RouterLink", Wt),
                            t.component("RouterView", Jt),
                            (t.config.globalProperties.$router = this),
                            Object.defineProperty(
                                t.config.globalProperties,
                                "$route",
                                { get: () => Object(i.q)(u) }
                            ),
                            C &&
                                !R &&
                                u.value === tt &&
                                ((R = !0),
                                v(o.location).catch((t) => {
                                    N(
                                        "Unexpected error when starting the router:",
                                        t
                                    );
                                }));
                        const e = {};
                        for (let t in tt) e[t] = Object(i.a)(() => u.value[t]);
                        t.provide(T, this), t.provide(S, Object(i.m)(e));
                        let n = t.unmount;
                        $.add(t),
                            (t.unmount = function () {
                                $.delete(t),
                                    $.size < 1 &&
                                        (E(),
                                        (u.value = tt),
                                        (R = !1),
                                        (L = !1)),
                                    n.call(this, arguments);
                            });
                    },
                };
            })({
                history:
                    ((dn = (location.host && dn) || location.pathname).indexOf(
                        "#"
                    ) < 0 && (dn += "#"),
                    dn.endsWith("#/") ||
                        dn.endsWith("#") ||
                        N(
                            `A hash base must end with a "#":\n"${dn}" should be "${dn.replace(
                                /#.*$/,
                                "#"
                            )}".`
                        ),
                    Q(dn)),
                routes: [
                    { path: "/", redirect: "/location/" },
                    { path: "/location", name: "home", redirect: "/location/" },
                    { path: "/search", redirect: "/search/" },
                    {
                        path: "/location/:path(.*)",
                        name: "location",
                        component: bn,
                        children: [
                            {
                                path: "/search/:path(.*)",
                                name: "search",
                                component: {},
                            },
                        ],
                    },
                ],
            }),
            wn = Object(i.e)({
                setup: function () {
                    return { onclicked: function () {} };
                },
                render: function () {
                    return Object(i.d)("div", null, [
                        Object(i.d)(Jt, null, null),
                    ]);
                },
            }),
            Pn = {};
        [
            "types/csv",
            "types/excel",
            "types/file",
            "types/folder",
            "types/image",
            "types/pdf",
            "types/word",
            "types/archive",
            "types/code",
            "actions/search",
            "actions/move-folder",
            "actions/create-folder",
            "actions/upload-cloud",
            "actions/delete",
            "actions/download",
            "actions/copy",
            "info",
            "cancel",
            "grid-view",
            "list-view",
            "image-edit",
            "crop",
            "reflect",
            "reset",
            "resize",
            "rotate",
            "gears",
            "return",
        ].forEach(function (t) {
            Pn[t] = n(376)("./".concat(t)).default;
        });
        var An = Object(i.e)({
            inheritAttrs: !1,
            props: {
                name: { type: String, required: !0 },
                size: { type: Number, default: null },
            },
            setup: function (t, e) {
                var n = t.name,
                    r = t.size,
                    s = e.attrs;
                return {
                    icons: Pn,
                    name: n,
                    getIcon: function () {
                        return Pn[n] || "";
                    },
                    size: r,
                    attrs: s,
                };
            },
            template:
                '\n        <div class="svg-icon" v-bind="this.attrs" v-html="this.getIcon()"></div>\n    ',
        });
        function En() {
            var t = Object(i.b)(wn);
            return t.use(xn), t.use(x), t.component("v-icon", An), t;
        }
    },
    function (t, e, n) {
        n(169), (t.exports = n(355));
    },
    function (t, e, n) {
        "use strict";
        n(170);
        var r,
            s = (r = n(342)) && r.__esModule ? r : { default: r };
        s.default._babelPolyfill &&
            "undefined" != typeof console &&
            console.warn &&
            console.warn(
                "@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended and may have consequences if different versions of the polyfills are applied sequentially. If you do need to load the polyfill more than once, use @babel/polyfill/noConflict instead to bypass the warning."
            ),
            (s.default._babelPolyfill = !0);
    },
    function (t, e, n) {
        "use strict";
        n(171),
            n(314),
            n(316),
            n(319),
            n(321),
            n(323),
            n(325),
            n(327),
            n(329),
            n(331),
            n(333),
            n(335),
            n(337),
            n(341);
    },
    function (t, e, n) {
        n(172),
            n(175),
            n(176),
            n(177),
            n(178),
            n(179),
            n(180),
            n(181),
            n(182),
            n(183),
            n(184),
            n(185),
            n(186),
            n(187),
            n(188),
            n(189),
            n(190),
            n(191),
            n(192),
            n(193),
            n(194),
            n(195),
            n(196),
            n(197),
            n(198),
            n(199),
            n(200),
            n(201),
            n(202),
            n(203),
            n(204),
            n(205),
            n(206),
            n(207),
            n(208),
            n(209),
            n(210),
            n(211),
            n(212),
            n(213),
            n(214),
            n(215),
            n(216),
            n(218),
            n(219),
            n(220),
            n(221),
            n(222),
            n(223),
            n(224),
            n(225),
            n(226),
            n(227),
            n(228),
            n(229),
            n(230),
            n(231),
            n(232),
            n(233),
            n(234),
            n(235),
            n(236),
            n(237),
            n(238),
            n(239),
            n(240),
            n(241),
            n(242),
            n(243),
            n(244),
            n(245),
            n(246),
            n(247),
            n(248),
            n(249),
            n(250),
            n(251),
            n(253),
            n(254),
            n(256),
            n(257),
            n(258),
            n(259),
            n(260),
            n(261),
            n(262),
            n(264),
            n(265),
            n(266),
            n(267),
            n(268),
            n(269),
            n(270),
            n(271),
            n(272),
            n(273),
            n(274),
            n(275),
            n(276),
            n(85),
            n(277),
            n(113),
            n(278),
            n(114),
            n(279),
            n(280),
            n(281),
            n(282),
            n(115),
            n(285),
            n(286),
            n(287),
            n(288),
            n(289),
            n(290),
            n(291),
            n(292),
            n(293),
            n(294),
            n(295),
            n(296),
            n(297),
            n(298),
            n(299),
            n(300),
            n(301),
            n(302),
            n(303),
            n(304),
            n(305),
            n(306),
            n(307),
            n(308),
            n(309),
            n(310),
            n(311),
            n(312),
            n(313),
            (t.exports = n(9));
    },
    function (t, e, n) {
        "use strict";
        var r = n(3),
            s = n(16),
            i = n(10),
            o = n(2),
            a = n(13),
            c = n(31).KEY,
            l = n(4),
            u = n(53),
            h = n(43),
            p = n(33),
            d = n(7),
            f = n(66),
            m = n(94),
            y = n(174),
            g = n(56),
            v = n(5),
            b = n(6),
            x = n(12),
            w = n(18),
            P = n(30),
            A = n(32),
            E = n(37),
            T = n(97),
            S = n(24),
            C = n(55),
            O = n(11),
            k = n(35),
            _ = S.f,
            N = O.f,
            I = T.f,
            j = r.Symbol,
            L = r.JSON,
            M = L && L.stringify,
            R = d("_hidden"),
            D = d("toPrimitive"),
            F = {}.propertyIsEnumerable,
            B = u("symbol-registry"),
            U = u("symbols"),
            V = u("op-symbols"),
            q = Object.prototype,
            $ = "function" == typeof j && !!C.f,
            z = r.QObject,
            H = !z || !z.prototype || !z.prototype.findChild,
            W =
                i &&
                l(function () {
                    return (
                        7 !=
                        E(
                            N({}, "a", {
                                get: function () {
                                    return N(this, "a", { value: 7 }).a;
                                },
                            })
                        ).a
                    );
                })
                    ? function (t, e, n) {
                          var r = _(q, e);
                          r && delete q[e],
                              N(t, e, n),
                              r && t !== q && N(q, e, r);
                      }
                    : N,
            G = function (t) {
                var e = (U[t] = E(j.prototype));
                return (e._k = t), e;
            },
            K =
                $ && "symbol" == typeof j.iterator
                    ? function (t) {
                          return "symbol" == typeof t;
                      }
                    : function (t) {
                          return t instanceof j;
                      },
            J = function (t, e, n) {
                return (
                    t === q && J(V, e, n),
                    v(t),
                    (e = P(e, !0)),
                    v(n),
                    s(U, e)
                        ? (n.enumerable
                              ? (s(t, R) && t[R][e] && (t[R][e] = !1),
                                (n = E(n, { enumerable: A(0, !1) })))
                              : (s(t, R) || N(t, R, A(1, {})), (t[R][e] = !0)),
                          W(t, e, n))
                        : N(t, e, n)
                );
            },
            X = function (t, e) {
                v(t);
                for (var n, r = y((e = w(e))), s = 0, i = r.length; i > s; )
                    J(t, (n = r[s++]), e[n]);
                return t;
            },
            Y = function (t) {
                var e = F.call(this, (t = P(t, !0)));
                return (
                    !(this === q && s(U, t) && !s(V, t)) &&
                    (!(
                        e ||
                        !s(this, t) ||
                        !s(U, t) ||
                        (s(this, R) && this[R][t])
                    ) ||
                        e)
                );
            },
            Q = function (t, e) {
                if (
                    ((t = w(t)), (e = P(e, !0)), t !== q || !s(U, e) || s(V, e))
                ) {
                    var n = _(t, e);
                    return (
                        !n ||
                            !s(U, e) ||
                            (s(t, R) && t[R][e]) ||
                            (n.enumerable = !0),
                        n
                    );
                }
            },
            Z = function (t) {
                for (var e, n = I(w(t)), r = [], i = 0; n.length > i; )
                    s(U, (e = n[i++])) || e == R || e == c || r.push(e);
                return r;
            },
            tt = function (t) {
                for (
                    var e, n = t === q, r = I(n ? V : w(t)), i = [], o = 0;
                    r.length > o;

                )
                    !s(U, (e = r[o++])) || (n && !s(q, e)) || i.push(U[e]);
                return i;
            };
        $ ||
            (a(
                (j = function () {
                    if (this instanceof j)
                        throw TypeError("Symbol is not a constructor!");
                    var t = p(arguments.length > 0 ? arguments[0] : void 0),
                        e = function (n) {
                            this === q && e.call(V, n),
                                s(this, R) &&
                                    s(this[R], t) &&
                                    (this[R][t] = !1),
                                W(this, t, A(1, n));
                        };
                    return (
                        i && H && W(q, t, { configurable: !0, set: e }), G(t)
                    );
                }).prototype,
                "toString",
                function () {
                    return this._k;
                }
            ),
            (S.f = Q),
            (O.f = J),
            (n(38).f = T.f = Z),
            (n(50).f = Y),
            (C.f = tt),
            i && !n(34) && a(q, "propertyIsEnumerable", Y, !0),
            (f.f = function (t) {
                return G(d(t));
            })),
            o(o.G + o.W + o.F * !$, { Symbol: j });
        for (
            var et =
                    "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(
                        ","
                    ),
                nt = 0;
            et.length > nt;

        )
            d(et[nt++]);
        for (var rt = k(d.store), st = 0; rt.length > st; ) m(rt[st++]);
        o(o.S + o.F * !$, "Symbol", {
            for: function (t) {
                return s(B, (t += "")) ? B[t] : (B[t] = j(t));
            },
            keyFor: function (t) {
                if (!K(t)) throw TypeError(t + " is not a symbol!");
                for (var e in B) if (B[e] === t) return e;
            },
            useSetter: function () {
                H = !0;
            },
            useSimple: function () {
                H = !1;
            },
        }),
            o(o.S + o.F * !$, "Object", {
                create: function (t, e) {
                    return void 0 === e ? E(t) : X(E(t), e);
                },
                defineProperty: J,
                defineProperties: X,
                getOwnPropertyDescriptor: Q,
                getOwnPropertyNames: Z,
                getOwnPropertySymbols: tt,
            });
        var it = l(function () {
            C.f(1);
        });
        o(o.S + o.F * it, "Object", {
            getOwnPropertySymbols: function (t) {
                return C.f(x(t));
            },
        }),
            L &&
                o(
                    o.S +
                        o.F *
                            (!$ ||
                                l(function () {
                                    var t = j();
                                    return (
                                        "[null]" != M([t]) ||
                                        "{}" != M({ a: t }) ||
                                        "{}" != M(Object(t))
                                    );
                                })),
                    "JSON",
                    {
                        stringify: function (t) {
                            for (
                                var e, n, r = [t], s = 1;
                                arguments.length > s;

                            )
                                r.push(arguments[s++]);
                            if (
                                ((n = e = r[1]),
                                (b(e) || void 0 !== t) && !K(t))
                            )
                                return (
                                    g(e) ||
                                        (e = function (t, e) {
                                            if (
                                                ("function" == typeof n &&
                                                    (e = n.call(this, t, e)),
                                                !K(e))
                                            )
                                                return e;
                                        }),
                                    (r[1] = e),
                                    M.apply(L, r)
                                );
                        },
                    }
                ),
            j.prototype[D] || n(17)(j.prototype, D, j.prototype.valueOf),
            h(j, "Symbol"),
            h(Math, "Math", !0),
            h(r.JSON, "JSON", !0);
    },
    function (t, e, n) {
        t.exports = n(53)("native-function-to-string", Function.toString);
    },
    function (t, e, n) {
        var r = n(35),
            s = n(55),
            i = n(50);
        t.exports = function (t) {
            var e = r(t),
                n = s.f;
            if (n)
                for (var o, a = n(t), c = i.f, l = 0; a.length > l; )
                    c.call(t, (o = a[l++])) && e.push(o);
            return e;
        };
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Object", { create: n(37) });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S + r.F * !n(10), "Object", { defineProperty: n(11).f });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S + r.F * !n(10), "Object", { defineProperties: n(96) });
    },
    function (t, e, n) {
        var r = n(18),
            s = n(24).f;
        n(25)("getOwnPropertyDescriptor", function () {
            return function (t, e) {
                return s(r(t), e);
            };
        });
    },
    function (t, e, n) {
        var r = n(12),
            s = n(39);
        n(25)("getPrototypeOf", function () {
            return function (t) {
                return s(r(t));
            };
        });
    },
    function (t, e, n) {
        var r = n(12),
            s = n(35);
        n(25)("keys", function () {
            return function (t) {
                return s(r(t));
            };
        });
    },
    function (t, e, n) {
        n(25)("getOwnPropertyNames", function () {
            return n(97).f;
        });
    },
    function (t, e, n) {
        var r = n(6),
            s = n(31).onFreeze;
        n(25)("freeze", function (t) {
            return function (e) {
                return t && r(e) ? t(s(e)) : e;
            };
        });
    },
    function (t, e, n) {
        var r = n(6),
            s = n(31).onFreeze;
        n(25)("seal", function (t) {
            return function (e) {
                return t && r(e) ? t(s(e)) : e;
            };
        });
    },
    function (t, e, n) {
        var r = n(6),
            s = n(31).onFreeze;
        n(25)("preventExtensions", function (t) {
            return function (e) {
                return t && r(e) ? t(s(e)) : e;
            };
        });
    },
    function (t, e, n) {
        var r = n(6);
        n(25)("isFrozen", function (t) {
            return function (e) {
                return !r(e) || (!!t && t(e));
            };
        });
    },
    function (t, e, n) {
        var r = n(6);
        n(25)("isSealed", function (t) {
            return function (e) {
                return !r(e) || (!!t && t(e));
            };
        });
    },
    function (t, e, n) {
        var r = n(6);
        n(25)("isExtensible", function (t) {
            return function (e) {
                return !!r(e) && (!t || t(e));
            };
        });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S + r.F, "Object", { assign: n(98) });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Object", { is: n(99) });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Object", { setPrototypeOf: n(70).set });
    },
    function (t, e, n) {
        "use strict";
        var r = n(51),
            s = {};
        (s[n(7)("toStringTag")] = "z"),
            s + "" != "[object z]" &&
                n(13)(
                    Object.prototype,
                    "toString",
                    function () {
                        return "[object " + r(this) + "]";
                    },
                    !0
                );
    },
    function (t, e, n) {
        var r = n(2);
        r(r.P, "Function", { bind: n(100) });
    },
    function (t, e, n) {
        var r = n(11).f,
            s = Function.prototype,
            i = /^\s*function ([^ (]*)/,
            o = "name";
        o in s ||
            (n(10) &&
                r(s, o, {
                    configurable: !0,
                    get: function () {
                        try {
                            return ("" + this).match(i)[1];
                        } catch (t) {
                            return "";
                        }
                    },
                }));
    },
    function (t, e, n) {
        "use strict";
        var r = n(6),
            s = n(39),
            i = n(7)("hasInstance"),
            o = Function.prototype;
        i in o ||
            n(11).f(o, i, {
                value: function (t) {
                    if ("function" != typeof this || !r(t)) return !1;
                    if (!r(this.prototype)) return t instanceof this;
                    for (; (t = s(t)); ) if (this.prototype === t) return !0;
                    return !1;
                },
            });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(102);
        r(r.G + r.F * (parseInt != s), { parseInt: s });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(103);
        r(r.G + r.F * (parseFloat != s), { parseFloat: s });
    },
    function (t, e, n) {
        "use strict";
        var r = n(3),
            s = n(16),
            i = n(27),
            o = n(72),
            a = n(30),
            c = n(4),
            l = n(38).f,
            u = n(24).f,
            h = n(11).f,
            p = n(44).trim,
            d = "Number",
            f = r.Number,
            m = f,
            y = f.prototype,
            g = i(n(37)(y)) == d,
            v = "trim" in String.prototype,
            b = function (t) {
                var e = a(t, !1);
                if ("string" == typeof e && e.length > 2) {
                    var n,
                        r,
                        s,
                        i = (e = v ? e.trim() : p(e, 3)).charCodeAt(0);
                    if (43 === i || 45 === i) {
                        if (88 === (n = e.charCodeAt(2)) || 120 === n)
                            return NaN;
                    } else if (48 === i) {
                        switch (e.charCodeAt(1)) {
                            case 66:
                            case 98:
                                (r = 2), (s = 49);
                                break;
                            case 79:
                            case 111:
                                (r = 8), (s = 55);
                                break;
                            default:
                                return +e;
                        }
                        for (
                            var o, c = e.slice(2), l = 0, u = c.length;
                            l < u;
                            l++
                        )
                            if ((o = c.charCodeAt(l)) < 48 || o > s) return NaN;
                        return parseInt(c, r);
                    }
                }
                return +e;
            };
        if (!f(" 0o1") || !f("0b1") || f("+0x1")) {
            f = function (t) {
                var e = arguments.length < 1 ? 0 : t,
                    n = this;
                return n instanceof f &&
                    (g
                        ? c(function () {
                              y.valueOf.call(n);
                          })
                        : i(n) != d)
                    ? o(new m(b(e)), n, f)
                    : b(e);
            };
            for (
                var x,
                    w = n(10)
                        ? l(m)
                        : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(
                              ","
                          ),
                    P = 0;
                w.length > P;
                P++
            )
                s(m, (x = w[P])) && !s(f, x) && h(f, x, u(m, x));
            (f.prototype = y), (y.constructor = f), n(13)(r, d, f);
        }
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(23),
            i = n(104),
            o = n(73),
            a = (1).toFixed,
            c = Math.floor,
            l = [0, 0, 0, 0, 0, 0],
            u = "Number.toFixed: incorrect invocation!",
            h = "0",
            p = function (t, e) {
                for (var n = -1, r = e; ++n < 6; )
                    (r += t * l[n]), (l[n] = r % 1e7), (r = c(r / 1e7));
            },
            d = function (t) {
                for (var e = 6, n = 0; --e >= 0; )
                    (n += l[e]), (l[e] = c(n / t)), (n = (n % t) * 1e7);
            },
            f = function () {
                for (var t = 6, e = ""; --t >= 0; )
                    if ("" !== e || 0 === t || 0 !== l[t]) {
                        var n = String(l[t]);
                        e = "" === e ? n : e + o.call(h, 7 - n.length) + n;
                    }
                return e;
            },
            m = function (t, e, n) {
                return 0 === e
                    ? n
                    : e % 2 == 1
                    ? m(t, e - 1, n * t)
                    : m(t * t, e / 2, n);
            };
        r(
            r.P +
                r.F *
                    ((!!a &&
                        ("0.000" !== (8e-5).toFixed(3) ||
                            "1" !== (0.9).toFixed(0) ||
                            "1.25" !== (1.255).toFixed(2) ||
                            "1000000000000000128" !==
                                (0xde0b6b3a7640080).toFixed(0))) ||
                        !n(4)(function () {
                            a.call({});
                        })),
            "Number",
            {
                toFixed: function (t) {
                    var e,
                        n,
                        r,
                        a,
                        c = i(this, u),
                        l = s(t),
                        y = "",
                        g = h;
                    if (l < 0 || l > 20) throw RangeError(u);
                    if (c != c) return "NaN";
                    if (c <= -1e21 || c >= 1e21) return String(c);
                    if ((c < 0 && ((y = "-"), (c = -c)), c > 1e-21))
                        if (
                            ((n =
                                (e =
                                    (function (t) {
                                        for (var e = 0, n = t; n >= 4096; )
                                            (e += 12), (n /= 4096);
                                        for (; n >= 2; ) (e += 1), (n /= 2);
                                        return e;
                                    })(c * m(2, 69, 1)) - 69) < 0
                                    ? c * m(2, -e, 1)
                                    : c / m(2, e, 1)),
                            (n *= 4503599627370496),
                            (e = 52 - e) > 0)
                        ) {
                            for (p(0, n), r = l; r >= 7; ) p(1e7, 0), (r -= 7);
                            for (p(m(10, r, 1), 0), r = e - 1; r >= 23; )
                                d(1 << 23), (r -= 23);
                            d(1 << r), p(1, 1), d(2), (g = f());
                        } else p(0, n), p(1 << -e, 0), (g = f() + o.call(h, l));
                    return (g =
                        l > 0
                            ? y +
                              ((a = g.length) <= l
                                  ? "0." + o.call(h, l - a) + g
                                  : g.slice(0, a - l) + "." + g.slice(a - l))
                            : y + g);
                },
            }
        );
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(4),
            i = n(104),
            o = (1).toPrecision;
        r(
            r.P +
                r.F *
                    (s(function () {
                        return "1" !== o.call(1, void 0);
                    }) ||
                        !s(function () {
                            o.call({});
                        })),
            "Number",
            {
                toPrecision: function (t) {
                    var e = i(
                        this,
                        "Number#toPrecision: incorrect invocation!"
                    );
                    return void 0 === t ? o.call(e) : o.call(e, t);
                },
            }
        );
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Number", { EPSILON: Math.pow(2, -52) });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(3).isFinite;
        r(r.S, "Number", {
            isFinite: function (t) {
                return "number" == typeof t && s(t);
            },
        });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Number", { isInteger: n(105) });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Number", {
            isNaN: function (t) {
                return t != t;
            },
        });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(105),
            i = Math.abs;
        r(r.S, "Number", {
            isSafeInteger: function (t) {
                return s(t) && i(t) <= 9007199254740991;
            },
        });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Number", { MAX_SAFE_INTEGER: 9007199254740991 });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Number", { MIN_SAFE_INTEGER: -9007199254740991 });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(103);
        r(r.S + r.F * (Number.parseFloat != s), "Number", { parseFloat: s });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(102);
        r(r.S + r.F * (Number.parseInt != s), "Number", { parseInt: s });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(106),
            i = Math.sqrt,
            o = Math.acosh;
        r(
            r.S +
                r.F *
                    !(
                        o &&
                        710 == Math.floor(o(Number.MAX_VALUE)) &&
                        o(1 / 0) == 1 / 0
                    ),
            "Math",
            {
                acosh: function (t) {
                    return (t = +t) < 1
                        ? NaN
                        : t > 94906265.62425156
                        ? Math.log(t) + Math.LN2
                        : s(t - 1 + i(t - 1) * i(t + 1));
                },
            }
        );
    },
    function (t, e, n) {
        var r = n(2),
            s = Math.asinh;
        r(r.S + r.F * !(s && 1 / s(0) > 0), "Math", {
            asinh: function t(e) {
                return isFinite((e = +e)) && 0 != e
                    ? e < 0
                        ? -t(-e)
                        : Math.log(e + Math.sqrt(e * e + 1))
                    : e;
            },
        });
    },
    function (t, e, n) {
        var r = n(2),
            s = Math.atanh;
        r(r.S + r.F * !(s && 1 / s(-0) < 0), "Math", {
            atanh: function (t) {
                return 0 == (t = +t) ? t : Math.log((1 + t) / (1 - t)) / 2;
            },
        });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(74);
        r(r.S, "Math", {
            cbrt: function (t) {
                return s((t = +t)) * Math.pow(Math.abs(t), 1 / 3);
            },
        });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Math", {
            clz32: function (t) {
                return (t >>>= 0)
                    ? 31 - Math.floor(Math.log(t + 0.5) * Math.LOG2E)
                    : 32;
            },
        });
    },
    function (t, e, n) {
        var r = n(2),
            s = Math.exp;
        r(r.S, "Math", {
            cosh: function (t) {
                return (s((t = +t)) + s(-t)) / 2;
            },
        });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(75);
        r(r.S + r.F * (s != Math.expm1), "Math", { expm1: s });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Math", { fround: n(217) });
    },
    function (t, e, n) {
        var r = n(74),
            s = Math.pow,
            i = s(2, -52),
            o = s(2, -23),
            a = s(2, 127) * (2 - o),
            c = s(2, -126);
        t.exports =
            Math.fround ||
            function (t) {
                var e,
                    n,
                    s = Math.abs(t),
                    l = r(t);
                return s < c
                    ? l * (s / c / o + 1 / i - 1 / i) * c * o
                    : (n = (e = (1 + o / i) * s) - (e - s)) > a || n != n
                    ? l * (1 / 0)
                    : l * n;
            };
    },
    function (t, e, n) {
        var r = n(2),
            s = Math.abs;
        r(r.S, "Math", {
            hypot: function (t, e) {
                for (
                    var n, r, i = 0, o = 0, a = arguments.length, c = 0;
                    o < a;

                )
                    c < (n = s(arguments[o++]))
                        ? ((i = i * (r = c / n) * r + 1), (c = n))
                        : (i += n > 0 ? (r = n / c) * r : n);
                return c === 1 / 0 ? 1 / 0 : c * Math.sqrt(i);
            },
        });
    },
    function (t, e, n) {
        var r = n(2),
            s = Math.imul;
        r(
            r.S +
                r.F *
                    n(4)(function () {
                        return -5 != s(4294967295, 5) || 2 != s.length;
                    }),
            "Math",
            {
                imul: function (t, e) {
                    var n = 65535,
                        r = +t,
                        s = +e,
                        i = n & r,
                        o = n & s;
                    return (
                        0 |
                        (i * o +
                            ((((n & (r >>> 16)) * o + i * (n & (s >>> 16))) <<
                                16) >>>
                                0))
                    );
                },
            }
        );
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Math", {
            log10: function (t) {
                return Math.log(t) * Math.LOG10E;
            },
        });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Math", { log1p: n(106) });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Math", {
            log2: function (t) {
                return Math.log(t) / Math.LN2;
            },
        });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Math", { sign: n(74) });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(75),
            i = Math.exp;
        r(
            r.S +
                r.F *
                    n(4)(function () {
                        return -2e-17 != !Math.sinh(-2e-17);
                    }),
            "Math",
            {
                sinh: function (t) {
                    return Math.abs((t = +t)) < 1
                        ? (s(t) - s(-t)) / 2
                        : (i(t - 1) - i(-t - 1)) * (Math.E / 2);
                },
            }
        );
    },
    function (t, e, n) {
        var r = n(2),
            s = n(75),
            i = Math.exp;
        r(r.S, "Math", {
            tanh: function (t) {
                var e = s((t = +t)),
                    n = s(-t);
                return e == 1 / 0
                    ? 1
                    : n == 1 / 0
                    ? -1
                    : (e - n) / (i(t) + i(-t));
            },
        });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Math", {
            trunc: function (t) {
                return (t > 0 ? Math.floor : Math.ceil)(t);
            },
        });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(36),
            i = String.fromCharCode,
            o = String.fromCodePoint;
        r(r.S + r.F * (!!o && 1 != o.length), "String", {
            fromCodePoint: function (t) {
                for (var e, n = [], r = arguments.length, o = 0; r > o; ) {
                    if (((e = +arguments[o++]), s(e, 1114111) !== e))
                        throw RangeError(e + " is not a valid code point");
                    n.push(
                        e < 65536
                            ? i(e)
                            : i(
                                  55296 + ((e -= 65536) >> 10),
                                  (e % 1024) + 56320
                              )
                    );
                }
                return n.join("");
            },
        });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(18),
            i = n(8);
        r(r.S, "String", {
            raw: function (t) {
                for (
                    var e = s(t.raw),
                        n = i(e.length),
                        r = arguments.length,
                        o = [],
                        a = 0;
                    n > a;

                )
                    o.push(String(e[a++])),
                        a < r && o.push(String(arguments[a]));
                return o.join("");
            },
        });
    },
    function (t, e, n) {
        "use strict";
        n(44)("trim", function (t) {
            return function () {
                return t(this, 3);
            };
        });
    },
    function (t, e, n) {
        "use strict";
        var r = n(76)(!0);
        n(77)(
            String,
            "String",
            function (t) {
                (this._t = String(t)), (this._i = 0);
            },
            function () {
                var t,
                    e = this._t,
                    n = this._i;
                return n >= e.length
                    ? { value: void 0, done: !0 }
                    : ((t = r(e, n)),
                      (this._i += t.length),
                      { value: t, done: !1 });
            }
        );
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(76)(!1);
        r(r.P, "String", {
            codePointAt: function (t) {
                return s(this, t);
            },
        });
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(8),
            i = n(78),
            o = "endsWith",
            a = "".endsWith;
        r(r.P + r.F * n(80)(o), "String", {
            endsWith: function (t) {
                var e = i(this, t, o),
                    n = arguments.length > 1 ? arguments[1] : void 0,
                    r = s(e.length),
                    c = void 0 === n ? r : Math.min(s(n), r),
                    l = String(t);
                return a ? a.call(e, l, c) : e.slice(c - l.length, c) === l;
            },
        });
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(78),
            i = "includes";
        r(r.P + r.F * n(80)(i), "String", {
            includes: function (t) {
                return !!~s(this, t, i).indexOf(
                    t,
                    arguments.length > 1 ? arguments[1] : void 0
                );
            },
        });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.P, "String", { repeat: n(73) });
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(8),
            i = n(78),
            o = "startsWith",
            a = "".startsWith;
        r(r.P + r.F * n(80)(o), "String", {
            startsWith: function (t) {
                var e = i(this, t, o),
                    n = s(
                        Math.min(
                            arguments.length > 1 ? arguments[1] : void 0,
                            e.length
                        )
                    ),
                    r = String(t);
                return a ? a.call(e, r, n) : e.slice(n, n + r.length) === r;
            },
        });
    },
    function (t, e, n) {
        "use strict";
        n(14)("anchor", function (t) {
            return function (e) {
                return t(this, "a", "name", e);
            };
        });
    },
    function (t, e, n) {
        "use strict";
        n(14)("big", function (t) {
            return function () {
                return t(this, "big", "", "");
            };
        });
    },
    function (t, e, n) {
        "use strict";
        n(14)("blink", function (t) {
            return function () {
                return t(this, "blink", "", "");
            };
        });
    },
    function (t, e, n) {
        "use strict";
        n(14)("bold", function (t) {
            return function () {
                return t(this, "b", "", "");
            };
        });
    },
    function (t, e, n) {
        "use strict";
        n(14)("fixed", function (t) {
            return function () {
                return t(this, "tt", "", "");
            };
        });
    },
    function (t, e, n) {
        "use strict";
        n(14)("fontcolor", function (t) {
            return function (e) {
                return t(this, "font", "color", e);
            };
        });
    },
    function (t, e, n) {
        "use strict";
        n(14)("fontsize", function (t) {
            return function (e) {
                return t(this, "font", "size", e);
            };
        });
    },
    function (t, e, n) {
        "use strict";
        n(14)("italics", function (t) {
            return function () {
                return t(this, "i", "", "");
            };
        });
    },
    function (t, e, n) {
        "use strict";
        n(14)("link", function (t) {
            return function (e) {
                return t(this, "a", "href", e);
            };
        });
    },
    function (t, e, n) {
        "use strict";
        n(14)("small", function (t) {
            return function () {
                return t(this, "small", "", "");
            };
        });
    },
    function (t, e, n) {
        "use strict";
        n(14)("strike", function (t) {
            return function () {
                return t(this, "strike", "", "");
            };
        });
    },
    function (t, e, n) {
        "use strict";
        n(14)("sub", function (t) {
            return function () {
                return t(this, "sub", "", "");
            };
        });
    },
    function (t, e, n) {
        "use strict";
        n(14)("sup", function (t) {
            return function () {
                return t(this, "sup", "", "");
            };
        });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Date", {
            now: function () {
                return new Date().getTime();
            },
        });
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(12),
            i = n(30);
        r(
            r.P +
                r.F *
                    n(4)(function () {
                        return (
                            null !== new Date(NaN).toJSON() ||
                            1 !==
                                Date.prototype.toJSON.call({
                                    toISOString: function () {
                                        return 1;
                                    },
                                })
                        );
                    }),
            "Date",
            {
                toJSON: function (t) {
                    var e = s(this),
                        n = i(e);
                    return "number" != typeof n || isFinite(n)
                        ? e.toISOString()
                        : null;
                },
            }
        );
    },
    function (t, e, n) {
        var r = n(2),
            s = n(252);
        r(r.P + r.F * (Date.prototype.toISOString !== s), "Date", {
            toISOString: s,
        });
    },
    function (t, e, n) {
        "use strict";
        var r = n(4),
            s = Date.prototype.getTime,
            i = Date.prototype.toISOString,
            o = function (t) {
                return t > 9 ? t : "0" + t;
            };
        t.exports =
            r(function () {
                return (
                    "0385-07-25T07:06:39.999Z" !=
                    i.call(new Date(-50000000000001))
                );
            }) ||
            !r(function () {
                i.call(new Date(NaN));
            })
                ? function () {
                      if (!isFinite(s.call(this)))
                          throw RangeError("Invalid time value");
                      var t = this,
                          e = t.getUTCFullYear(),
                          n = t.getUTCMilliseconds(),
                          r = e < 0 ? "-" : e > 9999 ? "+" : "";
                      return (
                          r +
                          ("00000" + Math.abs(e)).slice(r ? -6 : -4) +
                          "-" +
                          o(t.getUTCMonth() + 1) +
                          "-" +
                          o(t.getUTCDate()) +
                          "T" +
                          o(t.getUTCHours()) +
                          ":" +
                          o(t.getUTCMinutes()) +
                          ":" +
                          o(t.getUTCSeconds()) +
                          "." +
                          (n > 99 ? n : "0" + o(n)) +
                          "Z"
                      );
                  }
                : i;
    },
    function (t, e, n) {
        var r = Date.prototype,
            s = "Invalid Date",
            i = "toString",
            o = r.toString,
            a = r.getTime;
        new Date(NaN) + "" != s &&
            n(13)(r, i, function () {
                var t = a.call(this);
                return t == t ? o.call(this) : s;
            });
    },
    function (t, e, n) {
        var r = n(7)("toPrimitive"),
            s = Date.prototype;
        r in s || n(17)(s, r, n(255));
    },
    function (t, e, n) {
        "use strict";
        var r = n(5),
            s = n(30),
            i = "number";
        t.exports = function (t) {
            if ("string" !== t && t !== i && "default" !== t)
                throw TypeError("Incorrect hint");
            return s(r(this), t != i);
        };
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Array", { isArray: n(56) });
    },
    function (t, e, n) {
        "use strict";
        var r = n(21),
            s = n(2),
            i = n(12),
            o = n(108),
            a = n(81),
            c = n(8),
            l = n(82),
            u = n(83);
        s(
            s.S +
                s.F *
                    !n(57)(function (t) {
                        Array.from(t);
                    }),
            "Array",
            {
                from: function (t) {
                    var e,
                        n,
                        s,
                        h,
                        p = i(t),
                        d = "function" == typeof this ? this : Array,
                        f = arguments.length,
                        m = f > 1 ? arguments[1] : void 0,
                        y = void 0 !== m,
                        g = 0,
                        v = u(p);
                    if (
                        (y && (m = r(m, f > 2 ? arguments[2] : void 0, 2)),
                        null == v || (d == Array && a(v)))
                    )
                        for (n = new d((e = c(p.length))); e > g; g++)
                            l(n, g, y ? m(p[g], g) : p[g]);
                    else
                        for (
                            h = v.call(p), n = new d();
                            !(s = h.next()).done;
                            g++
                        )
                            l(n, g, y ? o(h, m, [s.value, g], !0) : s.value);
                    return (n.length = g), n;
                },
            }
        );
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(82);
        r(
            r.S +
                r.F *
                    n(4)(function () {
                        function t() {}
                        return !(Array.of.call(t) instanceof t);
                    }),
            "Array",
            {
                of: function () {
                    for (
                        var t = 0,
                            e = arguments.length,
                            n = new ("function" == typeof this ? this : Array)(
                                e
                            );
                        e > t;

                    )
                        s(n, t, arguments[t++]);
                    return (n.length = e), n;
                },
            }
        );
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(18),
            i = [].join;
        r(r.P + r.F * (n(49) != Object || !n(20)(i)), "Array", {
            join: function (t) {
                return i.call(s(this), void 0 === t ? "," : t);
            },
        });
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(69),
            i = n(27),
            o = n(36),
            a = n(8),
            c = [].slice;
        r(
            r.P +
                r.F *
                    n(4)(function () {
                        s && c.call(s);
                    }),
            "Array",
            {
                slice: function (t, e) {
                    var n = a(this.length),
                        r = i(this);
                    if (((e = void 0 === e ? n : e), "Array" == r))
                        return c.call(this, t, e);
                    for (
                        var s = o(t, n),
                            l = o(e, n),
                            u = a(l - s),
                            h = new Array(u),
                            p = 0;
                        p < u;
                        p++
                    )
                        h[p] = "String" == r ? this.charAt(s + p) : this[s + p];
                    return h;
                },
            }
        );
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(22),
            i = n(12),
            o = n(4),
            a = [].sort,
            c = [1, 2, 3];
        r(
            r.P +
                r.F *
                    (o(function () {
                        c.sort(void 0);
                    }) ||
                        !o(function () {
                            c.sort(null);
                        }) ||
                        !n(20)(a)),
            "Array",
            {
                sort: function (t) {
                    return void 0 === t
                        ? a.call(i(this))
                        : a.call(i(this), s(t));
                },
            }
        );
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(26)(0),
            i = n(20)([].forEach, !0);
        r(r.P + r.F * !i, "Array", {
            forEach: function (t) {
                return s(this, t, arguments[1]);
            },
        });
    },
    function (t, e, n) {
        var r = n(6),
            s = n(56),
            i = n(7)("species");
        t.exports = function (t) {
            var e;
            return (
                s(t) &&
                    ("function" != typeof (e = t.constructor) ||
                        (e !== Array && !s(e.prototype)) ||
                        (e = void 0),
                    r(e) && null === (e = e[i]) && (e = void 0)),
                void 0 === e ? Array : e
            );
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(26)(1);
        r(r.P + r.F * !n(20)([].map, !0), "Array", {
            map: function (t) {
                return s(this, t, arguments[1]);
            },
        });
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(26)(2);
        r(r.P + r.F * !n(20)([].filter, !0), "Array", {
            filter: function (t) {
                return s(this, t, arguments[1]);
            },
        });
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(26)(3);
        r(r.P + r.F * !n(20)([].some, !0), "Array", {
            some: function (t) {
                return s(this, t, arguments[1]);
            },
        });
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(26)(4);
        r(r.P + r.F * !n(20)([].every, !0), "Array", {
            every: function (t) {
                return s(this, t, arguments[1]);
            },
        });
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(110);
        r(r.P + r.F * !n(20)([].reduce, !0), "Array", {
            reduce: function (t) {
                return s(this, t, arguments.length, arguments[1], !1);
            },
        });
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(110);
        r(r.P + r.F * !n(20)([].reduceRight, !0), "Array", {
            reduceRight: function (t) {
                return s(this, t, arguments.length, arguments[1], !0);
            },
        });
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(54)(!1),
            i = [].indexOf,
            o = !!i && 1 / [1].indexOf(1, -0) < 0;
        r(r.P + r.F * (o || !n(20)(i)), "Array", {
            indexOf: function (t) {
                return o
                    ? i.apply(this, arguments) || 0
                    : s(this, t, arguments[1]);
            },
        });
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(18),
            i = n(23),
            o = n(8),
            a = [].lastIndexOf,
            c = !!a && 1 / [1].lastIndexOf(1, -0) < 0;
        r(r.P + r.F * (c || !n(20)(a)), "Array", {
            lastIndexOf: function (t) {
                if (c) return a.apply(this, arguments) || 0;
                var e = s(this),
                    n = o(e.length),
                    r = n - 1;
                for (
                    arguments.length > 1 && (r = Math.min(r, i(arguments[1]))),
                        r < 0 && (r = n + r);
                    r >= 0;
                    r--
                )
                    if (r in e && e[r] === t) return r || 0;
                return -1;
            },
        });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.P, "Array", { copyWithin: n(111) }), n(40)("copyWithin");
    },
    function (t, e, n) {
        var r = n(2);
        r(r.P, "Array", { fill: n(84) }), n(40)("fill");
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(26)(5),
            i = "find",
            o = !0;
        i in [] &&
            Array(1).find(function () {
                o = !1;
            }),
            r(r.P + r.F * o, "Array", {
                find: function (t) {
                    return s(
                        this,
                        t,
                        arguments.length > 1 ? arguments[1] : void 0
                    );
                },
            }),
            n(40)(i);
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(26)(6),
            i = "findIndex",
            o = !0;
        i in [] &&
            Array(1)[i](function () {
                o = !1;
            }),
            r(r.P + r.F * o, "Array", {
                findIndex: function (t) {
                    return s(
                        this,
                        t,
                        arguments.length > 1 ? arguments[1] : void 0
                    );
                },
            }),
            n(40)(i);
    },
    function (t, e, n) {
        n(46)("Array");
    },
    function (t, e, n) {
        var r = n(3),
            s = n(72),
            i = n(11).f,
            o = n(38).f,
            a = n(79),
            c = n(58),
            l = r.RegExp,
            u = l,
            h = l.prototype,
            p = /a/g,
            d = /a/g,
            f = new l(p) !== p;
        if (
            n(10) &&
            (!f ||
                n(4)(function () {
                    return (
                        (d[n(7)("match")] = !1),
                        l(p) != p || l(d) == d || "/a/i" != l(p, "i")
                    );
                }))
        ) {
            l = function (t, e) {
                var n = this instanceof l,
                    r = a(t),
                    i = void 0 === e;
                return !n && r && t.constructor === l && i
                    ? t
                    : s(
                          f
                              ? new u(r && !i ? t.source : t, e)
                              : u(
                                    (r = t instanceof l) ? t.source : t,
                                    r && i ? c.call(t) : e
                                ),
                          n ? this : h,
                          l
                      );
            };
            for (
                var m = function (t) {
                        (t in l) ||
                            i(l, t, {
                                configurable: !0,
                                get: function () {
                                    return u[t];
                                },
                                set: function (e) {
                                    u[t] = e;
                                },
                            });
                    },
                    y = o(u),
                    g = 0;
                y.length > g;

            )
                m(y[g++]);
            (h.constructor = l), (l.prototype = h), n(13)(r, "RegExp", l);
        }
        n(46)("RegExp");
    },
    function (t, e, n) {
        "use strict";
        n(114);
        var r = n(5),
            s = n(58),
            i = n(10),
            o = "toString",
            a = /./.toString,
            c = function (t) {
                n(13)(RegExp.prototype, o, t, !0);
            };
        n(4)(function () {
            return "/a/b" != a.call({ source: "a", flags: "b" });
        })
            ? c(function () {
                  var t = r(this);
                  return "/".concat(
                      t.source,
                      "/",
                      "flags" in t
                          ? t.flags
                          : !i && t instanceof RegExp
                          ? s.call(t)
                          : void 0
                  );
              })
            : a.name != o &&
              c(function () {
                  return a.call(this);
              });
    },
    function (t, e, n) {
        "use strict";
        var r = n(5),
            s = n(8),
            i = n(87),
            o = n(59);
        n(60)("match", 1, function (t, e, n, a) {
            return [
                function (n) {
                    var r = t(this),
                        s = null == n ? void 0 : n[e];
                    return void 0 !== s
                        ? s.call(n, r)
                        : new RegExp(n)[e](String(r));
                },
                function (t) {
                    var e = a(n, t, this);
                    if (e.done) return e.value;
                    var c = r(t),
                        l = String(this);
                    if (!c.global) return o(c, l);
                    var u = c.unicode;
                    c.lastIndex = 0;
                    for (var h, p = [], d = 0; null !== (h = o(c, l)); ) {
                        var f = String(h[0]);
                        (p[d] = f),
                            "" === f && (c.lastIndex = i(l, s(c.lastIndex), u)),
                            d++;
                    }
                    return 0 === d ? null : p;
                },
            ];
        });
    },
    function (t, e, n) {
        "use strict";
        var r = n(5),
            s = n(12),
            i = n(8),
            o = n(23),
            a = n(87),
            c = n(59),
            l = Math.max,
            u = Math.min,
            h = Math.floor,
            p = /\$([$&`']|\d\d?|<[^>]*>)/g,
            d = /\$([$&`']|\d\d?)/g;
        n(60)("replace", 2, function (t, e, n, f) {
            return [
                function (r, s) {
                    var i = t(this),
                        o = null == r ? void 0 : r[e];
                    return void 0 !== o
                        ? o.call(r, i, s)
                        : n.call(String(i), r, s);
                },
                function (t, e) {
                    var s = f(n, t, this, e);
                    if (s.done) return s.value;
                    var h = r(t),
                        p = String(this),
                        d = "function" == typeof e;
                    d || (e = String(e));
                    var y = h.global;
                    if (y) {
                        var g = h.unicode;
                        h.lastIndex = 0;
                    }
                    for (var v = []; ; ) {
                        var b = c(h, p);
                        if (null === b) break;
                        if ((v.push(b), !y)) break;
                        "" === String(b[0]) &&
                            (h.lastIndex = a(p, i(h.lastIndex), g));
                    }
                    for (var x, w = "", P = 0, A = 0; A < v.length; A++) {
                        b = v[A];
                        for (
                            var E = String(b[0]),
                                T = l(u(o(b.index), p.length), 0),
                                S = [],
                                C = 1;
                            C < b.length;
                            C++
                        )
                            S.push(void 0 === (x = b[C]) ? x : String(x));
                        var O = b.groups;
                        if (d) {
                            var k = [E].concat(S, T, p);
                            void 0 !== O && k.push(O);
                            var _ = String(e.apply(void 0, k));
                        } else _ = m(E, p, T, S, O, e);
                        T >= P &&
                            ((w += p.slice(P, T) + _), (P = T + E.length));
                    }
                    return w + p.slice(P);
                },
            ];
            function m(t, e, r, i, o, a) {
                var c = r + t.length,
                    l = i.length,
                    u = d;
                return (
                    void 0 !== o && ((o = s(o)), (u = p)),
                    n.call(a, u, function (n, s) {
                        var a;
                        switch (s.charAt(0)) {
                            case "$":
                                return "$";
                            case "&":
                                return t;
                            case "`":
                                return e.slice(0, r);
                            case "'":
                                return e.slice(c);
                            case "<":
                                a = o[s.slice(1, -1)];
                                break;
                            default:
                                var u = +s;
                                if (0 === u) return n;
                                if (u > l) {
                                    var p = h(u / 10);
                                    return 0 === p
                                        ? n
                                        : p <= l
                                        ? void 0 === i[p - 1]
                                            ? s.charAt(1)
                                            : i[p - 1] + s.charAt(1)
                                        : n;
                                }
                                a = i[u - 1];
                        }
                        return void 0 === a ? "" : a;
                    })
                );
            }
        });
    },
    function (t, e, n) {
        "use strict";
        var r = n(5),
            s = n(99),
            i = n(59);
        n(60)("search", 1, function (t, e, n, o) {
            return [
                function (n) {
                    var r = t(this),
                        s = null == n ? void 0 : n[e];
                    return void 0 !== s
                        ? s.call(n, r)
                        : new RegExp(n)[e](String(r));
                },
                function (t) {
                    var e = o(n, t, this);
                    if (e.done) return e.value;
                    var a = r(t),
                        c = String(this),
                        l = a.lastIndex;
                    s(l, 0) || (a.lastIndex = 0);
                    var u = i(a, c);
                    return (
                        s(a.lastIndex, l) || (a.lastIndex = l),
                        null === u ? -1 : u.index
                    );
                },
            ];
        });
    },
    function (t, e, n) {
        "use strict";
        var r = n(79),
            s = n(5),
            i = n(52),
            o = n(87),
            a = n(8),
            c = n(59),
            l = n(86),
            u = n(4),
            h = Math.min,
            p = [].push,
            d = 4294967295,
            f = !u(function () {
                RegExp(d, "y");
            });
        n(60)("split", 2, function (t, e, n, u) {
            var m;
            return (
                (m =
                    "c" == "abbc".split(/(b)*/)[1] ||
                    4 != "test".split(/(?:)/, -1).length ||
                    2 != "ab".split(/(?:ab)*/).length ||
                    4 != ".".split(/(.?)(.?)/).length ||
                    ".".split(/()()/).length > 1 ||
                    "".split(/.?/).length
                        ? function (t, e) {
                              var s = String(this);
                              if (void 0 === t && 0 === e) return [];
                              if (!r(t)) return n.call(s, t, e);
                              for (
                                  var i,
                                      o,
                                      a,
                                      c = [],
                                      u =
                                          (t.ignoreCase ? "i" : "") +
                                          (t.multiline ? "m" : "") +
                                          (t.unicode ? "u" : "") +
                                          (t.sticky ? "y" : ""),
                                      h = 0,
                                      f = void 0 === e ? d : e >>> 0,
                                      m = new RegExp(t.source, u + "g");
                                  (i = l.call(m, s)) &&
                                  !(
                                      (o = m.lastIndex) > h &&
                                      (c.push(s.slice(h, i.index)),
                                      i.length > 1 &&
                                          i.index < s.length &&
                                          p.apply(c, i.slice(1)),
                                      (a = i[0].length),
                                      (h = o),
                                      c.length >= f)
                                  );

                              )
                                  m.lastIndex === i.index && m.lastIndex++;
                              return (
                                  h === s.length
                                      ? (!a && m.test("")) || c.push("")
                                      : c.push(s.slice(h)),
                                  c.length > f ? c.slice(0, f) : c
                              );
                          }
                        : "0".split(void 0, 0).length
                        ? function (t, e) {
                              return void 0 === t && 0 === e
                                  ? []
                                  : n.call(this, t, e);
                          }
                        : n),
                [
                    function (n, r) {
                        var s = t(this),
                            i = null == n ? void 0 : n[e];
                        return void 0 !== i
                            ? i.call(n, s, r)
                            : m.call(String(s), n, r);
                    },
                    function (t, e) {
                        var r = u(m, t, this, e, m !== n);
                        if (r.done) return r.value;
                        var l = s(t),
                            p = String(this),
                            y = i(l, RegExp),
                            g = l.unicode,
                            v =
                                (l.ignoreCase ? "i" : "") +
                                (l.multiline ? "m" : "") +
                                (l.unicode ? "u" : "") +
                                (f ? "y" : "g"),
                            b = new y(f ? l : "^(?:" + l.source + ")", v),
                            x = void 0 === e ? d : e >>> 0;
                        if (0 === x) return [];
                        if (0 === p.length) return null === c(b, p) ? [p] : [];
                        for (var w = 0, P = 0, A = []; P < p.length; ) {
                            b.lastIndex = f ? P : 0;
                            var E,
                                T = c(b, f ? p : p.slice(P));
                            if (
                                null === T ||
                                (E = h(
                                    a(b.lastIndex + (f ? 0 : P)),
                                    p.length
                                )) === w
                            )
                                P = o(p, P, g);
                            else {
                                if ((A.push(p.slice(w, P)), A.length === x))
                                    return A;
                                for (var S = 1; S <= T.length - 1; S++)
                                    if ((A.push(T[S]), A.length === x))
                                        return A;
                                P = w = E;
                            }
                        }
                        return A.push(p.slice(w)), A;
                    },
                ]
            );
        });
    },
    function (t, e, n) {
        var r = n(3),
            s = n(88).set,
            i = r.MutationObserver || r.WebKitMutationObserver,
            o = r.process,
            a = r.Promise,
            c = "process" == n(27)(o);
        t.exports = function () {
            var t,
                e,
                n,
                l = function () {
                    var r, s;
                    for (c && (r = o.domain) && r.exit(); t; ) {
                        (s = t.fn), (t = t.next);
                        try {
                            s();
                        } catch (r) {
                            throw (t ? n() : (e = void 0), r);
                        }
                    }
                    (e = void 0), r && r.enter();
                };
            if (c)
                n = function () {
                    o.nextTick(l);
                };
            else if (!i || (r.navigator && r.navigator.standalone))
                if (a && a.resolve) {
                    var u = a.resolve(void 0);
                    n = function () {
                        u.then(l);
                    };
                } else
                    n = function () {
                        s.call(r, l);
                    };
            else {
                var h = !0,
                    p = document.createTextNode("");
                new i(l).observe(p, { characterData: !0 }),
                    (n = function () {
                        p.data = h = !h;
                    });
            }
            return function (r) {
                var s = { fn: r, next: void 0 };
                e && (e.next = s), t || ((t = s), n()), (e = s);
            };
        };
    },
    function (t, e) {
        t.exports = function (t) {
            try {
                return { e: !1, v: t() };
            } catch (t) {
                return { e: !0, v: t };
            }
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(118),
            s = n(41),
            i = "Map";
        t.exports = n(63)(
            i,
            function (t) {
                return function () {
                    return t(
                        this,
                        arguments.length > 0 ? arguments[0] : void 0
                    );
                };
            },
            {
                get: function (t) {
                    var e = r.getEntry(s(this, i), t);
                    return e && e.v;
                },
                set: function (t, e) {
                    return r.def(s(this, i), 0 === t ? 0 : t, e);
                },
            },
            r,
            !0
        );
    },
    function (t, e, n) {
        "use strict";
        var r = n(118),
            s = n(41);
        t.exports = n(63)(
            "Set",
            function (t) {
                return function () {
                    return t(
                        this,
                        arguments.length > 0 ? arguments[0] : void 0
                    );
                };
            },
            {
                add: function (t) {
                    return r.def(s(this, "Set"), (t = 0 === t ? 0 : t), t);
                },
            },
            r
        );
    },
    function (t, e, n) {
        "use strict";
        var r,
            s = n(3),
            i = n(26)(0),
            o = n(13),
            a = n(31),
            c = n(98),
            l = n(119),
            u = n(6),
            h = n(41),
            p = n(41),
            d = !s.ActiveXObject && "ActiveXObject" in s,
            f = "WeakMap",
            m = a.getWeak,
            y = Object.isExtensible,
            g = l.ufstore,
            v = function (t) {
                return function () {
                    return t(
                        this,
                        arguments.length > 0 ? arguments[0] : void 0
                    );
                };
            },
            b = {
                get: function (t) {
                    if (u(t)) {
                        var e = m(t);
                        return !0 === e
                            ? g(h(this, f)).get(t)
                            : e
                            ? e[this._i]
                            : void 0;
                    }
                },
                set: function (t, e) {
                    return l.def(h(this, f), t, e);
                },
            },
            x = (t.exports = n(63)(f, v, b, l, !0, !0));
        p &&
            d &&
            (c((r = l.getConstructor(v, f)).prototype, b),
            (a.NEED = !0),
            i(["delete", "has", "get", "set"], function (t) {
                var e = x.prototype,
                    n = e[t];
                o(e, t, function (e, s) {
                    if (u(e) && !y(e)) {
                        this._f || (this._f = new r());
                        var i = this._f[t](e, s);
                        return "set" == t ? this : i;
                    }
                    return n.call(this, e, s);
                });
            }));
    },
    function (t, e, n) {
        "use strict";
        var r = n(119),
            s = n(41),
            i = "WeakSet";
        n(63)(
            i,
            function (t) {
                return function () {
                    return t(
                        this,
                        arguments.length > 0 ? arguments[0] : void 0
                    );
                };
            },
            {
                add: function (t) {
                    return r.def(s(this, i), t, !0);
                },
            },
            r,
            !1,
            !0
        );
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(64),
            i = n(89),
            o = n(5),
            a = n(36),
            c = n(8),
            l = n(6),
            u = n(3).ArrayBuffer,
            h = n(52),
            p = i.ArrayBuffer,
            d = i.DataView,
            f = s.ABV && u.isView,
            m = p.prototype.slice,
            y = s.VIEW,
            g = "ArrayBuffer";
        r(r.G + r.W + r.F * (u !== p), { ArrayBuffer: p }),
            r(r.S + r.F * !s.CONSTR, g, {
                isView: function (t) {
                    return (f && f(t)) || (l(t) && y in t);
                },
            }),
            r(
                r.P +
                    r.U +
                    r.F *
                        n(4)(function () {
                            return !new p(2).slice(1, void 0).byteLength;
                        }),
                g,
                {
                    slice: function (t, e) {
                        if (void 0 !== m && void 0 === e)
                            return m.call(o(this), t);
                        for (
                            var n = o(this).byteLength,
                                r = a(t, n),
                                s = a(void 0 === e ? n : e, n),
                                i = new (h(this, p))(c(s - r)),
                                l = new d(this),
                                u = new d(i),
                                f = 0;
                            r < s;

                        )
                            u.setUint8(f++, l.getUint8(r++));
                        return i;
                    },
                }
            ),
            n(46)(g);
    },
    function (t, e, n) {
        var r = n(2);
        r(r.G + r.W + r.F * !n(64).ABV, { DataView: n(89).DataView });
    },
    function (t, e, n) {
        n(29)("Int8", 1, function (t) {
            return function (e, n, r) {
                return t(this, e, n, r);
            };
        });
    },
    function (t, e, n) {
        n(29)("Uint8", 1, function (t) {
            return function (e, n, r) {
                return t(this, e, n, r);
            };
        });
    },
    function (t, e, n) {
        n(29)(
            "Uint8",
            1,
            function (t) {
                return function (e, n, r) {
                    return t(this, e, n, r);
                };
            },
            !0
        );
    },
    function (t, e, n) {
        n(29)("Int16", 2, function (t) {
            return function (e, n, r) {
                return t(this, e, n, r);
            };
        });
    },
    function (t, e, n) {
        n(29)("Uint16", 2, function (t) {
            return function (e, n, r) {
                return t(this, e, n, r);
            };
        });
    },
    function (t, e, n) {
        n(29)("Int32", 4, function (t) {
            return function (e, n, r) {
                return t(this, e, n, r);
            };
        });
    },
    function (t, e, n) {
        n(29)("Uint32", 4, function (t) {
            return function (e, n, r) {
                return t(this, e, n, r);
            };
        });
    },
    function (t, e, n) {
        n(29)("Float32", 4, function (t) {
            return function (e, n, r) {
                return t(this, e, n, r);
            };
        });
    },
    function (t, e, n) {
        n(29)("Float64", 8, function (t) {
            return function (e, n, r) {
                return t(this, e, n, r);
            };
        });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(22),
            i = n(5),
            o = (n(3).Reflect || {}).apply,
            a = Function.apply;
        r(
            r.S +
                r.F *
                    !n(4)(function () {
                        o(function () {});
                    }),
            "Reflect",
            {
                apply: function (t, e, n) {
                    var r = s(t),
                        c = i(n);
                    return o ? o(r, e, c) : a.call(r, e, c);
                },
            }
        );
    },
    function (t, e, n) {
        var r = n(2),
            s = n(37),
            i = n(22),
            o = n(5),
            a = n(6),
            c = n(4),
            l = n(100),
            u = (n(3).Reflect || {}).construct,
            h = c(function () {
                function t() {}
                return !(u(function () {}, [], t) instanceof t);
            }),
            p = !c(function () {
                u(function () {});
            });
        r(r.S + r.F * (h || p), "Reflect", {
            construct: function (t, e) {
                i(t), o(e);
                var n = arguments.length < 3 ? t : i(arguments[2]);
                if (p && !h) return u(t, e, n);
                if (t == n) {
                    switch (e.length) {
                        case 0:
                            return new t();
                        case 1:
                            return new t(e[0]);
                        case 2:
                            return new t(e[0], e[1]);
                        case 3:
                            return new t(e[0], e[1], e[2]);
                        case 4:
                            return new t(e[0], e[1], e[2], e[3]);
                    }
                    var r = [null];
                    return r.push.apply(r, e), new (l.apply(t, r))();
                }
                var c = n.prototype,
                    d = s(a(c) ? c : Object.prototype),
                    f = Function.apply.call(t, d, e);
                return a(f) ? f : d;
            },
        });
    },
    function (t, e, n) {
        var r = n(11),
            s = n(2),
            i = n(5),
            o = n(30);
        s(
            s.S +
                s.F *
                    n(4)(function () {
                        Reflect.defineProperty(r.f({}, 1, { value: 1 }), 1, {
                            value: 2,
                        });
                    }),
            "Reflect",
            {
                defineProperty: function (t, e, n) {
                    i(t), (e = o(e, !0)), i(n);
                    try {
                        return r.f(t, e, n), !0;
                    } catch (t) {
                        return !1;
                    }
                },
            }
        );
    },
    function (t, e, n) {
        var r = n(2),
            s = n(24).f,
            i = n(5);
        r(r.S, "Reflect", {
            deleteProperty: function (t, e) {
                var n = s(i(t), e);
                return !(n && !n.configurable) && delete t[e];
            },
        });
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(5),
            i = function (t) {
                (this._t = s(t)), (this._i = 0);
                var e,
                    n = (this._k = []);
                for (e in t) n.push(e);
            };
        n(107)(i, "Object", function () {
            var t,
                e = this,
                n = e._k;
            do {
                if (e._i >= n.length) return { value: void 0, done: !0 };
            } while (!((t = n[e._i++]) in e._t));
            return { value: t, done: !1 };
        }),
            r(r.S, "Reflect", {
                enumerate: function (t) {
                    return new i(t);
                },
            });
    },
    function (t, e, n) {
        var r = n(24),
            s = n(39),
            i = n(16),
            o = n(2),
            a = n(6),
            c = n(5);
        o(o.S, "Reflect", {
            get: function t(e, n) {
                var o,
                    l,
                    u = arguments.length < 3 ? e : arguments[2];
                return c(e) === u
                    ? e[n]
                    : (o = r.f(e, n))
                    ? i(o, "value")
                        ? o.value
                        : void 0 !== o.get
                        ? o.get.call(u)
                        : void 0
                    : a((l = s(e)))
                    ? t(l, n, u)
                    : void 0;
            },
        });
    },
    function (t, e, n) {
        var r = n(24),
            s = n(2),
            i = n(5);
        s(s.S, "Reflect", {
            getOwnPropertyDescriptor: function (t, e) {
                return r.f(i(t), e);
            },
        });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(39),
            i = n(5);
        r(r.S, "Reflect", {
            getPrototypeOf: function (t) {
                return s(i(t));
            },
        });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Reflect", {
            has: function (t, e) {
                return e in t;
            },
        });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(5),
            i = Object.isExtensible;
        r(r.S, "Reflect", {
            isExtensible: function (t) {
                return s(t), !i || i(t);
            },
        });
    },
    function (t, e, n) {
        var r = n(2);
        r(r.S, "Reflect", { ownKeys: n(121) });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(5),
            i = Object.preventExtensions;
        r(r.S, "Reflect", {
            preventExtensions: function (t) {
                s(t);
                try {
                    return i && i(t), !0;
                } catch (t) {
                    return !1;
                }
            },
        });
    },
    function (t, e, n) {
        var r = n(11),
            s = n(24),
            i = n(39),
            o = n(16),
            a = n(2),
            c = n(32),
            l = n(5),
            u = n(6);
        a(a.S, "Reflect", {
            set: function t(e, n, a) {
                var h,
                    p,
                    d = arguments.length < 4 ? e : arguments[3],
                    f = s.f(l(e), n);
                if (!f) {
                    if (u((p = i(e)))) return t(p, n, a, d);
                    f = c(0);
                }
                if (o(f, "value")) {
                    if (!1 === f.writable || !u(d)) return !1;
                    if ((h = s.f(d, n))) {
                        if (h.get || h.set || !1 === h.writable) return !1;
                        (h.value = a), r.f(d, n, h);
                    } else r.f(d, n, c(0, a));
                    return !0;
                }
                return void 0 !== f.set && (f.set.call(d, a), !0);
            },
        });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(70);
        s &&
            r(r.S, "Reflect", {
                setPrototypeOf: function (t, e) {
                    s.check(t, e);
                    try {
                        return s.set(t, e), !0;
                    } catch (t) {
                        return !1;
                    }
                },
            });
    },
    function (t, e, n) {
        n(315), (t.exports = n(9).Array.includes);
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(54)(!0);
        r(r.P, "Array", {
            includes: function (t) {
                return s(this, t, arguments.length > 1 ? arguments[1] : void 0);
            },
        }),
            n(40)("includes");
    },
    function (t, e, n) {
        n(317), (t.exports = n(9).Array.flatMap);
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(318),
            i = n(12),
            o = n(8),
            a = n(22),
            c = n(109);
        r(r.P, "Array", {
            flatMap: function (t) {
                var e,
                    n,
                    r = i(this);
                return (
                    a(t),
                    (e = o(r.length)),
                    (n = c(r, 0)),
                    s(n, r, r, e, 0, 1, t, arguments[1]),
                    n
                );
            },
        }),
            n(40)("flatMap");
    },
    function (t, e, n) {
        "use strict";
        var r = n(56),
            s = n(6),
            i = n(8),
            o = n(21),
            a = n(7)("isConcatSpreadable");
        t.exports = function t(e, n, c, l, u, h, p, d) {
            for (var f, m, y = u, g = 0, v = !!p && o(p, d, 3); g < l; ) {
                if (g in c) {
                    if (
                        ((f = v ? v(c[g], g, n) : c[g]),
                        (m = !1),
                        s(f) && (m = void 0 !== (m = f[a]) ? !!m : r(f)),
                        m && h > 0)
                    )
                        y = t(e, n, f, i(f.length), y, h - 1) - 1;
                    else {
                        if (y >= 9007199254740991) throw TypeError();
                        e[y] = f;
                    }
                    y++;
                }
                g++;
            }
            return y;
        };
    },
    function (t, e, n) {
        n(320), (t.exports = n(9).String.padStart);
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(122),
            i = n(62),
            o = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(i);
        r(r.P + r.F * o, "String", {
            padStart: function (t) {
                return s(
                    this,
                    t,
                    arguments.length > 1 ? arguments[1] : void 0,
                    !0
                );
            },
        });
    },
    function (t, e, n) {
        n(322), (t.exports = n(9).String.padEnd);
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(122),
            i = n(62),
            o = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(i);
        r(r.P + r.F * o, "String", {
            padEnd: function (t) {
                return s(
                    this,
                    t,
                    arguments.length > 1 ? arguments[1] : void 0,
                    !1
                );
            },
        });
    },
    function (t, e, n) {
        n(324), (t.exports = n(9).String.trimLeft);
    },
    function (t, e, n) {
        "use strict";
        n(44)(
            "trimLeft",
            function (t) {
                return function () {
                    return t(this, 1);
                };
            },
            "trimStart"
        );
    },
    function (t, e, n) {
        n(326), (t.exports = n(9).String.trimRight);
    },
    function (t, e, n) {
        "use strict";
        n(44)(
            "trimRight",
            function (t) {
                return function () {
                    return t(this, 2);
                };
            },
            "trimEnd"
        );
    },
    function (t, e, n) {
        n(328), (t.exports = n(66).f("asyncIterator"));
    },
    function (t, e, n) {
        n(94)("asyncIterator");
    },
    function (t, e, n) {
        n(330), (t.exports = n(9).Object.getOwnPropertyDescriptors);
    },
    function (t, e, n) {
        var r = n(2),
            s = n(121),
            i = n(18),
            o = n(24),
            a = n(82);
        r(r.S, "Object", {
            getOwnPropertyDescriptors: function (t) {
                for (
                    var e, n, r = i(t), c = o.f, l = s(r), u = {}, h = 0;
                    l.length > h;

                )
                    void 0 !== (n = c(r, (e = l[h++]))) && a(u, e, n);
                return u;
            },
        });
    },
    function (t, e, n) {
        n(332), (t.exports = n(9).Object.values);
    },
    function (t, e, n) {
        var r = n(2),
            s = n(123)(!1);
        r(r.S, "Object", {
            values: function (t) {
                return s(t);
            },
        });
    },
    function (t, e, n) {
        n(334), (t.exports = n(9).Object.entries);
    },
    function (t, e, n) {
        var r = n(2),
            s = n(123)(!0);
        r(r.S, "Object", {
            entries: function (t) {
                return s(t);
            },
        });
    },
    function (t, e, n) {
        "use strict";
        n(115), n(336), (t.exports = n(9).Promise.finally);
    },
    function (t, e, n) {
        "use strict";
        var r = n(2),
            s = n(9),
            i = n(3),
            o = n(52),
            a = n(117);
        r(r.P + r.R, "Promise", {
            finally: function (t) {
                var e = o(this, s.Promise || i.Promise),
                    n = "function" == typeof t;
                return this.then(
                    n
                        ? function (n) {
                              return a(e, t()).then(function () {
                                  return n;
                              });
                          }
                        : t,
                    n
                        ? function (n) {
                              return a(e, t()).then(function () {
                                  throw n;
                              });
                          }
                        : t
                );
            },
        });
    },
    function (t, e, n) {
        n(338), n(339), n(340), (t.exports = n(9));
    },
    function (t, e, n) {
        var r = n(3),
            s = n(2),
            i = n(62),
            o = [].slice,
            a = /MSIE .\./.test(i),
            c = function (t) {
                return function (e, n) {
                    var r = arguments.length > 2,
                        s = !!r && o.call(arguments, 2);
                    return t(
                        r
                            ? function () {
                                  ("function" == typeof e
                                      ? e
                                      : Function(e)
                                  ).apply(this, s);
                              }
                            : e,
                        n
                    );
                };
            };
        s(s.G + s.B + s.F * a, {
            setTimeout: c(r.setTimeout),
            setInterval: c(r.setInterval),
        });
    },
    function (t, e, n) {
        var r = n(2),
            s = n(88);
        r(r.G + r.B, { setImmediate: s.set, clearImmediate: s.clear });
    },
    function (t, e, n) {
        for (
            var r = n(85),
                s = n(35),
                i = n(13),
                o = n(3),
                a = n(17),
                c = n(45),
                l = n(7),
                u = l("iterator"),
                h = l("toStringTag"),
                p = c.Array,
                d = {
                    CSSRuleList: !0,
                    CSSStyleDeclaration: !1,
                    CSSValueList: !1,
                    ClientRectList: !1,
                    DOMRectList: !1,
                    DOMStringList: !1,
                    DOMTokenList: !0,
                    DataTransferItemList: !1,
                    FileList: !1,
                    HTMLAllCollection: !1,
                    HTMLCollection: !1,
                    HTMLFormElement: !1,
                    HTMLSelectElement: !1,
                    MediaList: !0,
                    MimeTypeArray: !1,
                    NamedNodeMap: !1,
                    NodeList: !0,
                    PaintRequestList: !1,
                    Plugin: !1,
                    PluginArray: !1,
                    SVGLengthList: !1,
                    SVGNumberList: !1,
                    SVGPathSegList: !1,
                    SVGPointList: !1,
                    SVGStringList: !1,
                    SVGTransformList: !1,
                    SourceBufferList: !1,
                    StyleSheetList: !0,
                    TextTrackCueList: !1,
                    TextTrackList: !1,
                    TouchList: !1,
                },
                f = s(d),
                m = 0;
            m < f.length;
            m++
        ) {
            var y,
                g = f[m],
                v = d[g],
                b = o[g],
                x = b && b.prototype;
            if (x && (x[u] || a(x, u, p), x[h] || a(x, h, g), (c[g] = p), v))
                for (y in r) x[y] || i(x, y, r[y], !0);
        }
    },
    function (t, e, n) {
        var r = (function (t) {
            "use strict";
            var e,
                n = Object.prototype,
                r = n.hasOwnProperty,
                s = "function" == typeof Symbol ? Symbol : {},
                i = s.iterator || "@@iterator",
                o = s.asyncIterator || "@@asyncIterator",
                a = s.toStringTag || "@@toStringTag";
            function c(t, e, n) {
                return (
                    Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                    }),
                    t[e]
                );
            }
            try {
                c({}, "");
            } catch (t) {
                c = function (t, e, n) {
                    return (t[e] = n);
                };
            }
            function l(t, e, n, r) {
                var s = e && e.prototype instanceof y ? e : y,
                    i = Object.create(s.prototype),
                    o = new O(r || []);
                return (
                    (i._invoke = (function (t, e, n) {
                        var r = h;
                        return function (s, i) {
                            if (r === d)
                                throw new Error("Generator is already running");
                            if (r === f) {
                                if ("throw" === s) throw i;
                                return _();
                            }
                            for (n.method = s, n.arg = i; ; ) {
                                var o = n.delegate;
                                if (o) {
                                    var a = T(o, n);
                                    if (a) {
                                        if (a === m) continue;
                                        return a;
                                    }
                                }
                                if ("next" === n.method)
                                    n.sent = n._sent = n.arg;
                                else if ("throw" === n.method) {
                                    if (r === h) throw ((r = f), n.arg);
                                    n.dispatchException(n.arg);
                                } else
                                    "return" === n.method &&
                                        n.abrupt("return", n.arg);
                                r = d;
                                var c = u(t, e, n);
                                if ("normal" === c.type) {
                                    if (((r = n.done ? f : p), c.arg === m))
                                        continue;
                                    return { value: c.arg, done: n.done };
                                }
                                "throw" === c.type &&
                                    ((r = f),
                                    (n.method = "throw"),
                                    (n.arg = c.arg));
                            }
                        };
                    })(t, n, o)),
                    i
                );
            }
            function u(t, e, n) {
                try {
                    return { type: "normal", arg: t.call(e, n) };
                } catch (t) {
                    return { type: "throw", arg: t };
                }
            }
            t.wrap = l;
            var h = "suspendedStart",
                p = "suspendedYield",
                d = "executing",
                f = "completed",
                m = {};
            function y() {}
            function g() {}
            function v() {}
            var b = {};
            b[i] = function () {
                return this;
            };
            var x = Object.getPrototypeOf,
                w = x && x(x(k([])));
            w && w !== n && r.call(w, i) && (b = w);
            var P = (v.prototype = y.prototype = Object.create(b));
            function A(t) {
                ["next", "throw", "return"].forEach(function (e) {
                    c(t, e, function (t) {
                        return this._invoke(e, t);
                    });
                });
            }
            function E(t, e) {
                var n;
                this._invoke = function (s, i) {
                    function o() {
                        return new e(function (n, o) {
                            !(function n(s, i, o, a) {
                                var c = u(t[s], t, i);
                                if ("throw" !== c.type) {
                                    var l = c.arg,
                                        h = l.value;
                                    return h &&
                                        "object" == typeof h &&
                                        r.call(h, "__await")
                                        ? e.resolve(h.__await).then(
                                              function (t) {
                                                  n("next", t, o, a);
                                              },
                                              function (t) {
                                                  n("throw", t, o, a);
                                              }
                                          )
                                        : e.resolve(h).then(
                                              function (t) {
                                                  (l.value = t), o(l);
                                              },
                                              function (t) {
                                                  return n("throw", t, o, a);
                                              }
                                          );
                                }
                                a(c.arg);
                            })(s, i, n, o);
                        });
                    }
                    return (n = n ? n.then(o, o) : o());
                };
            }
            function T(t, n) {
                var r = t.iterator[n.method];
                if (r === e) {
                    if (((n.delegate = null), "throw" === n.method)) {
                        if (
                            t.iterator.return &&
                            ((n.method = "return"),
                            (n.arg = e),
                            T(t, n),
                            "throw" === n.method)
                        )
                            return m;
                        (n.method = "throw"),
                            (n.arg = new TypeError(
                                "The iterator does not provide a 'throw' method"
                            ));
                    }
                    return m;
                }
                var s = u(r, t.iterator, n.arg);
                if ("throw" === s.type)
                    return (
                        (n.method = "throw"),
                        (n.arg = s.arg),
                        (n.delegate = null),
                        m
                    );
                var i = s.arg;
                return i
                    ? i.done
                        ? ((n[t.resultName] = i.value),
                          (n.next = t.nextLoc),
                          "return" !== n.method &&
                              ((n.method = "next"), (n.arg = e)),
                          (n.delegate = null),
                          m)
                        : i
                    : ((n.method = "throw"),
                      (n.arg = new TypeError(
                          "iterator result is not an object"
                      )),
                      (n.delegate = null),
                      m);
            }
            function S(t) {
                var e = { tryLoc: t[0] };
                1 in t && (e.catchLoc = t[1]),
                    2 in t && ((e.finallyLoc = t[2]), (e.afterLoc = t[3])),
                    this.tryEntries.push(e);
            }
            function C(t) {
                var e = t.completion || {};
                (e.type = "normal"), delete e.arg, (t.completion = e);
            }
            function O(t) {
                (this.tryEntries = [{ tryLoc: "root" }]),
                    t.forEach(S, this),
                    this.reset(!0);
            }
            function k(t) {
                if (t) {
                    var n = t[i];
                    if (n) return n.call(t);
                    if ("function" == typeof t.next) return t;
                    if (!isNaN(t.length)) {
                        var s = -1,
                            o = function n() {
                                for (; ++s < t.length; )
                                    if (r.call(t, s))
                                        return (
                                            (n.value = t[s]), (n.done = !1), n
                                        );
                                return (n.value = e), (n.done = !0), n;
                            };
                        return (o.next = o);
                    }
                }
                return { next: _ };
            }
            function _() {
                return { value: e, done: !0 };
            }
            return (
                (g.prototype = P.constructor = v),
                (v.constructor = g),
                (g.displayName = c(v, a, "GeneratorFunction")),
                (t.isGeneratorFunction = function (t) {
                    var e = "function" == typeof t && t.constructor;
                    return (
                        !!e &&
                        (e === g ||
                            "GeneratorFunction" === (e.displayName || e.name))
                    );
                }),
                (t.mark = function (t) {
                    return (
                        Object.setPrototypeOf
                            ? Object.setPrototypeOf(t, v)
                            : ((t.__proto__ = v), c(t, a, "GeneratorFunction")),
                        (t.prototype = Object.create(P)),
                        t
                    );
                }),
                (t.awrap = function (t) {
                    return { __await: t };
                }),
                A(E.prototype),
                (E.prototype[o] = function () {
                    return this;
                }),
                (t.AsyncIterator = E),
                (t.async = function (e, n, r, s, i) {
                    void 0 === i && (i = Promise);
                    var o = new E(l(e, n, r, s), i);
                    return t.isGeneratorFunction(n)
                        ? o
                        : o.next().then(function (t) {
                              return t.done ? t.value : o.next();
                          });
                }),
                A(P),
                c(P, a, "Generator"),
                (P[i] = function () {
                    return this;
                }),
                (P.toString = function () {
                    return "[object Generator]";
                }),
                (t.keys = function (t) {
                    var e = [];
                    for (var n in t) e.push(n);
                    return (
                        e.reverse(),
                        function n() {
                            for (; e.length; ) {
                                var r = e.pop();
                                if (r in t)
                                    return (n.value = r), (n.done = !1), n;
                            }
                            return (n.done = !0), n;
                        }
                    );
                }),
                (t.values = k),
                (O.prototype = {
                    constructor: O,
                    reset: function (t) {
                        if (
                            ((this.prev = 0),
                            (this.next = 0),
                            (this.sent = this._sent = e),
                            (this.done = !1),
                            (this.delegate = null),
                            (this.method = "next"),
                            (this.arg = e),
                            this.tryEntries.forEach(C),
                            !t)
                        )
                            for (var n in this)
                                "t" === n.charAt(0) &&
                                    r.call(this, n) &&
                                    !isNaN(+n.slice(1)) &&
                                    (this[n] = e);
                    },
                    stop: function () {
                        this.done = !0;
                        var t = this.tryEntries[0].completion;
                        if ("throw" === t.type) throw t.arg;
                        return this.rval;
                    },
                    dispatchException: function (t) {
                        if (this.done) throw t;
                        var n = this;
                        function s(r, s) {
                            return (
                                (a.type = "throw"),
                                (a.arg = t),
                                (n.next = r),
                                s && ((n.method = "next"), (n.arg = e)),
                                !!s
                            );
                        }
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var o = this.tryEntries[i],
                                a = o.completion;
                            if ("root" === o.tryLoc) return s("end");
                            if (o.tryLoc <= this.prev) {
                                var c = r.call(o, "catchLoc"),
                                    l = r.call(o, "finallyLoc");
                                if (c && l) {
                                    if (this.prev < o.catchLoc)
                                        return s(o.catchLoc, !0);
                                    if (this.prev < o.finallyLoc)
                                        return s(o.finallyLoc);
                                } else if (c) {
                                    if (this.prev < o.catchLoc)
                                        return s(o.catchLoc, !0);
                                } else {
                                    if (!l)
                                        throw new Error(
                                            "try statement without catch or finally"
                                        );
                                    if (this.prev < o.finallyLoc)
                                        return s(o.finallyLoc);
                                }
                            }
                        }
                    },
                    abrupt: function (t, e) {
                        for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                            var s = this.tryEntries[n];
                            if (
                                s.tryLoc <= this.prev &&
                                r.call(s, "finallyLoc") &&
                                this.prev < s.finallyLoc
                            ) {
                                var i = s;
                                break;
                            }
                        }
                        i &&
                            ("break" === t || "continue" === t) &&
                            i.tryLoc <= e &&
                            e <= i.finallyLoc &&
                            (i = null);
                        var o = i ? i.completion : {};
                        return (
                            (o.type = t),
                            (o.arg = e),
                            i
                                ? ((this.method = "next"),
                                  (this.next = i.finallyLoc),
                                  m)
                                : this.complete(o)
                        );
                    },
                    complete: function (t, e) {
                        if ("throw" === t.type) throw t.arg;
                        return (
                            "break" === t.type || "continue" === t.type
                                ? (this.next = t.arg)
                                : "return" === t.type
                                ? ((this.rval = this.arg = t.arg),
                                  (this.method = "return"),
                                  (this.next = "end"))
                                : "normal" === t.type && e && (this.next = e),
                            m
                        );
                    },
                    finish: function (t) {
                        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                            var n = this.tryEntries[e];
                            if (n.finallyLoc === t)
                                return (
                                    this.complete(n.completion, n.afterLoc),
                                    C(n),
                                    m
                                );
                        }
                    },
                    catch: function (t) {
                        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                            var n = this.tryEntries[e];
                            if (n.tryLoc === t) {
                                var r = n.completion;
                                if ("throw" === r.type) {
                                    var s = r.arg;
                                    C(n);
                                }
                                return s;
                            }
                        }
                        throw new Error("illegal catch attempt");
                    },
                    delegateYield: function (t, n, r) {
                        return (
                            (this.delegate = {
                                iterator: k(t),
                                resultName: n,
                                nextLoc: r,
                            }),
                            "next" === this.method && (this.arg = e),
                            m
                        );
                    },
                }),
                t
            );
        })(t.exports);
        try {
            regeneratorRuntime = r;
        } catch (t) {
            Function("r", "regeneratorRuntime = r")(r);
        }
    },
    function (t, e, n) {
        n(343), (t.exports = n(124).global);
    },
    function (t, e, n) {
        var r = n(344);
        r(r.G, { global: n(90) });
    },
    function (t, e, n) {
        var r = n(90),
            s = n(124),
            i = n(345),
            o = n(347),
            a = n(354),
            c = function (t, e, n) {
                var l,
                    u,
                    h,
                    p = t & c.F,
                    d = t & c.G,
                    f = t & c.S,
                    m = t & c.P,
                    y = t & c.B,
                    g = t & c.W,
                    v = d ? s : s[e] || (s[e] = {}),
                    b = v.prototype,
                    x = d ? r : f ? r[e] : (r[e] || {}).prototype;
                for (l in (d && (n = e), n))
                    ((u = !p && x && void 0 !== x[l]) && a(v, l)) ||
                        ((h = u ? x[l] : n[l]),
                        (v[l] =
                            d && "function" != typeof x[l]
                                ? n[l]
                                : y && u
                                ? i(h, r)
                                : g && x[l] == h
                                ? (function (t) {
                                      var e = function (e, n, r) {
                                          if (this instanceof t) {
                                              switch (arguments.length) {
                                                  case 0:
                                                      return new t();
                                                  case 1:
                                                      return new t(e);
                                                  case 2:
                                                      return new t(e, n);
                                              }
                                              return new t(e, n, r);
                                          }
                                          return t.apply(this, arguments);
                                      };
                                      return (e.prototype = t.prototype), e;
                                  })(h)
                                : m && "function" == typeof h
                                ? i(Function.call, h)
                                : h),
                        m &&
                            (((v.virtual || (v.virtual = {}))[l] = h),
                            t & c.R && b && !b[l] && o(b, l, h)));
            };
        (c.F = 1),
            (c.G = 2),
            (c.S = 4),
            (c.P = 8),
            (c.B = 16),
            (c.W = 32),
            (c.U = 64),
            (c.R = 128),
            (t.exports = c);
    },
    function (t, e, n) {
        var r = n(346);
        t.exports = function (t, e, n) {
            if ((r(t), void 0 === e)) return t;
            switch (n) {
                case 1:
                    return function (n) {
                        return t.call(e, n);
                    };
                case 2:
                    return function (n, r) {
                        return t.call(e, n, r);
                    };
                case 3:
                    return function (n, r, s) {
                        return t.call(e, n, r, s);
                    };
            }
            return function () {
                return t.apply(e, arguments);
            };
        };
    },
    function (t, e) {
        t.exports = function (t) {
            if ("function" != typeof t)
                throw TypeError(t + " is not a function!");
            return t;
        };
    },
    function (t, e, n) {
        var r = n(348),
            s = n(353);
        t.exports = n(92)
            ? function (t, e, n) {
                  return r.f(t, e, s(1, n));
              }
            : function (t, e, n) {
                  return (t[e] = n), t;
              };
    },
    function (t, e, n) {
        var r = n(349),
            s = n(350),
            i = n(352),
            o = Object.defineProperty;
        e.f = n(92)
            ? Object.defineProperty
            : function (t, e, n) {
                  if ((r(t), (e = i(e, !0)), r(n), s))
                      try {
                          return o(t, e, n);
                      } catch (t) {}
                  if ("get" in n || "set" in n)
                      throw TypeError("Accessors not supported!");
                  return "value" in n && (t[e] = n.value), t;
              };
    },
    function (t, e, n) {
        var r = n(91);
        t.exports = function (t) {
            if (!r(t)) throw TypeError(t + " is not an object!");
            return t;
        };
    },
    function (t, e, n) {
        t.exports =
            !n(92) &&
            !n(125)(function () {
                return (
                    7 !=
                    Object.defineProperty(n(351)("div"), "a", {
                        get: function () {
                            return 7;
                        },
                    }).a
                );
            });
    },
    function (t, e, n) {
        var r = n(91),
            s = n(90).document,
            i = r(s) && r(s.createElement);
        t.exports = function (t) {
            return i ? s.createElement(t) : {};
        };
    },
    function (t, e, n) {
        var r = n(91);
        t.exports = function (t, e) {
            if (!r(t)) return t;
            var n, s;
            if (
                e &&
                "function" == typeof (n = t.toString) &&
                !r((s = n.call(t)))
            )
                return s;
            if ("function" == typeof (n = t.valueOf) && !r((s = n.call(t))))
                return s;
            if (
                !e &&
                "function" == typeof (n = t.toString) &&
                !r((s = n.call(t)))
            )
                return s;
            throw TypeError("Can't convert object to primitive value");
        };
    },
    function (t, e) {
        t.exports = function (t, e) {
            return {
                enumerable: !(1 & t),
                configurable: !(2 & t),
                writable: !(4 & t),
                value: e,
            };
        };
    },
    function (t, e) {
        var n = {}.hasOwnProperty;
        t.exports = function (t, e) {
            return n.call(t, e);
        };
    },
    function (t, e, n) {
        "use strict";
        n.r(e),
            function (t) {
                n(357), n(358);
                var e = n(167),
                    r = n(19),
                    s = Object(e.a)(),
                    i = window.localStorage.getItem("webpSupported");
                null === i
                    ? Object(r.WebpIsSupported)(function (t) {
                          (window.webpSupported = t),
                              window.localStorage.setItem("webpSupported", t),
                              s.mount("#app");
                      })
                    : ((window.webpSupported = "true" === i), s.mount("#app")),
                    t &&
                        t.hot &&
                        t.hot.accept(["./app.ts"], function (t) {
                            window.location.reload();
                        });
            }.call(this, n(356)(t));
    },
    function (t, e) {
        t.exports = function (t) {
            if (!t.webpackPolyfill) {
                var e = Object.create(t);
                e.children || (e.children = []),
                    Object.defineProperty(e, "loaded", {
                        enumerable: !0,
                        get: function () {
                            return e.l;
                        },
                    }),
                    Object.defineProperty(e, "id", {
                        enumerable: !0,
                        get: function () {
                            return e.i;
                        },
                    }),
                    Object.defineProperty(e, "exports", { enumerable: !0 }),
                    (e.webpackPolyfill = 1);
            }
            return e;
        };
    },
    function (t, e, n) {},
    function (t, e, n) {},
    function (t, e, n) {
        "use strict";
        var r = n(15),
            s = n(127),
            i = n(360),
            o = n(133);
        function a(t) {
            var e = new i(t),
                n = s(i.prototype.request, e);
            return r.extend(n, i.prototype, e), r.extend(n, e), n;
        }
        var c = a(n(130));
        (c.Axios = i),
            (c.create = function (t) {
                return a(o(c.defaults, t));
            }),
            (c.Cancel = n(134)),
            (c.CancelToken = n(374)),
            (c.isCancel = n(129)),
            (c.all = function (t) {
                return Promise.all(t);
            }),
            (c.spread = n(375)),
            (t.exports = c),
            (t.exports.default = c);
    },
    function (t, e, n) {
        "use strict";
        var r = n(15),
            s = n(128),
            i = n(361),
            o = n(362),
            a = n(133);
        function c(t) {
            (this.defaults = t),
                (this.interceptors = { request: new i(), response: new i() });
        }
        (c.prototype.request = function (t) {
            "string" == typeof t
                ? ((t = arguments[1] || {}).url = arguments[0])
                : (t = t || {}),
                (t = a(this.defaults, t)).method
                    ? (t.method = t.method.toLowerCase())
                    : this.defaults.method
                    ? (t.method = this.defaults.method.toLowerCase())
                    : (t.method = "get");
            var e = [o, void 0],
                n = Promise.resolve(t);
            for (
                this.interceptors.request.forEach(function (t) {
                    e.unshift(t.fulfilled, t.rejected);
                }),
                    this.interceptors.response.forEach(function (t) {
                        e.push(t.fulfilled, t.rejected);
                    });
                e.length;

            )
                n = n.then(e.shift(), e.shift());
            return n;
        }),
            (c.prototype.getUri = function (t) {
                return (
                    (t = a(this.defaults, t)),
                    s(t.url, t.params, t.paramsSerializer).replace(/^\?/, "")
                );
            }),
            r.forEach(["delete", "get", "head", "options"], function (t) {
                c.prototype[t] = function (e, n) {
                    return this.request(a(n || {}, { method: t, url: e }));
                };
            }),
            r.forEach(["post", "put", "patch"], function (t) {
                c.prototype[t] = function (e, n, r) {
                    return this.request(
                        a(r || {}, { method: t, url: e, data: n })
                    );
                };
            }),
            (t.exports = c);
    },
    function (t, e, n) {
        "use strict";
        var r = n(15);
        function s() {
            this.handlers = [];
        }
        (s.prototype.use = function (t, e) {
            return (
                this.handlers.push({ fulfilled: t, rejected: e }),
                this.handlers.length - 1
            );
        }),
            (s.prototype.eject = function (t) {
                this.handlers[t] && (this.handlers[t] = null);
            }),
            (s.prototype.forEach = function (t) {
                r.forEach(this.handlers, function (e) {
                    null !== e && t(e);
                });
            }),
            (t.exports = s);
    },
    function (t, e, n) {
        "use strict";
        var r = n(15),
            s = n(363),
            i = n(129),
            o = n(130);
        function a(t) {
            t.cancelToken && t.cancelToken.throwIfRequested();
        }
        t.exports = function (t) {
            return (
                a(t),
                (t.headers = t.headers || {}),
                (t.data = s(t.data, t.headers, t.transformRequest)),
                (t.headers = r.merge(
                    t.headers.common || {},
                    t.headers[t.method] || {},
                    t.headers
                )),
                r.forEach(
                    ["delete", "get", "head", "post", "put", "patch", "common"],
                    function (e) {
                        delete t.headers[e];
                    }
                ),
                (t.adapter || o.adapter)(t).then(
                    function (e) {
                        return (
                            a(t),
                            (e.data = s(
                                e.data,
                                e.headers,
                                t.transformResponse
                            )),
                            e
                        );
                    },
                    function (e) {
                        return (
                            i(e) ||
                                (a(t),
                                e &&
                                    e.response &&
                                    (e.response.data = s(
                                        e.response.data,
                                        e.response.headers,
                                        t.transformResponse
                                    ))),
                            Promise.reject(e)
                        );
                    }
                )
            );
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(15);
        t.exports = function (t, e, n) {
            return (
                r.forEach(n, function (n) {
                    t = n(t, e);
                }),
                t
            );
        };
    },
    function (t, e) {
        var n,
            r,
            s = (t.exports = {});
        function i() {
            throw new Error("setTimeout has not been defined");
        }
        function o() {
            throw new Error("clearTimeout has not been defined");
        }
        function a(t) {
            if (n === setTimeout) return setTimeout(t, 0);
            if ((n === i || !n) && setTimeout)
                return (n = setTimeout), setTimeout(t, 0);
            try {
                return n(t, 0);
            } catch (e) {
                try {
                    return n.call(null, t, 0);
                } catch (e) {
                    return n.call(this, t, 0);
                }
            }
        }
        !(function () {
            try {
                n = "function" == typeof setTimeout ? setTimeout : i;
            } catch (t) {
                n = i;
            }
            try {
                r = "function" == typeof clearTimeout ? clearTimeout : o;
            } catch (t) {
                r = o;
            }
        })();
        var c,
            l = [],
            u = !1,
            h = -1;
        function p() {
            u &&
                c &&
                ((u = !1),
                c.length ? (l = c.concat(l)) : (h = -1),
                l.length && d());
        }
        function d() {
            if (!u) {
                var t = a(p);
                u = !0;
                for (var e = l.length; e; ) {
                    for (c = l, l = []; ++h < e; ) c && c[h].run();
                    (h = -1), (e = l.length);
                }
                (c = null),
                    (u = !1),
                    (function (t) {
                        if (r === clearTimeout) return clearTimeout(t);
                        if ((r === o || !r) && clearTimeout)
                            return (r = clearTimeout), clearTimeout(t);
                        try {
                            r(t);
                        } catch (e) {
                            try {
                                return r.call(null, t);
                            } catch (e) {
                                return r.call(this, t);
                            }
                        }
                    })(t);
            }
        }
        function f(t, e) {
            (this.fun = t), (this.array = e);
        }
        function m() {}
        (s.nextTick = function (t) {
            var e = new Array(arguments.length - 1);
            if (arguments.length > 1)
                for (var n = 1; n < arguments.length; n++)
                    e[n - 1] = arguments[n];
            l.push(new f(t, e)), 1 !== l.length || u || a(d);
        }),
            (f.prototype.run = function () {
                this.fun.apply(null, this.array);
            }),
            (s.title = "browser"),
            (s.browser = !0),
            (s.env = {}),
            (s.argv = []),
            (s.version = ""),
            (s.versions = {}),
            (s.on = m),
            (s.addListener = m),
            (s.once = m),
            (s.off = m),
            (s.removeListener = m),
            (s.removeAllListeners = m),
            (s.emit = m),
            (s.prependListener = m),
            (s.prependOnceListener = m),
            (s.listeners = function (t) {
                return [];
            }),
            (s.binding = function (t) {
                throw new Error("process.binding is not supported");
            }),
            (s.cwd = function () {
                return "/";
            }),
            (s.chdir = function (t) {
                throw new Error("process.chdir is not supported");
            }),
            (s.umask = function () {
                return 0;
            });
    },
    function (t, e, n) {
        "use strict";
        var r = n(15);
        t.exports = function (t, e) {
            r.forEach(t, function (n, r) {
                r !== e &&
                    r.toUpperCase() === e.toUpperCase() &&
                    ((t[e] = n), delete t[r]);
            });
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(132);
        t.exports = function (t, e, n) {
            var s = n.config.validateStatus;
            n.status && s && !s(n.status)
                ? e(
                      r(
                          "Request failed with status code " + n.status,
                          n.config,
                          null,
                          n.request,
                          n
                      )
                  )
                : t(n);
        };
    },
    function (t, e, n) {
        "use strict";
        t.exports = function (t, e, n, r, s) {
            return (
                (t.config = e),
                n && (t.code = n),
                (t.request = r),
                (t.response = s),
                (t.isAxiosError = !0),
                (t.toJSON = function () {
                    return {
                        message: this.message,
                        name: this.name,
                        description: this.description,
                        number: this.number,
                        fileName: this.fileName,
                        lineNumber: this.lineNumber,
                        columnNumber: this.columnNumber,
                        stack: this.stack,
                        config: this.config,
                        code: this.code,
                    };
                }),
                t
            );
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(15);
        t.exports = r.isStandardBrowserEnv()
            ? {
                  write: function (t, e, n, s, i, o) {
                      var a = [];
                      a.push(t + "=" + encodeURIComponent(e)),
                          r.isNumber(n) &&
                              a.push("expires=" + new Date(n).toGMTString()),
                          r.isString(s) && a.push("path=" + s),
                          r.isString(i) && a.push("domain=" + i),
                          !0 === o && a.push("secure"),
                          (document.cookie = a.join("; "));
                  },
                  read: function (t) {
                      var e = document.cookie.match(
                          new RegExp("(^|;\\s*)(" + t + ")=([^;]*)")
                      );
                      return e ? decodeURIComponent(e[3]) : null;
                  },
                  remove: function (t) {
                      this.write(t, "", Date.now() - 864e5);
                  },
              }
            : {
                  write: function () {},
                  read: function () {
                      return null;
                  },
                  remove: function () {},
              };
    },
    function (t, e, n) {
        "use strict";
        var r = n(370),
            s = n(371);
        t.exports = function (t, e) {
            return t && !r(e) ? s(t, e) : e;
        };
    },
    function (t, e, n) {
        "use strict";
        t.exports = function (t) {
            return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(t);
        };
    },
    function (t, e, n) {
        "use strict";
        t.exports = function (t, e) {
            return e ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : t;
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(15),
            s = [
                "age",
                "authorization",
                "content-length",
                "content-type",
                "etag",
                "expires",
                "from",
                "host",
                "if-modified-since",
                "if-unmodified-since",
                "last-modified",
                "location",
                "max-forwards",
                "proxy-authorization",
                "referer",
                "retry-after",
                "user-agent",
            ];
        t.exports = function (t) {
            var e,
                n,
                i,
                o = {};
            return t
                ? (r.forEach(t.split("\n"), function (t) {
                      if (
                          ((i = t.indexOf(":")),
                          (e = r.trim(t.substr(0, i)).toLowerCase()),
                          (n = r.trim(t.substr(i + 1))),
                          e)
                      ) {
                          if (o[e] && s.indexOf(e) >= 0) return;
                          o[e] =
                              "set-cookie" === e
                                  ? (o[e] ? o[e] : []).concat([n])
                                  : o[e]
                                  ? o[e] + ", " + n
                                  : n;
                      }
                  }),
                  o)
                : o;
        };
    },
    function (t, e, n) {
        "use strict";
        var r = n(15);
        t.exports = r.isStandardBrowserEnv()
            ? (function () {
                  var t,
                      e = /(msie|trident)/i.test(navigator.userAgent),
                      n = document.createElement("a");
                  function s(t) {
                      var r = t;
                      return (
                          e && (n.setAttribute("href", r), (r = n.href)),
                          n.setAttribute("href", r),
                          {
                              href: n.href,
                              protocol: n.protocol
                                  ? n.protocol.replace(/:$/, "")
                                  : "",
                              host: n.host,
                              search: n.search
                                  ? n.search.replace(/^\?/, "")
                                  : "",
                              hash: n.hash ? n.hash.replace(/^#/, "") : "",
                              hostname: n.hostname,
                              port: n.port,
                              pathname:
                                  "/" === n.pathname.charAt(0)
                                      ? n.pathname
                                      : "/" + n.pathname,
                          }
                      );
                  }
                  return (
                      (t = s(window.location.href)),
                      function (e) {
                          var n = r.isString(e) ? s(e) : e;
                          return n.protocol === t.protocol && n.host === t.host;
                      }
                  );
              })()
            : function () {
                  return !0;
              };
    },
    function (t, e, n) {
        "use strict";
        var r = n(134);
        function s(t) {
            if ("function" != typeof t)
                throw new TypeError("executor must be a function.");
            var e;
            this.promise = new Promise(function (t) {
                e = t;
            });
            var n = this;
            t(function (t) {
                n.reason || ((n.reason = new r(t)), e(n.reason));
            });
        }
        (s.prototype.throwIfRequested = function () {
            if (this.reason) throw this.reason;
        }),
            (s.source = function () {
                var t;
                return {
                    token: new s(function (e) {
                        t = e;
                    }),
                    cancel: t,
                };
            }),
            (t.exports = s);
    },
    function (t, e, n) {
        "use strict";
        t.exports = function (t) {
            return function (e) {
                return t.apply(null, e);
            };
        };
    },
    function (t, e, n) {
        var r = {
            "./actions/copy": 135,
            "./actions/copy.svg": 135,
            "./actions/create-folder": 136,
            "./actions/create-folder.svg": 136,
            "./actions/delete": 137,
            "./actions/delete.svg": 137,
            "./actions/download": 138,
            "./actions/download.svg": 138,
            "./actions/move-folder": 139,
            "./actions/move-folder.svg": 139,
            "./actions/search": 140,
            "./actions/search.svg": 140,
            "./actions/upload-cloud": 141,
            "./actions/upload-cloud.svg": 141,
            "./cancel": 142,
            "./cancel.svg": 142,
            "./crop": 143,
            "./crop.svg": 143,
            "./gears": 144,
            "./gears.svg": 144,
            "./grid-view": 145,
            "./grid-view.svg": 145,
            "./image-edit": 146,
            "./image-edit.svg": 146,
            "./info": 147,
            "./info.svg": 147,
            "./list-view": 148,
            "./list-view.svg": 148,
            "./reflect": 149,
            "./reflect.svg": 149,
            "./reset": 150,
            "./reset.svg": 150,
            "./resize": 151,
            "./resize.svg": 151,
            "./return": 152,
            "./return.svg": 152,
            "./rotate": 153,
            "./rotate.svg": 153,
            "./types/archive": 154,
            "./types/archive.svg": 154,
            "./types/audio": 155,
            "./types/audio.svg": 155,
            "./types/code": 156,
            "./types/code.svg": 156,
            "./types/csv": 157,
            "./types/csv.svg": 157,
            "./types/excel": 158,
            "./types/excel.svg": 158,
            "./types/file": 159,
            "./types/file.svg": 159,
            "./types/folder": 160,
            "./types/folder.svg": 160,
            "./types/image": 161,
            "./types/image.svg": 161,
            "./types/pdf": 162,
            "./types/pdf.svg": 162,
            "./types/video": 163,
            "./types/video.svg": 163,
            "./types/word": 164,
            "./types/word.svg": 164,
        };
        function s(t) {
            var e = i(t);
            return n(e);
        }
        function i(t) {
            if (!n.o(r, t)) {
                var e = new Error("Cannot find module '" + t + "'");
                throw ((e.code = "MODULE_NOT_FOUND"), e);
            }
            return r[t];
        }
        (s.keys = function () {
            return Object.keys(r);
        }),
            (s.resolve = i),
            (t.exports = s),
            (s.id = 376);
    },
]);
